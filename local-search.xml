<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>clickhouse表引擎</title>
    <link href="/2022/02/03/clickhouse%E8%A1%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2022/02/03/clickhouse%E8%A1%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1><span id="表引擎介绍">表引擎介绍</span></h1><p>表引擎是 ClickHouse 的一大特色。不同的引擎有不同的作用，可以说， 表引擎决定了如何存储表的数据。包括：</p><p>➢ 数据的存储方式和位置，写到哪里以及从哪里读取数据。 （一般的引擎都存在磁盘中，但是存在与其他数据库继承的场景，比如和mysql集成，数据放在mysql服务端。）</p><p>➢ 支持哪些查询以及如何支持。（有些语法只有在特定的引擎才可以使用，比如不能在 MergeTree 表中存储多维数组）</p><p>➢ 并发数据访问。（可以多线程执行同一条sql）</p><p>➢ 索引的使用（如果存在）。</p><p>➢ 是否可以执行多线程请求。</p><p>➢ 数据复制参数。</p><blockquote><p>表引擎的使用方式就是必须显式在创建表时定义该表使用的引擎，以及引擎使用的相关参数。</p></blockquote><p><strong>特别注意：引擎的名称大小写敏感</strong></p><h1><span id="合并树家族">合并树家族</span></h1><h2><span id="mergetree"><strong>MergeTree</strong></span></h2><ul><li>ClickHouse 中最强大的表引擎当属 MergeTree（合并树）引擎及该系列（*MergeTree）</li></ul><p>中的其他引擎，支持索引和分区，地位可以相当于 innodb 之于 Mysql。而且基于 MergeTree，</p><ul><li>还衍生除了很多小弟，也是非常有特色的引擎。</li></ul><ol><li><p>建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>),<br>create_time Datetime<br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id,sku_id);<br></code></pre></td></tr></table></figure></li><li><p><strong>插入数据</strong></p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><h3><span id="参数介绍">参数介绍</span></h3><h4><span id="partition-by-分区"><strong>partition by</strong> 分区</span></h4><h5><span id="1-目的">1. 目的</span></h5><p>分区的目的主要是降低扫描的范围，优化查询速度</p><h5><span id="2-可选">2. 可选</span></h5><p>可选的，如果不填，只会使用一个分区。</p><h5><span id="3分区目录">3.<strong>分区目录</strong></span></h5><p>MergeTree 是以列文件+索引文件+表定义文件组成的，但是如果设定了分区那么这些文</p><p>件就会保存到不同的分区目录中。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0c4bfsguj30rw0iqjtg.jpg"></p><h5><span id="4并行">4.<strong>并行</strong></span></h5><p>分区后，面对涉及跨分区的查询统计，ClickHouse 会以分区为单位并行处理。</p><h5><span id="5数据写入与分区合并">5.<strong>数据写入与分区合并</strong></span></h5><ul><li><p>任何一个批次的数据写入都会产生一个临时分区，不会纳入任何一个已有的分区。</p></li><li><p>写入后的某个时刻（大概 10-15 分钟后），ClickHouse 会自动执行合并操作。</p></li><li><p>也可以手动通过 optimize 执行，把临时分区的数据，合并到已有分区中。语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">optimize <span class="hljs-keyword">table</span> xxxx <span class="hljs-keyword">final</span>;<br></code></pre></td></tr></table></figure><p>如：</p><ul><li>再次执行上面的插入操作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>查看数据并没有纳入任何分区</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0c7984cnj30ui0s8wi5.jpg"></p></li><li><p>手动 optimize 之后，再次查询  <img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0c8dbd1bj30og0y6tce.jpg"></p></li></ul><h4><span id="primary-key-主键"><strong>primary key</strong> <strong>主键</strong></span></h4><ul><li>ClickHouse 中的主键，和其他数据库不太一样，<strong>它只提供了数据的一级索引，但是却不</strong></li></ul><p><strong>是唯一约束。</strong>这就意味着是可以存在相同 primary key 的数据的。</p><ul><li><p>主键的设定主要依据是查询语句中的 where 条件。</p></li><li><p>根据条件通过对主键进行某种形式的二分查找，能够定位到对应的 index granularity（粒度）,避免了全表扫描。</p><blockquote><p>index granularity： 直接翻译的话就是索引粒度，指在稀疏索引中两个相邻索引对应数据的间隔。ClickHouse 中的 MergeTree 默认是 8192。官方不建议修改这个值，除非该列存在大量重复值，比如在一个分区中几万行才有一个不同数据。</p></blockquote><p><strong>稀疏索引：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0cf9ividj31460nigq3.jpg"></p><p>稀疏索引的好处就是可以用很少的索引数据，定位更多的数据，代价就是只能定位到索    引粒度的第一行，然后再进行进行一点扫描。</p><blockquote><p>比如要查找id为15151的数据，可以判断出他大于10101 小于32343 ，因此会在这个区域内进行查找，类似的根据二分查找定位到具体的值。</p></blockquote></li></ul><h4><span id="order-by"><strong>order by</strong></span></h4><ul><li><p>order by 设定了分区内的数据按照哪些字段顺序进行有序保存。</p></li><li><p>order by 是 MergeTree 中唯一一个必填项，甚至比 primary key 还重要，因为当用户不</p><p>设置主键的情况，很多处理会依照 order by 的字段进行处理（比如后面会讲的去重和汇总）。</p></li><li><p><strong>要求：主键必须是 order by 字段的前缀字段</strong>。比如 order by 字段是 (id,sku_id) 那么主键必须是 id 或者(id,sku_id)</p></li></ul><h3><span id="跳数索引">跳数索引</span></h3><ul><li><p>MergeTree支持二级索引，又称之为跳数索引，是由数据的聚合信息构建而成。跳数索引的目录也是帮助查询，减少数据扫描的范围。</p></li><li><p>此索引在 <code>CREATE</code> 语句的列部分里定义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">INDEX index_name expr TYPE type(...) GRANULARITY granularity_value<br></code></pre></td></tr></table></figure><ul><li><p><code>*MergeTree</code> 系列的表可以指定跳数索引。</p></li><li><p>跳数索引是指数据片段按照粒度(建表时指定的<code>index_granularity</code>)分割成小块后，将上述SQL的granularity_value数量的小块组合成一个大的块，对这些大块写入索引信息。</p></li><li><p>这样有助于使用<code>where</code>筛选时跳过大量不必要的数据，减少<code>SELECT</code>需要读取的数据量。</p></li><li><p>如：创建测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt2(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>),<br>create_time Datetime,<br>INDEX a total_amount TYPE minmax GRANULARITY <span class="hljs-number">5</span><br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure><blockquote><p>其中 GRANULARITY N 是设定二级索引对于一级索引粒度的粒度。</p><p>即一级索引为[1,3],[3,6],[6,9] ，对应的二级索引范围为[1,9]，将3个一级索引进行了合并，这样查找时就不需要根据一级索引去进行比较，直接根据二级索引就可以。</p></blockquote></li></ul></li></ul><blockquote><p> 目前在 ClickHouse 的官网上二级索引的功能在 v20.1.2.4 之前是被标注为实验性的，在这个版本之后默认是开启的。 </p></blockquote><h3><span id="数据-ttl"><strong>数据</strong> <strong>TTL</strong></span></h3><ul><li><p>TTL 即 Time To Live，TTL用于设置值的生命周期，它既可以为整张表设置，也可以为每个列字段单独设置。表级别的 TTL 还会指定数据在磁盘和卷上自动转移的逻辑（也就是数据过期后可以移动到指定磁盘上）。</p></li><li><p>TTL 表达式的计算结果必须是 <a href="https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/mergetree/">日期</a> 或 <a href="https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/mergetree/">日期时间</a> 类型的字段。</p></li><li><p><code>TTL</code>子句不能被用于主键字段。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">TTL time_column<br>TTL time_column <span class="hljs-operator">+</span> <span class="hljs-type">interval</span><br></code></pre></td></tr></table></figure></li></ul><h4><span id="1列级别-ttl">1.<strong>列级别</strong> <strong>TTL</strong></span></h4><p>当列中的值过期时, ClickHouse会将它们替换成该列数据类型的默认值。如果数据片段中列的所有值均已过期，则ClickHouse 会从文件系统中的数据片段中删除此列。</p><h5><span id="语法">语法</span></h5><p>创建表时指定 <code>TTL</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> example_table<br>(<br>    d DateTime,<br>    a <span class="hljs-type">Int</span> TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">MONTH</span>,<br>    b <span class="hljs-type">Int</span> TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">MONTH</span>,<br>    c String<br>)<br>ENGINE <span class="hljs-operator">=</span> MergeTree<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(d)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> d;<br></code></pre></td></tr></table></figure><p>为表中已存在的列字段添加 <code>TTL</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> example_table<br>    MODIFY <span class="hljs-keyword">COLUMN</span><br>    c String TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>;<br></code></pre></td></tr></table></figure><p><strong>案例演示</strong></p><ul><li><p>创建测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt7(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) TTL create_time<span class="hljs-operator">+</span><span class="hljs-type">interval</span> <span class="hljs-number">10</span> <span class="hljs-keyword">SECOND</span>,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure></li><li><p>插入数据（注意：根据实际时间改变）</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt7 <span class="hljs-keyword">values</span><br>(<span class="hljs-number">106</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2022-02-03 10:44:32&#x27;</span>),<br>(<span class="hljs-number">107</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2022-02-03 10:44:32&#x27;</span>),<br>(<span class="hljs-number">110</span>,<span class="hljs-string">&#x27;sku_003&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2022-02-04 19:20:30&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0ik5e2dtj30ns0fe0u6.jpg"></p><ul><li><p>手动合并，查看效果 到期后，指定的字段数据归 0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">optimize <span class="hljs-keyword">table</span> t_order_mt7 <span class="hljs-keyword">final</span>;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0ilgoy7mj30tc120wi1.jpg"></p><h4><span id="2表-ttl">2.表 TTL</span></h4><ul><li><p>表可以设置一个用于移除过期行的表达式，以及多个用于在磁盘或卷上自动转移数据片段的表达式。当表中的行过期时，ClickHouse 会删除所有对应的行。对于数据片段的转移特性，必须所有的行都满足转移条件。</p></li><li><p>下面的这条语句是数据会在 create_time 之后 10 秒丢失</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_mt3 MODIFY TTL create_time <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">10</span> <span class="hljs-keyword">SECOND</span>;<br></code></pre></td></tr></table></figure></li></ul><h5><span id="案例演示">案例演示</span></h5><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0iqo7gd7j30ze0m476i.jpg"></p><h2><span id="replacingmergetree">ReplacingMergeTree</span></h2><ul><li><p>ReplacingMergeTree 是 MergeTree 的一个变种，它存储特性完全继承 MergeTree，只是多了一个去重的功能。 </p></li><li><p>尽管 MergeTree 可以设置主键，但是 primary key 其实没有唯一约束的功能。如果你想处理掉重复的数据，可以借助这个 ReplacingMergeTree。 </p></li></ul><h3><span id="去重时机"><strong>去重时机</strong></span></h3><p>数据的去重只会在同一批插入（新版本）或合并的过程中出现。合并会在未知的时间在后台进行，所以你无法预</p><p>先作出计划。有一些数据可能仍未被处理。</p><h3><span id="去重范围"><strong>去重范围</strong></span></h3><ul><li><p>如果表经过了分区，去重只会在分区内部进行去重，不能执行跨分区的去重。</p></li><li><p>所以 ReplacingMergeTree 能力有限， ReplacingMergeTree 适用于在后台清除重复的数据以节省空间，但是它不保证没有重复的数据出现。</p></li></ul><h3><span id="案例演示"><strong>案例演示</strong></span></h3><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_rmt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) ,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>ReplacingMergeTree(create_time)<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure><ul><li><p>ReplacingMergeTree() 填入的参数为版本字段，重复数据保留版本字段值最大的。</p></li><li><p>如果不填版本字段，默认按照插入顺序保留最后一条。</p></li></ul><p>（2）向表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_rmt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（3）执行第一次查询</p><p>可以看到插入的数据是根据id和sku_id 去重过的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_order_rmt;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0of9u8h5j30ps0j00ui.jpg"></p><p>（4）再次插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_rmt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>(5) 再次查询，可以看到这次依旧只插入了4条数据，但是和第一次插入的数据没有进行去重，依旧存在重复数据。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0olyjbfej30oo0qgjuc.jpg"></p><p>（6）手动合并</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">OPTIMIZE <span class="hljs-keyword">TABLE</span> t_order_rmt <span class="hljs-keyword">FINAL</span>;<br></code></pre></td></tr></table></figure><p>  (7) 再执行一次查询，此时数据已经根据分区进行了最终去重。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0ovmauddj30ow0imjt6.jpg"></p><h3><span id="案例结论">案例结论</span></h3><p>➢ 实际上是使用 order by 字段作为唯一键</p><p>➢ 去重不能跨分区</p><p>➢ 只有同一批插入（新版本）或合并分区时才会进行去重</p><p>➢ 认定重复的数据保留，版本字段值最大的</p><p>➢ 如果版本字段相同则按插入顺序保留最后一笔</p><h2><span id="summingmergetree"><strong>SummingMergeTree</strong></span></h2><ul><li><p>对于不查询明细，只关心以维度进行汇总聚合结果的场景。如果只使用普通的MergeTree的话，无论是存储空间的开销，还是查询时临时聚合的开销都比较大。</p></li><li><p>ClickHouse 为了这种场景，提供了一种能够“预聚合”的引擎 SummingMergeTree</p></li><li><p>不支持幂等性，当写入100条，写了50条后挂了，后面再次同步100条数据时，会把前50条的数据聚合两次。</p></li></ul><h3><span id="案例演示"><strong>案例演示</strong></span></h3><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_smt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) ,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>SummingMergeTree(total_amount)<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id,sku_id );<br></code></pre></td></tr></table></figure><p>（2）插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_smt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（3）执行第一次查询，可以看到已经做了一次聚合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_order_smt;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0p639ls5j30py0igabu.jpg"></p><p>（4）再次插入一条重复数据，并查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_smt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0p8yhgnfj30pq0liq5h.jpg"></p><p>（5）手动合并,并再次执行查询，可以看到数据已经全部聚合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">OPTIMIZE <span class="hljs-keyword">TABLE</span> t_order_smt <span class="hljs-keyword">FINAL</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0pau5gw1j30oq0qm0ve.jpg"></p><h3><span id="案例结论">案例结论</span></h3><p>➢ 以 SummingMergeTree（）中指定的列作为汇总数据列 </p><p>➢ 以 order by 的列为准，作为维度列</p><p>➢ 可以填写多列必须数字列，如果不填，以所有非维度列且为数字列的字段为汇总数据列</p><p>➢ 其他的列按插入顺序保留第一行</p><p>➢ 不在一个分区的数据不会被聚合</p><p>➢ 只有在同一批次插入(新版本)或分片合并时才会进行聚合</p><h3><span id="能不能直接执行查询-sql-得到汇总值">能不能直接执行查询 SQL 得到汇总值？</span></h3><p>不行，可能会包含一些还没来得及聚合的临时明细如果要是获取汇总值，还是需要使用 sum 进行聚合，这样效率会有一定的提高，但本身 ClickHouse 是列式存储的，效率提升有限，不会特别明显。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> total_amount <span class="hljs-keyword">from</span> XXX <span class="hljs-keyword">where</span> province_name<span class="hljs-operator">=</span>’’ <span class="hljs-keyword">and</span> create_date<span class="hljs-operator">=</span>’xxx’<br></code></pre></td></tr></table></figure><p>改写为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(total_amount) <span class="hljs-keyword">from</span> province_name<span class="hljs-operator">=</span>’’ <span class="hljs-keyword">and</span> create_date<span class="hljs-operator">=</span>‘xxx’<br></code></pre></td></tr></table></figure><h1><span id="集成">集成</span></h1><h2><span id="mysql">MySQL</span></h2><p>MySQL 引擎可以对存储在远程 MySQL 服务器上的数据执行 <code>SELECT</code> 查询和<code>insert</code>插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db.]table_name [<span class="hljs-keyword">ON</span> CLUSTER cluster]<br>(<br>    name1 [type1] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALIAS expr1] [TTL expr1],<br>    name2 [type2] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALIAS expr2] [TTL expr2],<br>    ...<br>) ENGINE <span class="hljs-operator">=</span> MySQL(<span class="hljs-string">&#x27;host:port&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;table&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>[, replace_query, <span class="hljs-string">&#x27;on_duplicate_clause&#x27;</span>])<br>SETTINGS<br>    [connection_pool_size<span class="hljs-operator">=</span><span class="hljs-number">16</span>, ]<br>    [connection_max_tries<span class="hljs-operator">=</span><span class="hljs-number">3</span>, ]<br>    [connection_wait_timeout<span class="hljs-operator">=</span><span class="hljs-number">5</span>, ] <span class="hljs-comment">/* 0 -- do not wait */</span><br>    [connection_auto_close<span class="hljs-operator">=</span><span class="hljs-literal">true</span> ]<br>;<br></code></pre></td></tr></table></figure><p>更多见：<a href="https://clickhouse.com/docs/en/engines/table-engines/integrations/mysql/">MySQL | ClickHouse Documentation</a></p><h1><span id="日志系列">日志系列</span></h1><ul><li>这些引擎是为了需要写入许多小数据量（少于一百万行）的表的场景而开发的。</li><li>这系列的引擎有：<ul><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/stripelog/">StripeLog</a></li><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/log/">日志</a></li><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/tinylog/">TinyLog</a></li></ul></li></ul><h2><span id="tinylog">TinyLog</span></h2><p>以列文件的形式保存在磁盘上，不支持索引，没有并发控制。一般保存少量数据的小表，</p><p>生产环境上作用有限。可以用于平时练习测试用。</p><h2><span id></span></h2>]]></content>
    
    
    <categories>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse基本数据类型</title>
    <link href="/2022/02/01/clickhouse%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/02/01/clickhouse%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1><span id="clickhouse基本数据类型">clickhouse基本数据类型</span></h1><h2><span id="整型"><strong>整型</strong></span></h2><p>固定长度的整型，包括有符号整型或无符号整型。</p><p>整型范围（-2n-1~2n-1-1）：</p><p>Int8 - [-128 : 127]</p><p>Int16 - [-32768 : 32767]</p><p>Int32 - [-2147483648 : 2147483647]</p><p>Int64 - [-9223372036854775808 : 9223372036854775807]</p><p>无符号整型范围（0~2n-1）：</p><p>UInt8 - [0 : 255]</p><p>UInt16 - [0 : 65535]</p><p>UInt32 - [0 : 4294967295]</p><p>UInt64 - [0 : 18446744073709551615]</p><blockquote><p>使用场景： 个数、数量、也可以存储型id</p></blockquote><h2><span id="浮点型"><strong>浮点型</strong></span></h2><p>Float32 - float</p><p>Float64 – double</p><p>建议尽可能以整数形式存储数据。例如，将固定精度的数字转换为整数值，如时间用毫秒为单位表示，因为浮点型进行计算时可能引起四舍五入的误差。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">select</span> <span class="hljs-number">1.0</span><span class="hljs-number">-0.9</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1.</span> <span class="hljs-operator">-</span> <span class="hljs-number">0.9</span><br><br>Query id: <span class="hljs-number">82</span>a9fb29<span class="hljs-number">-9</span>ac3<span class="hljs-number">-41</span>a1<span class="hljs-number">-918</span>d<span class="hljs-operator">-</span>a37ec7bff333<br><br>┌──────minus(<span class="hljs-number">1.</span>, <span class="hljs-number">0.9</span>)─┐<br>│ <span class="hljs-number">0.09999999999999998</span> │<br>└─────────────────────┘<br><br><span class="hljs-number">1</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> set. Elapsed: <span class="hljs-number">0.010</span> sec.<br></code></pre></td></tr></table></figure><blockquote><p>使用场景：一般数据值比较小，不涉及大量的统计计算，精度要求不高的时候。比如保存商品的重量。</p></blockquote><h2><span id="布尔型">布尔型</span></h2><p>没有单独的类型来存储布尔值。可以使用 UInt8 类型，取值限制为 0 或 1。</p><h2><span id="decimal-型"><strong>Decimal</strong> <strong>型</strong></span></h2><p>有符号的浮点数，可在加、减和乘法运算过程中保持精度。对于除法，最低有效数字会</p><p>被丢弃（不舍入）。</p><p>有三种声明：</p><p>➢ Decimal32(s)，相当于 Decimal(9-s,s)，有效位数为 1~9</p><p>➢ Decimal64(s)，相当于 Decimal(18-s,s)，有效位数为 1~18</p><p>➢ Decimal128(s)，相当于 Decimal(38-s,s)，有效位数为 1~38</p><p><strong>s 标识小数位</strong></p><blockquote><p>使用场景： 一般金额字段、汇率、利率等字段为了保证小数点精度，都使用 Decimal</p><p>进行存储。</p></blockquote><h2><span id="字符串"><strong>字符串</strong></span></h2><ul><li>String</li></ul><p>字符串可以任意长度的。它可以包含任意的字节集，包含空字节。</p><ul><li>FixedString(N)</li></ul><p>固定长度 N 的字符串，N 必须是严格的正自然数。当服务端读取长度小于 N 的字符</p><p>串时候，通过在字符串末尾添加空字节来达到 N 字节长度。 当服务端读取长度大于 N 的</p><p>字符串时候，将返回错误消息。</p><p>与 String 相比，极少会使用 FixedString，因为使用起来不是很方便。</p><blockquote><p>使用场景：名称、文字描述、字符型编码。 固定长度的可以保存一些定长的内容，比</p><p>如一些编码，性别等但是考虑到一定的变化风险，带来收益不够明显，所以定长字符串使用意义有限。</p></blockquote><h2><span id="枚举类型"><strong>枚举类型</strong></span></h2><p>包括 Enum8 和 Enum16 类型。Enum 保存 ‘string’= integer 的对应关系。</p><ul><li><p>Enum8 用 ‘String’= Int8 对描述。</p></li><li><p>Enum16 用 ‘String’= Int16 对描述。</p></li></ul><h3><span id="用法示例">用法示例</span></h3><ul><li><p>创建一个带有一个枚举 Enum8(‘hello’ = 1, ‘world’ = 2) 类型的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_enum<br>                (<br>                x Enum8(<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>)<br>                )<br>                ENGINE <span class="hljs-operator">=</span> TinyLog;<br></code></pre></td></tr></table></figure></li><li><p><strong>这个</strong> <strong>x</strong> 列只能存储类型定义中列出的值：hello或world</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_enum <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;hello&#x27;</span>), (<span class="hljs-string">&#x27;world&#x27;</span>), (<span class="hljs-string">&#x27;hello&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyye8yqx9pj30u00u9mz9.jpg"></p><ul><li><strong>如果需要看到对应行的数值，则必须将</strong> <strong>Enum</strong> <strong>值转换为整数类型</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :)  <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>(x, <span class="hljs-string">&#x27;Int8&#x27;</span>) <span class="hljs-keyword">FROM</span> t_enum;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyye7wjb2nj30qw0g83zh.jpg"></p><blockquote><p>使用场景：对一些状态、类型的字段算是一种空间优化，也算是一种数据约束。但是实</p><p>际使用中往往因为一些数据内容的变化增加一定的维护成本，甚至是数据丢失问题。所以谨慎使用。</p></blockquote><h2><span id="时间类型"><strong>时间类型</strong></span></h2><p>目前 ClickHouse 有三种时间类型</p><p>➢ Date 接受<code>年-月-日</code>的字符串比如 ‘2019-12-16’ </p><p>➢ Datetime 接受<code>年-月-日 时:分:秒</code>的字符串比如 ‘2019-12-16 20:50:10’ </p><p>➢ Datetime64 接受<code>年-月-日 时:分:秒.亚秒</code>的字符串比如‘2019-12-16 20:50:10.66’</p><h2><span id="数组"><strong>数组</strong></span></h2><p>Array(T)：由 T 类型元素组成的数组。</p><p>T 可以是任意类型，包含数组类型。 但不推荐使用多维数组，ClickHouse 对多维数组</p><p>的支持有限。例如，不能在 MergeTree 表中存储多维数组。</p><ul><li>创建数组方式 1，使用 array 函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> x, toTypeName(x) ;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyye721a9uj30ry0hkgn4.jpg"></p><ul><li>创建数组方式 2：使用方括号</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-keyword">AS</span> x, toTypeName(x);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyye7bn8x2j30oo0ecwfg.jpg"></p><p>还有很多数据结构，可以参考官方文档：<a href="https://clickhouse.com/docs/zh/sql-reference/data-types/">简介 | ClickHouse文档</a></p>]]></content>
    
    
    <categories>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 安装clickhouse</title>
    <link href="/2022/02/01/docker-%E5%AE%89%E8%A3%85clickhouse/"/>
    <url>/2022/02/01/docker-%E5%AE%89%E8%A3%85clickhouse/</url>
    
    <content type="html"><![CDATA[<p>1.启动容器服务，加载镜像</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker run <span class="hljs-operator">-</span>d <span class="hljs-comment">--name ch-server --ulimit nofile=262144:262144 -p 8123:8123 -p 9000:9000 -p 9009:9009 yandex/clickhouse-server</span><br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyycj48p14j31py0g4tcd.jpg"></p><p>2.查看服务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker ps<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyycjh5146j31yy05075c.jpg"></p><p>3.进入docker容器内，使用用户名和密码连接数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker <span class="hljs-keyword">exec</span> <span class="hljs-operator">-</span>it <span class="hljs-number">46</span>bb792f7762 <span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>bash<br>root<span class="hljs-variable">@46bb792f7762</span>:<span class="hljs-operator">/</span># clickhouse<span class="hljs-operator">-</span>client<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyycl6slqwj30w008qjsx.jpg"></p><blockquote><p>如果有密码，输入下面命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span>root<span class="hljs-variable">@46bb792f7762</span>:<span class="hljs-operator">/</span># clickhouse<span class="hljs-operator">-</span>client <span class="hljs-operator">-</span>u <span class="hljs-keyword">default</span> <span class="hljs-comment">--password test</span><br></code></pre></td></tr></table></figure></blockquote><p>4.查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyydfocs7yj30r00fyq3t.jpg"></p><p>5.dbeaver 查看</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyydcukk8nj318m0u0q6x.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse入门</title>
    <link href="/2022/02/01/clickhouse/"/>
    <url>/2022/02/01/clickhouse/</url>
    
    <content type="html"><![CDATA[<h1><span id="clickhouse-是什么"><strong>ClickHouse</strong> 是什么？</span></h1><p>ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的列式存储数据库（DBMS），使用 C++</p><p>语言编写，主要用于在线分析处理查询（OLAP），能够使用 SQL 查询实时生成分析数据报</p><p>告。</p><blockquote><ul><li>OLTP:   联机事务处理（Online Transaction Processing)。是mysql，oracle这种传统的关系型数据库的主要应用，适合做基本的日常的事务处理，增删改查等操作。</li><li>OLAP：联机分析处理（Online Analytical Processing)，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。适合做一次插入多次查询，适合分析，聚合的场景，但是对更新，删除不擅长。</li></ul></blockquote><h1><span id="clickhouse-的特点">ClickHouse <strong>的特点</strong></span></h1><h2><span id="1列式存储">1.<strong>列式存储</strong></span></h2><h3><span id="行式存储和列式存储的对比">行式存储和列式存储的对比</span></h3><ul><li><p>行式存储的好处是想查某个人所有的属性时，可以通过一次磁盘查找加顺序读取就可以。但是当想查所有人的年龄时，需要不停的查找，或者全表扫描才行，遍历的很多数据都是不需要的。</p></li><li><p>列式存储，想查所有人的年龄只需把年龄那一列拿出来就可以了</p></li></ul><p>以下面的表为例：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyy3x95nv3j31580est9i.jpg"></p><ul><li><p>采用行式存储时，数据在磁盘上的组织结构为：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyy3xu1e5zj315s05igm7.jpg"></p></li><li><p>采用列式存储时，数据在磁盘上的组织结构为：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyy3yqqgzzj315405kjrz.jpg"></p></li></ul><h3><span id="列式储存的好处"><strong>列式储存的好处：</strong></span></h3><ul><li><p>对于列的聚合，计数，求和等统计操作原因优于行式存储。</p></li><li><p>由于某一列的数据类型都是相同的，针对于数据存储更容易进行数据压缩，每一列</p><p>选择更优的数据压缩算法，大大提高了数据的压缩比重。</p></li><li><p>由于数据压缩比更好，一方面节省了磁盘空间，另一方面对于 cache 也有了更大的</p></li></ul><p>发挥空间</p><h2><span id="dbms-的功能"><strong>DBMS</strong> <strong>的功能</strong></span></h2><p>几乎覆盖了标准 SQL 的大部分语法，包括 DDL 和 DML，以及配套的各种函数，用户管</p><p>理及权限管理，数据的备份与恢复。 </p><blockquote><p>数据库管理系统（英语：database management system，缩写：DBMS）即数据库管理软件，是一种针对对象数据库，为管理数据库而设计的大型计算机软件管理系统。</p><p>具有代表性的数据管理系统有：Oracle、Microsoft SQL Server、Access、MySQL及PostgreSQL等。通常数据库管理师会使用数据库管理系统来创建数据库系统。</p></blockquote><h2><span id="多样化引擎"><strong>多样化引擎</strong></span></h2><p>ClickHouse 和 MySQL 类似，把表级的存储引擎插件化，根据表的不同需求可以设定不同</p><p>的存储引擎。目前包括合并树、日志、接口和其他四大类 20 多种引擎。</p><h2><span id="高吞吐写入能力">高吞吐写入能力</span></h2><ul><li><p>ClickHouse 采用类 LSM Tree的结构，数据写入后定期在后台 Compaction。通过类 LSM tree的结构，ClickHouse 在数据导入时全部是顺序 append 写，写入后数据段不可更改，在后台compaction 时也是多个段 merge sort 后顺序写回磁盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在 HDD 上也有着优异的写入性能。</p></li><li><p>官方公开 benchmark 测试显示能够达到 50MB-200MB/s 的写入吞吐能力，按照每行</p></li></ul><p>100Byte 估算，大约相当于 50W-200W 条/s 的写入速度。</p><p><a href="https://zhuanlan.zhihu.com/p/415799237">深入浅出分析LSM树（日志结构合并树） - 知乎 (zhihu.com)</a></p><blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyy4aob591j314o0hg0uk.jpg"></p></blockquote><h3><span id="数据分区与线程级并行"><strong>数据分区与线程级并行</strong></span></h3><ul><li>ClickHouse 将数据划分为多个 partition，每个 partition 再进一步划分为多个 index </li></ul><p>granularity(索引粒度)，然后通过多个 CPU核心分别处理其中的一部分来实现并行数据处理。</p><p>在这种设计下，<strong>单条 Query 就能利用整机所有 CPU</strong>。极致的并行处理能力，极大的降低了查</p><p>询延时。</p><ul><li>所以，ClickHouse 即使对于大量数据的查询也能够化整为零平行处理。但是有一个弊端</li></ul><p>就是对于单条查询使用多 cpu，就不利于同时并发多条查询。所以对于高 qps 的查询业务，</p><p>ClickHouse 并不是强项。</p><blockquote><p>QPS（<strong>Query Per Second</strong>）：每秒请求数，就是说服务器在一秒的时间内处理了多少个请求。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>分布式框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clickhouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis主从架构</title>
    <link href="/2021/12/28/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    <url>/2021/12/28/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1><span id="redis主从架构介绍">Redis主从架构介绍</span></h1><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，<strong>一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读</strong>。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑<strong>读高并发</strong>。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv2a0o0mqj30oi0lsgmm.jpg" style="zoom:30%;"><h1><span id="主从复制全量复制流程">主从复制(全量复制)流程</span></h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv2yicirhj30tq0lggnx.jpg"></p><ol><li>如果你为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个<strong>SYNC</strong>命令(redis2.8版本之前的命令)master请求复制数据。</li><li>master收到SYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件。</li><li>master将生成的rdb数据发给slave。</li><li>Master由于从执行bgsave到生成rdb数据存在时间，在此时间间隔内，可能有新的客户端请求，master会把这些最近的请求缓存在内存中。（也就是一个最近数据的缓冲区，默认大小为1M）</li><li>当第3步的rdb数据发完后，他会把这些缓存的数据也发给slave</li><li>当slave有老的rdb数据，就会先把老的数据清掉。重新生成包含缓存的rd b数据，并加载到内存中。</li><li>之后，master和slave通过socket长连接，持续进行命令同步，从而保证主从数据一致。</li></ol><blockquote><p>当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master。</p></blockquote><blockquote><p>如果master收到了多个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave。  </p></blockquote><p><strong>当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2.8版本开始，master和slave断开重连后支持部分复制</strong>。</p><h1><span id="主从复制部分复制流程">主从复制(部分复制)流程</span></h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv2xkkaizj318w0ro78b.jpg"></p><ol><li>从2.8版本开始，slave与master能够在网络连接断开<strong>重连后只进行部分数据复制。</strong> </li><li>master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据。master和它所有的slave都维护了复制的数据下标offset和master的进程id。</li><li>当网络连接断开后，slave会请求master继续进行未完成的复制。<ul><li>从节点数据下标 offset还在缓存队列里，那么将会从slave记录的数据下标开始从缓存区复制。</li><li>如果master进程id变化了，或者从节点数据下标 offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制</li></ul></li></ol><h1><span id="redis哨兵高可用架构"><strong>Redis哨兵高可用架构</strong></span></h1><ul><li><p>sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。 </p></li><li><p>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过sentinel代理访问redis的主节点。</p></li><li><p>当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息) </p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv33qmtvpj319e0pktbv.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis主从架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化</title>
    <link href="/2021/12/27/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2021/12/27/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>redis 持久化主要有2种方式：RDB 和AOF</p></blockquote><h1><span id="rdb快照">RDB快照</span></h1><h2><span id="什么是rdb快照">什么是RDB快照</span></h2><ul><li>rdb就是快照，是redis默认的持久化方式，就是把所有的数据持久化到磁盘，隔一段时间持久化一次到 dump.rdb 的二进制文件中，在服务器重启后只需要把文件中的数据恢复即可。 </li><li>你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。 比如说， <code>save 60 1000</code>会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集</li></ul><h2><span id="rdb-文件的创建">RDB 文件的创建</span></h2><blockquote><p>有两种方式：手动触发和自动触发</p></blockquote><h3><span id="手动触发">手动触发</span></h3><ul><li>save命令会阻塞当前Redis服务器，直到RDB过程完成为止。在服务器进程阻塞期间，服务器不能处理任何命令请求。因此，当save命令正在执行时，客户端发送的所有命令都会被拒绝，知道save命令执行完毕。（不建议使用）</li><li>bgsave 命令会fork出一个子进程(而不是线程)，由子进程进行RDB文件创建，而父进程继续处理命令。</li></ul><blockquote><p>进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件， 每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。 </p></blockquote><h3><span id="自动触发">自动触发</span></h3><p>redis通过配置文件进行配置，redis可以通过设置服务器配置的save选项，服务器每隔一段时间自动执行一次bgsave命令。</p><h3><span id="优缺点">优缺点</span></h3><p><strong>优点：</strong></p><ul><li>适合大规模的数据恢复，恢复速度快！</li><li>体积小，相较于aof他只是保存了结果，不需要保存每一次命令操作。</li></ul><p><strong>缺点：</strong></p><ul><li>数据需要一定的时间间隔进程操作！ 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据就没有了。</li></ul><h1><span id="aof">AOF</span></h1><ul><li>以独立日志的方式记录每次写命令，每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 appendonly.aof文 件的末尾，并在 Redis 重启时在重新执行 AOF 文件中的命令以达到恢复数据的目的。</li><li>AOF 的主要作用是解决数据持久化的实时性。</li><li>你可以通过修改配置文件来打开 AOF 功能：  <code>appendonly yes </code></li><li>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。 <ul><li><strong>appendfsync always</strong>：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</li><li><strong>appendfsync everysec</strong>：每秒 fsync 一次，足够快（和使用 RDB 持久化差不多），并且在 故障时只会丢失 1 秒钟的数据。</li><li><strong>appendfsync no</strong>：：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。因为你不清楚不同的操作系统底层是怎么去刷磁盘的。 </li></ul></li></ul><h2><span id="aof-重写">AOF 重写</span></h2><ul><li><p>AOF文件里可能有太多没用指令，比如3次递增readcount, 重写后直接会变成readcount:3，AOF会定期根据<strong>内存的最新数据</strong>生成aof文件</p></li><li><p>进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF </p></li><li><p>AOF重写redis会fork出一个子进程去做，不会对redis正常命令处理有太多影响</p></li><li><p>如下两个配置可以控制AOF自动重写频率 </p><ul><li>auto-aof-rewrite-min-size 64mb //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</li><li>auto-aof-rewrite-percentage 100 //aof文件自上一次重写后文件大小增长了100%则再次触发重写</li></ul></li></ul><h3><span id="优缺点">优缺点</span></h3><p><strong>优点</strong>：</p><ul><li>每一次修改都同步，文件的完整性会更加好！</li></ul><p><strong>缺点：</strong></p><ul><li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</li></ul><h1><span id="redis-40-混合持久化"><strong>Redis 4.0 混合持久化</strong></span></h1><blockquote><p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志存放，但是存放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。 通过配置 <code> aof-use-rdb-preamble yes</code>可以开启混合持久化。   </p></blockquote><h2><span id="混合持久化流程">混合持久化流程</span></h2><ul><li>如果开启了混合持久化。<strong>AOF在重写时</strong>，不再是单纯将内存数据转换为命令写入AOF文件，而是根据aof命令重写<strong>这一刻之前</strong>的内存做RDB快照处理，并且将RDB快照内容和<strong>增量的</strong>AOF修改内存数据的命令存在一起，都写入新的AOF文件。</li><li>新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</li><li> 于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再加载增量 AOF 日志就可以完全替代之前的 AOF 全量文件的加载，因此重启效率大幅得到提升。 </li></ul><h2><span id="混合持久化aof文件结构">混合持久化AOF文件结构</span></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxtx3e8tbhj30r40i23zd.jpg" style="zoom:50%;"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxtx4ka5e8j31ey0q6myv.jpg" style="zoom: 33%;"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis持久化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 核心数据结构</title>
    <link href="/2021/12/26/redis/"/>
    <url>/2021/12/26/redis/</url>
    
    <content type="html"><![CDATA[<h1><span id="redis-是什么">redis 是什么？</span></h1><blockquote><p>redis是一个高性能的key-value 数据库，它可以用来存储字符串，哈希，列表，集合，有序集合。</p></blockquote><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxrgdfb02gj30tq0v2whf.jpg" style="zoom:50%;"><h1><span id="string">String</span></h1><p>String 是redis中最基础的数据结构，主要用在常规计数，如：统计网站访问数据量，当前在线人数等</p><p><strong>应用场景</strong></p><ul><li><p>单值缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> key1 &quot;zhangsan&quot;<br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> key1<br>&quot;zhangsan&quot;<br></code></pre></td></tr></table></figure></li><li><p>计数器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial <span class="hljs-number">12</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>&quot;12&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> incr article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">13</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>&quot;13&quot;<br></code></pre></td></tr></table></figure></li><li><p>分布式系统全局序列号<br>INCRBY  orderId  1000        //redis批量生成序列号提升性能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> orderId<br>&quot;99&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> incrby orderId  <span class="hljs-number">1000</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1099</span><br></code></pre></td></tr></table></figure></li><li><p>分布式锁</p><ul><li>SETNX  product:10001   </li><li>执行业务操作。。。</li><li>DEL  product:10001。                                     //执行完业务释放锁</li><li>SET product:10001 true  ex  10  nx              //防止程序意外终止导致死</li></ul></li></ul><blockquote><p>SETNX（ <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists ）</p><ul><li><p>在指定的 key 不存在时，为 key 设置指定的值，这种情况下等同 <a href="https://www.redis.com.cn/commands/set.html">SET</a> 命令。当 <code>key</code>存在时，什么也不做。</p></li><li><p>返回值</p><ul><li><code>1</code> 如果key被设置了</li><li><code>0</code> 如果key没有被设置</li></ul></li></ul></blockquote><h1><span id="hash">hash</span></h1><ul><li>定义：Hash是一个field 和value 的映射表，特别适合存储对象，比如存储用户信息，商品信息等。</li><li>优缺点：<ul><li>优点<ul><li>同类数据归类整合储存，方便数据管理</li><li>相比string操作消耗内存与cpu更小</li><li>相比string储存更节省空间</li></ul></li><li>缺点<ul><li>过期功能不能使用在field上，只能用在key上</li></ul></li></ul></li></ul><p><strong>应用场景</strong></p><ul><li>对象缓存</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> HMSET  <span class="hljs-keyword">user</span>  <span class="hljs-number">1</span>:name  zhuge <span class="hljs-number">1</span>:balance  <span class="hljs-number">1888</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> HMGET  <span class="hljs-keyword">user</span>  <span class="hljs-number">1</span>:name  <span class="hljs-number">1</span>:balance<br><span class="hljs-number">1</span>) &quot;zhuge&quot;<br><span class="hljs-number">2</span>) &quot;1888&quot;<br></code></pre></td></tr></table></figure><ul><li>电商购物车<ul><li>以用户id为key；     商品id为field；    商品数量为value；</li><li>购物车操作<ul><li>添加商品 <code> hset cart:user2 &quot;apple&quot; 1</code></li><li>增加数量  <code> hincrby cart:user2 &quot;apple&quot; 3</code></li><li>商品总数 <code>hlen cart:user2</code></li><li>删除商品 <code>hdel cart:user2 &quot;apple&quot;</code></li><li>获取购物车所有商品 <code>hgetall cart:user2</code></li></ul></li></ul></li></ul><h1><span id="list">list</span></h1><p>list是一个链表结构，主要功能是push和pop（添加和弹出集合元素），获取一个范围的值等。常用于：粉丝列表，最新消息排行。</p><p><strong>应用场景</strong></p><ul><li><p>微博消息和微信公号消息<br>张三关注了2 个订阅号，美食专栏和娱乐周边</p><ul><li><p>美食专栏发推送</p><p> <code>lpush msg:zhangSan &quot;apple is yammy!&quot;</code></p></li><li><p>娱乐周边发推送.</p><p><code>lpush msg:zhangSan &quot;YangMi is beautiful!&quot;</code></p></li><li><p>查看张三关注的最新订阅号消息.</p><p> <code>lrange msg:zhangSan 0 5</code></p></li></ul></li></ul><h1><span id="set">set</span></h1><p>Redis 中的set集合是无序且不可重复的，它最大的优势可以进行交集，丙级，差集等，常用来求共同好友等。</p><p><strong>应用场景</strong></p><ul><li><p>微信抽奖小程序</p><ul><li>点击参与抽奖加入集合 </li></ul><p>​      <code>sadd iphone13 zhangsan</code></p><ul><li>查看参与抽奖所有用户</li></ul><p>​      <code>smembers iphone13</code>      </p><ul><li><p>抽取count名中奖者  </p><ul><li><p>返回集合中2个随机数.</p><p><code>srandmember iphone13 2</code></p></li><li><p>移除并返回集合中的2个随机元素 </p><p> <code>spop iphone13 2</code></p></li></ul></li></ul></li><li><p>微信微博点赞，收藏，标签</p><ul><li>点赞<br>SADD  like:{消息ID}  {用户ID}</li><li>取消点赞<br>SREM like:{消息ID}  {用户ID}</li><li>检查用户是否点过赞<br>SISMEMBER  like:{消息ID}  {用户ID}</li><li>获取点赞的用户列表<br>SMEMBERS like:{消息ID}</li><li>获取点赞用户数<br>SCARD like:{消息ID}</li></ul></li><li><p>集合操作</p><ul><li>交集：SINTER set1 set2 set3 </li><li>并集：SUNION set1 set2 set3</li><li>差集：SDIFF set1 set2 set3 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd set1 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd set2 <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sinter set1 set2<br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;3&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sunion set1 set2<br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">3</span>) &quot;3&quot;<br><span class="hljs-number">4</span>) &quot;4&quot;<br><span class="hljs-number">5</span>) &quot;5&quot;<br><span class="hljs-number">6</span>) &quot;6&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sdiff set1 set2<br><span class="hljs-number">1</span>) &quot;2&quot;<br><span class="hljs-number">2</span>) &quot;4&quot;<br></code></pre></td></tr></table></figure></li></ul><h1><span id="zset">zset</span></h1><p>在set的基础上，增加了一个权重系数score，使集合中的元素可以按照score进行有序排列，常用于实现排行榜。</p><p><strong>应用场景</strong></p><ul><li><p>Zset集合操作实现排行榜</p><ul><li><p>点击新闻   </p><p>ZINCRBY  hotNews:20190819  1  守护香港</p></li><li><p>展示当日排行前十 </p><p> ZREVRANGE  hotNews:20190819  0  10  WITHSCORES </p></li><li><p>七日搜索榜单计算<br>ZUNIONSTORE  hotNews:20190813-20190819  7<br>hotNews:20190813  hotNews:20190814… hotNews:20190819</p><blockquote><p>[ZUNIONSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">key …]</a><br>计算给定的一个或多个有序集的并集，并存储在新的 key 中</p></blockquote></li><li><p>展示七日排行前十<br>ZREVRANGE hotNews:20190813-20190819  0  10  WITHSCORES</p><blockquote><p>[ ZREVRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</p></blockquote></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis 核心数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个SpringBoot项目</title>
    <link href="/2021/12/25/%E7%AC%AC%E4%B8%80%E4%B8%AAspringboot%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/12/25/%E7%AC%AC%E4%B8%80%E4%B8%AAspringboot%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1><span id="编写代码">编写代码</span></h1><ul><li>进入官网 <a href="https://start.spring.io/">Spring Initializr</a> 初始化项目</li><li>编写控制HelloController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">helloController</span> </span>&#123;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello World!&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1><span id="编写测试用例">编写测试用例</span></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.http.MediaType;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.MockMvc;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.hamcrest.Matchers.equalTo;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;<br><br><span class="hljs-meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@AutoConfigureMockMvc</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">helloControllerTest</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    mockMvc.perform(MockMvcRequestBuilders.get(<span class="hljs-string">&quot;/hello&quot;</span>).accept(MediaType.APPLICATION_JSON))<br>      .andExpect(status().isOk())<br>      .andExpect(content().string(equalTo(<span class="hljs-string">&quot;hello World!&quot;</span>)));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1><span id="启动项目">启动项目</span></h1><ul><li>idea 里面右击项目</li><li>build/libs下运行 <code>Java -jar xxx</code></li><li>项目目录下运行：<code>gradle bootRun</code></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxr8m9n86ij30sq08ujrx.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql锁与事务隔离级别</title>
    <link href="/2021/12/18/mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2021/12/18/mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1><span id="锁是什么">锁是什么？</span></h1><ul><li>锁是计算机协调多个线程或进程并发访问同一资源的机制。</li><li>在数据库中，数据是一种共享的资源，因此也需要保证数据并发访问的一致性和有效性。</li></ul><h1><span id="锁的分类">锁的分类</span></h1><ul><li><p>从性能上来分为：<code>乐观锁</code>和<code>悲观锁</code></p><ul><li><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><blockquote><p>乐观锁一般通过版本比对的方式来实现的：</p><ul><li><p>当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。</p></li><li><p>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与我们第一次取出的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。那么更新操作就会失败。</p></li></ul></blockquote></li><li><p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p></li></ul></li><li><p>从操作类型来分为：<code>读锁</code>和<code>写锁</code></p><ul><li>读锁：也称为共享锁，多个读操作可以同时进行，且互不影响。</li><li>写锁：也称为拍他锁，他可以阻断其他读操作或者写操作。</li></ul></li><li><p>从可操作的粒度来分为：<code>表锁</code>和<code>行锁</code></p><ul><li><p>表锁：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲 </p><p>突的概率最高，并发度最低；</p></li><li><p>行锁：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁 </p><p>冲突的概率最低，并发度最高。</p></li></ul></li></ul><h1><span id="mysql-事务">mysql 事务</span></h1><h2><span id="1事务定义">1.事务定义</span></h2><p>事务是一个操作集合，这些操作要么都执行，要么都不执行，他是一个不可分割的工作单位。</p><h2><span id="2事务的四大特性">2.事务的四大特性</span></h2><ul><li>原子性：事务是一个原子操作单元，它对数据的修改，要么都执行，要么都不执行。</li><li>一致性：一个事务执行前和执行后，数据必须保持一致，如：转账前用户AB的钱加在一起时500，转账后也应该是500</li><li>隔离型：事务外的实体不可以知道事务过程中的中间状态</li><li>持久性：对数据库的操作是永久性的，即使系统故障也能保持</li></ul><h2><span id="3不考虑事务的隔离性会产生并发问题">3.不考虑事务的隔离性会产生并发问题</span></h2><ul><li>更新丢失：当两个或者多个事务同时对一行数据进行更新，会发生数据的覆盖，最后的更新覆盖了其他事务的更新。</li><li>脏读：读到了没有提交的数据，一个事务正在写操作，另一个事务进行了读操作，读到了脏数据。如果此时事务回滚，读取到的数据就是无效的。</li><li>不可重复读：读到了已经提交的数据，事务A多次读取同一数据，但在这个过程中，事务B对数据进行了修改并提交，会导致事务A多次读取数据结果不一致。</li><li>幻读：事务A读取到了事务B提交的新增数据。查询某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</li></ul><h1><span id="mysql-事务隔离级别">mysql 事务隔离级别</span></h1><ul><li><p>脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p></li><li><p>mysql隔离级别越高，性能越差。因为事务的本质就是串行化，这显然与并发是矛盾的。</p></li><li><p><code>RR</code> 级别作为 <code>mysql</code> 事务默认隔离级别，是事务安全与性能的折中。</p></li><li><p>查看当前事务的隔离级别 <code>select @@transaction_isolation;</code></p></li><li><p>设置事务隔离级别</p><ul><li>当前会话： <code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></li><li>全局：<code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></li></ul></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>可能</td><td>可能</td><td align="center">可能</td></tr><tr><td>读已提交</td><td>不可能</td><td>可能</td><td align="center">可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td align="center">可能</td></tr><tr><td>串行化</td><td>不可能</td><td>不可能</td><td align="center">不可能</td></tr></tbody></table><h2><span id="1读未提交">1.读未提交</span></h2><ul><li><p>打开两个客户端：客户端A设置当前事务模式为read uncommitted，查询employees 表的初始值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> READ<span class="hljs-operator">-</span>UNCOMMITTED        <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure></li><li><p>客户端B开启事务，并执行更新操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据，一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是<strong>脏数据</strong>： </p></li><li><p>```sql<br>mysql&gt;  select * from employees;<br>+—-+———–+—–+———-+———————+<br>| id | name      | age | position | hire_time           |<br>+—-+———–+—–+———-+———————+<br>|  4 | newLiLei  |  22 | mana ger | 2021-12-06 21:36:50 |<br>|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |<br>|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |<br>+—-+———–+—–+———-+———————+<br>3 rows in set (0.00 sec)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br>## 读已提交<br><br><span class="hljs-bullet">- </span>打开两个客户端：客户端A设置当前事务模式为read committed，查询employees 表的初始值<br><br><span class="hljs-code">```sql</span><br><span class="hljs-code">mysql&gt; select @@transaction_isolation;</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">| @@transaction_isolation |</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">| READ-COMMITTED          |</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">1 row in set (0.00 sec)</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; select * from employees;</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br><span class="hljs-section">| id | name      | age | position | hire_time           |</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br>|  4 | LiLei     |  22 | mana ger | 2021-12-06 21:36:50 |<br>|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |<br><span class="hljs-section">|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure></li><li><p>客户端B开启事务，并执行更新操作</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端B的事务提交</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">commit</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端A再次查询，结果 与上一步不一致，即产生了不可重复读的问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> newLiLei  <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br></code></pre></td></tr></table></figure><h2><span id="可重复读">可重复读</span></h2><ul><li>打开两个客户端：客户端A设置当前事务模式为REPEATABLE-READ，查询employees 表的初始值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ         <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端B开启事务，并执行更新操作, 并提交。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>在客户端A查询表account的所有记录，与上一次查询结果一致，没出现有出现不可重复读的问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><blockquote><p>Mysql默认级别是repeatable-read，有办法解决幻读问题吗？ </p><p><strong>间隙锁在某些情况下可以解决幻读问题</strong> </p><p>要避免幻读可以用间隙锁在Session_1下面执行update account set name = ‘zhuge’ where id &gt; 10 and id &lt;=20;，则其他Session没法在这个范围所包含的间隙里插入或修改任何数据</p></blockquote><h2><span id="串行化">串行化</span></h2><ul><li>打开两个客户端：客户端A设置当前事务模式为SERIALIZABLE，查询employees 表的初始值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> SERIALIZABLE            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec) <br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> newLiLei  <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy123   <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7</span> <span class="hljs-operator">|</span> wangwu123 <span class="hljs-operator">|</span>  <span class="hljs-number">18</span> <span class="hljs-operator">|</span> super    <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">53</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br></code></pre></td></tr></table></figure><ul><li>打开一个客户端B，并设置当前事务模式为serializable，插入一条记录报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，开发中很少会用到。 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employees <span class="hljs-keyword">values</span>(<span class="hljs-number">12</span>,&quot;lili2&quot;,<span class="hljs-number">11</span>,&quot;manager&quot;,&quot;2021-12-06 21:36:55&quot;);<br>ERROR <span class="hljs-number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction<br></code></pre></td></tr></table></figure><h1><span id="mysql事务隔离性的实现">mysql事务隔离性的实现</span></h1><h2><span id="mvcc机制多版本并发控制">MVCC机制（多版本并发控制）</span></h2><ul><li>主要是保存数据在某个时间点的快照实现的。</li><li>mysql在每行记录后面，保存了两个隐藏列，分别为：创建事务id和删除事务id</li></ul><ul><li><p>当执行select操作的时候，mysql底层会带上过滤条件：</p><ul><li><p>创建事务id &lt;= max(当前事务id, 已提交的最大事务id)，保证该事务读到的数据，要么是开始前就已经存在的，要么是自身插入或修改后的。</p></li><li><p>删除事务id  &gt;  max (当前事务id, 已提交的最大事务id) 或  删除事务id未定义。保证事务读到的行，在事务开始前没有被删除</p></li></ul></li></ul><h1><span id="innodb与myisam的最大不同有两点">InnoDB与MYISAM的最大不同有两点：</span></h1><ol><li>支持事务</li><li>支持行锁</li></ol><h1><span id="性能优化建议">性能优化建议</span></h1><ul><li><p>尽可能低级别事务隔离</p></li><li><p>尽可能减少检索条件范围，避免间隙锁 </p></li><li><p>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行 </p></li><li><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 </p><blockquote><p>无索引行锁会升级为表锁：锁主要是加在索引上，如果对非索引字段更新, 行锁可能会变表锁</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql锁</tag>
      
      <tag>mysql事务隔离级别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见sql优化(二)</title>
    <link href="/2021/12/07/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96-%E4%BA%8C/"/>
    <url>/2021/12/07/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2><span id="一-分页查询优化">一  <strong>分页查询优化</strong></span></h2><h3><span id="1-根据自增且连续的主键排序的分页查询">1. 根据自增且连续的主键排序的分页查询</span></h3><blockquote><p>原则：按照主键去查询</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">90000</span> limit <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。 </p><p>但是，这条改写的SQL 在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致，如：先删除一条前面的记录，然后再测试原 SQL 和优化后的 SQL</p><h3><span id="2根据非主键字段排序的分页查询">2.根据非主键字段排序的分页查询</span></h3><blockquote><p>原则： 让排序和分页操作先查出主键，然后根据主键查到对应的记录，这样排序时返回的字段会少很多，从而会执行索引排序。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> name limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>表示根据非主键字段name排序的分页查询，发现并没有使用 name 字段的索引（key 字段对应的值为 null），具体原因为：扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。</p><p>改写后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>) ed <span class="hljs-keyword">on</span> e.id <span class="hljs-operator">=</span> ed.id;<br></code></pre></td></tr></table></figure><h2><span id="二-join关联查询优化">二   <strong>Join关联查询优化</strong></span></h2><h3><span id="mysql的表关联常见有两种算法">mysql的表关联常见有两种算法</span></h3><h4><span id="1嵌套循环连接nested-loop-join-算法">1.嵌套循环连接（Nested-Loop Join） 算法</span></h4><ul><li><p>一次一行循环地从第一张表（称为<strong>驱动表</strong>）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（<strong>被驱动</strong>表）里取出满足条件的行，然后取出两张表的结果合集。</p></li><li><p>大致流程是：</p><ol><li><p>第一步：从表 t2 中读取一行数据，根据关联字段 到表 t1 中查找</p></li><li><p>第二步：取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端； </p></li><li><p>第三部：重复第二步</p></li></ol><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span><span class="hljs-operator">*</span><span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2 <span class="hljs-keyword">on</span> t1.a<span class="hljs-operator">=</span> t2.a;<br></code></pre></td></tr></table></figure><p>假设t2有100条数据，t1有10000条。整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(<strong>扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据（扫描索引很快，可以忽略），也就是总共 t1 表也扫描了100</strong> 行**)。因此整个过程扫描了 **200 行。</p></blockquote></li><li><p>优化器一般会优先选择小表做驱动表。<strong>所以使用 inner join 时，排在前面的表并不一定就是驱动表。</strong></p></li></ul><h4><span id="2基于块的嵌套循环连接block-nested-loop-join-算法">2.基于块的嵌套循环连接（Block Nested-Loop Join） 算法</span></h4><ul><li><p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。 </p></li><li><p>大致流程是：</p><ol><li><p>第一步：把t2中的所有数据放在join_buffer中</p></li><li><p>第二步：依次取出t1中的每一行，跟join_buffer中的数据做对比</p></li><li><p>第三部：返回满足条件的数据</p></li></ol><blockquote><p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = <strong>10100</strong>。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= <strong>100 万次</strong>。 </p></blockquote></li></ul><h3><span id="对于关联sql的优化">对于关联sql的优化</span></h3><ul><li><p>关联字段加索引，让mysql做join操作时，尽量选择嵌套循环算法。</p><blockquote><p>从上面的例子可以对比看出，嵌套循环算法因为有索引，每次进行查找时，只需根据索引，查找一条匹配的数据，即扫描一次。但基于块的嵌套循环连接却因为没有索引，每次都需要进行一次全表扫描。</p></blockquote></li><li><p>小表驱动大表。写多表连接sql时如果<strong>明确知道</strong>哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间。</p><blockquote><p>straight_join同inner join类似，但是可以指定左边的表来驱动右边的表。但是使用它一定要慎重，因为大部分情况优化器是比人聪明的，人为指定的顺序不一定比搜索引擎靠谱。</p></blockquote></li></ul><h2><span id="三-in和exsits优化">三  <strong>in和exsits优化</strong></span></h2><blockquote><p> 原则：<strong>小表驱动大表</strong>，即小的数据集驱动大的数据集 </p></blockquote><ul><li><p>当B表的数据集 &lt; A表的数据集时，in优于exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B) <br>#等价于：  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B)&#123; <br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-operator">=</span> B.id<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当B表的数据集 &gt; B表的数据集时，exists优于in</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> b.id <span class="hljs-operator">=</span> A.id) <br>#等价于：  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> A)&#123;<br>     <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会忽略SELECT清单,因此没有区别 </p></blockquote></li></ul><h2><span id="四-count查询优化">四  <strong>count(*)查询优化</strong></span></h2><h3><span id="查询mysql自己维护的总行数">查询mysql自己维护的总行数</span></h3><ul><li>对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被 mysql存储在磁盘上查询不需要计算 。</li><li>对于<strong>innodb存储引擎</strong>的表mysql不会存储表的总记录行数，查询count需要实时计算 </li></ul><h3><span id="show-table-status"><strong>show table status</strong></span></h3><ul><li><p>如果只需要知道表总行数的估计值可以用如下sql查询，性能很高 .</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxdq94vfa1j31rk088q4o.jpg"></p></li></ul><h3><span id="count优化方式">count(*)优化方式</span></h3><ul><li><p><strong>将总数维护到Redis里</strong> </p><p>插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准（如mysql执行成功了，redis没有更新成功），很难保证表操作和redis操作的事务一致性 ，可能得考虑分布式事务，适用于准确度要求不高的场景。</p></li><li><p><strong>增加计数表</strong></p><p>插入或删除表数据行的时候同时维护计数表（如新建一个表，该表增加一个字段user_count，insert user 的同时更新该字段），让他们在同一个事务里操作，让mysql的事务来保证一致性。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见sql优化</title>
    <link href="/2021/12/05/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96/"/>
    <url>/2021/12/05/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2><span id="常见sql优化">常见sql优化</span></h2><ul><li><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p></li><li><p>尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select * 语句</p></li><li><p>尽量不使用不等于（！=或者&lt;&gt;），这些无法使用索引，会导致全表扫描 </p></li><li><p>尽量不使用 is null,is not null ，这些无法使用索引，会导致全表扫描 </p></li><li><p>like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</p></li><li><p>少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。</p></li><li><p>尽量将大范围拆分成多个小范围。单次数据量查询过大可能导致优化器最终选择不走索引</p></li><li><p>范围和范围右边的字段不会走索引，只有范围和范围之前的等值字段会走索引</p></li><li><p>不在索引列上做任何操作。（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。</p></li></ul><p>准备工作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">24</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  `position` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>  `hire_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时 间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `idx_name_age_position` (`name`,`age`,`position`) <span class="hljs-keyword">USING</span> BTREE) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br>  <br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;LiLei&#x27;</span>,<span class="hljs-number">22</span>,<span class="hljs-string">&#x27;mana ger&#x27;</span>,NOW());<br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;HanMeimei&#x27;</span>, <span class="hljs-number">23</span>,<span class="hljs-string">&#x27;dev&#x27;</span>,NOW());<br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;Lucy&#x27;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;dev&#x27;</span>,NOW());<br></code></pre></td></tr></table></figure><p>Eg1: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;LiLei&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx4g3b8iklj31m606ejsx.jpg"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">left</span>(name,<span class="hljs-number">3</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;LiLei&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx4g3oc8zsj31ek06cgmu.jpg"></p><p>Eg2:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> <span class="hljs-type">date</span>(hire_time) <span class="hljs-operator">=</span><span class="hljs-string">&#x27;2018-09-30&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> hire_time <span class="hljs-operator">&gt;=</span><span class="hljs-string">&#x27;2018-09-30 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> hire_time <span class="hljs-operator">&lt;=</span><span class="hljs-string">&#x27;2018-09-30 23:59:59&#x27;</span>;<br></code></pre></td></tr></table></figure><p>给hire_time增加一个普通索引，上面的sql由于进行了date运算所以不会走索引，下面的会走。</p><h2><span id="using-filesort文件排序原理详解"><strong>Using filesort文件排序原理详解</strong></span></h2><ul><li><p>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。 </p></li><li><p>filesort文件排序方式</p><ul><li>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</li><li>双路排序（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行</strong> <strong>数据的行 ID</strong>(主键)，然后在 sort buffer 中进行排序，排序完后需要再次通过主键回到原表查询需要的字段。用trace工具 可以看到sort_mode信息里显示&lt; sort_key, rowid &gt; </li></ul><blockquote><p> MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来 判断使用哪种排序模式。</p><ul><li><p> 如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 单路排序模式； </p></li><li><p> 如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 双路排序模式。</p></li></ul></blockquote></li></ul><ul><li><p>单路排序 和 双路排序的选择</p><ul><li><p>如果 MySQL 排序内存配置的比较小并且没有条件继续增加了，可以适当max_length_for_sort_data 配 置小点，让优化器选择使用<strong>双路排序</strong>算法，可以在sort_buffer 中一次排序更多的行，只是需要再根据主键回到原表取数据。 </p></li><li><p>如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器 优先选择全字段排序(<strong>单路排序</strong>)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查 询结果了。 </p></li></ul></li></ul><blockquote><p>所以，MySQL通过 <strong>max_length_for_sort_data</strong> 这个参数来控制排序，在不同场景使用不同的排序模式， 从而提升排序效率。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Explain详解</title>
    <link href="/2021/11/27/Explain-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/11/27/Explain-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1><span id="explain使用介绍">explain使用介绍</span></h1><ul><li><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈 </p></li><li><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL （如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）。</p></li><li><p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。</p></li></ul><p><strong>下面是使用explain的例子：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwztv72dgxj31aq06mq45.jpg"></p><h2><span id="explain中的列">explain中的列</span></h2><h3><span id="id列">id列</span></h3><ul><li><p>id列的编号就是select的序列号，有几个select就有几个id</p></li><li><p>id的顺序是按select 出现的顺序增长的</p></li><li><p>Id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzu3b6nonj31fo07m75y.jpg"></p><h3><span id="select_type列">select_type列</span></h3><ul><li>simple: 简单查询。查询中不含子查询和联合查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx1xees8p5j31cm06ujso.jpg"></p><ul><li>primary : 复杂查询中最外层的select。</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p>中的：<code>select *** from film </code> </p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzu3b6nonj31fo07m75y.jpg"></p><ul><li>subsquery: 复杂查询中的子查询（不在from子句中）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p>中的：<code>select 1 from actor limit 1</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzu3b6nonj31fo07m75y.jpg"></p><ul><li>derived([dɪˈraɪv]) : 包含在from子句中的子查询。Mysql将把结果存放在一个临时表中，也称为派生表。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">set</span> session optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;derived_merge=off&#x27;</span>;<br>mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) der;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx1xvhx932j31pa08owgo.jpg"></p><ul><li>union ：在union后的select。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> id, name <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx399g82jsj31ey07ejsz.jpg"></p><blockquote><ul><li> union 用于把来自多个select  语句的结果组合到一个结果集合中。语法为：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-keyword">column</span>,......<span class="hljs-keyword">from</span> table1<br> <span class="hljs-keyword">union</span> [<span class="hljs-keyword">all</span>]<br><span class="hljs-keyword">select</span>  <span class="hljs-keyword">column</span>,...... <span class="hljs-keyword">from</span> table2<br></code></pre></td></tr></table></figure></blockquote><h3><span id="table列">table列</span></h3><ul><li>这一列表示explain的这一行在执行哪个表</li><li>当form后有子查询时，table列为<code>&lt;derivedN&gt;</code>格式，表示当前查询依赖id = N的查询，于是先执行id= N的查询。</li></ul><h3><span id="type-列">type 列</span></h3><ul><li><p>这一列表示访问类型，即mysql决定如何查找表中的行。</p></li><li><p>性能排序从好到坏依次为：<code>system &gt;const&gt; eq_ref&gt; ref&gt; range &gt; index &gt; all</code>，一般来说，得保证查询至少到range级别，最好到ref。</p></li><li><p>具体的类型介绍。</p><blockquote><ul><li><p>NULL：mysql在窒息感阶段用不着访问表或者索引。例如索引列中取最小值，可以单独查找索引来完成，不需要执行时访问表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx39keqvk8j31kc072myn.jpg"></p></li></ul></blockquote><blockquote><ul><li><p>const：直接按 primary key 或 unique key读取，将该列与常数比较，所以表最多有一个匹配行，读取1次，速度比较快</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx39u1jkh4j31cm084400.jpg"></p></li></ul></blockquote><blockquote><ul><li><p>eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合 条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> film <span class="hljs-keyword">on</span> film_actor.film_id <span class="hljs-operator">=</span> film.id;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3a5jmvsej31m207wjt5.jpg"></p></li></ul></blockquote><blockquote><ul><li>ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者联合索引的部分前缀，索引要 和某个值相比较，可能会找到多个符合条件的行。 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;film1&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3a7ju6ugj31fk06mta5.jpg"></p></blockquote><blockquote><ul><li>range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3acp599sj31ea06sta0.jpg"></p></blockquote><blockquote><ul><li>index：扫描全表索引，这通常比ALL快一些。即查询的字段都是索引列。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3ahaf61zj31eo06mwft.jpg"></p></blockquote><p>​        </p><blockquote><ul><li>ALL：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3amcxg5rj31am06yjsm.jpg"></p></blockquote></li></ul><h3><span id="possible_keys列"><strong>possible_keys列</strong></span></h3><ul><li>这一列显示查询可能使用哪些索引来查找。 </li><li>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中 数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </li><li>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。 </li></ul><h3><span id="key列">key列</span></h3><ul><li>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </li><li>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索 引，在查询中使用 force index、ignore index。</li></ul><h3><span id="key_len列">key_len列</span></h3><ul><li>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </li><li>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成， 并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。 </li></ul><blockquote><p>key_len计算规则如下： </p><ul><li><p>字符串 </p><ul><li><p>char(n)：n字节长度</p></li><li><p>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n </p><p>+ 2</p></li></ul></li><li><p>数值类型</p><ul><li>tinyint：1字节 </li><li>smallint：2字节</li><li>int：4字节 </li><li>bigint：8字节</li></ul></li><li><p>时间类型</p><ul><li>date：3字节 </li><li>timestamp：4字节 </li><li>datetime：8字节</li></ul></li><li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></li></ul></blockquote><h3><span id="ref列"><strong>ref列</strong></span></h3><ul><li>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id） </li></ul><h3><span id="rows列"><strong>rows列</strong></span></h3><ul><li>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。 </li></ul><h3><span id="extra列"><strong>Extra列</strong></span></h3><p>这一列展示的是额外信息。常见的重要值如下： </p><ul><li><p>Using index：使用覆盖索引（覆盖索引指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。 ）</p></li><li><p>Using where：使用 where 语句来处理结果，查询的列未被索引覆盖</p></li><li><p>Using index condition：会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> film_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> name <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><ul><li> actor.name没有索引，此时创建了张临时表来distinct </li></ul></li><li><p>Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><ul><li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排 序name并检索行记录 </li></ul></li><li><p>Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p> Extra 的介绍不是一定的，需要综合当时的场景考虑，不需要记住哪个场景使用的是哪个，只是需要当出现Using filesort, Using temporary：Using where：时，考虑需要优化。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Explain详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql索引介绍</title>
    <link href="/2021/11/04/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/11/04/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2><span id></span></h2><h2><span id="索引的本质">索引的本质</span></h2><blockquote><p>索引是帮助Mysql高效获取数据的排好序的数据结构</p></blockquote><h2><span id="索引的数据结构">索引的数据结构</span></h2><h4><span id="二叉树单边增长的场景会导致全表扫描">二叉树：单边增长的场景会导致全表扫描。</span></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwoa8e7thzj30am0dkwek.jpg" style="zoom: 67%;"><span id="more"></span><h4><span id="红黑树相对平衡比二叉树性能好大数据下红黑树的高度过高会造成磁盘io频繁">红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。</span></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwoabk973sj30dy08cjrf.jpg"><h4><span id="hash">Hash</span></h4><p>一次hash算法就可以定位到文件的位置，但存在缺点：</p><ul><li>不支持范围查找</li><li>不支持排序</li></ul><p>数据库如果比较大，只用到精确查找就可以用hash</p><h4><span id="b-tree">B-tree：</span></h4><ol><li><strong>特点：</strong></li></ol><blockquote><ul><li>叶子结点具有相同的深度，叶子结点指针为空。</li><li>所有索引元素不重复</li><li>节点中的数据索引从左到右递增</li></ul></blockquote><ol start="2"><li>如果使用了innoDb存储引擎，结点的data元素就可能存储的是除了索引外的其他所有列，会占用比较大的存储空间，对于一个大结点而言，可以存放的结点数量就会比较小</li></ol><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwoaf7s92lj30ne07oq3a.jpg"><h4><span id="btreeb-tree变种">B+tree(B-tree变种)</span></h4><ol><li><p>特点：</p><blockquote><ul><li>非叶子结点不存储data ,只存储索引（冗余），可以存放更多的索引。</li><li>叶子结点包含所有的索引字段。</li><li>叶子结点用指针连接，提高区间访问的性能。</li></ul></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwoarcvziwj30r80bwjs3.jpg"></p></li></ol><h2><span id="索引是怎么支持千万级表快速查找">索引是怎么支持千万级表快速查找？</span></h2><p>mysql建议一个结点大小为16kb,这样一次iO速度比较快，一个大结点下的一个索引元素大约是14b，所以一个大结点里面约有1170个索引元素，对于一个高度为3的b+树，可以存储<code>16* 1170* 1170 </code>= 2000万。</p><h2><span id="存储引擎">存储引擎</span></h2><p>存储引擎是对于表而言的，不同的表可以设置不同的存储引擎</p><h3><span id="myisam索引实现非聚集">MyISAM索引实现(非聚集)</span></h3><ul><li><p>MyISAM索引文件和数据文件是分离的</p></li><li><p>表结构文件是xxx.frm, 索引文件是xxx.MYI, 数据文件是xxx.MYD</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwqkxbz5qvj30j80f8mxz.jpg"></p></li></ul><blockquote><p>执行流程：当有一条查询语句：where Col1 = 49， 先判断有没有走索引，走索引的话，先根据49快速在MYI文件中定位到结点，获取该结点存储的索引所在行的磁盘文件指针0x90，再去MYD中定位数据。</p></blockquote><h3><span id="innodb索引实现聚集">InnoDb索引实现(聚集)</span></h3><ul><li><p>表数据文件本身就是按B+tree组织的一个索引文件</p></li><li><p>叶子结点包含了完整的数据记录，data里存储的是：索引所在行的其他所有数据</p></li><li><p>表结构文件是xxx.frm, 索引文件+ 数据文件 是xxx.ibd</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwql7jmw80j30si0dmgmn.jpg"></p><h4><span id="为什么innodb表要尽量设定一个主键">为什么InnoDb表要尽量设定一个主键</span></h4><ul><li>innnoDb表数据文件本身就是按B+tree组织的一个索引文件</li><li>主键是数据库确保数据行在整张表唯一性的保障.</li><li>设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。 </li><li>如果没有主键，InnoDB会选择一个唯一键来作为聚簇索 引，如果没有唯一键，会生成一个隐式的主键。 </li></ul><h4><span id="主键使用整型的自增id而不是uuid">主键使用整型的自增ID而不是UUID？</span></h4><ul><li>查找元素的时候会涉及到大量的数据比较，整型比字符串快</li><li>UUID占用的存储空间会大于整形</li><li>叶子结点是按顺序排列的，如果主键索 引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，在维护B+树的过程中，会造成非常多的数据插入，数据移动，然后导致产生很多的内 存碎片，进而造成插入性能的下降。 </li></ul><h3><span id="辅助索引非主键索引">辅助索引（非主键索引）</span></h3><ul><li><p>叶子结点存储的是索引所在数据行的主键。</p></li><li><p>辅助索引访问数据总是需要二次查找，先遍历非主键索引再遍历主键索引</p></li></ul><h4><span id="为什么非主键索引结构叶子结点存储的是主键值">为什么非主键索引结构叶子结点存储的是主键值?</span></h4><ul><li>一致性，完整的数据只在主键索引上维护一份就可以，不用考虑分布式的问题。</li><li>节省存储空间.</li></ul><h2><span id="联合索引">联合索引</span></h2><ul><li>5个单值索引，对应5棵B+树，联合索引就只需要一棵树，所以日常推荐使用联合索引而不是单值索引。</li><li>索引排序的时候会按照字段顺序，逐个去排序</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwqm2wi1m8j30og0c8dgy.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="/2021/10/27/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/27/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1><span id="什么是rabbitmq"><strong>什么是RabbitMQ？</strong></span></h1><p>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件</p><h1><span id="rabbitmq-的使用场景"><strong>rabbitmq 的使用场景</strong></span></h1><blockquote><ul><li><p>服务间异步通信 </p></li><li><p>顺序消费</p></li><li><p>定时任务 </p></li><li><p>请求削峰 </p></li></ul></blockquote><span id="more"></span><h1><span id="rabbitmq-的优点">rabbitmq 的优点</span></h1><ul><li>异步解偶。 相比于传统的串行、并行执行，可以提高吞吐量</li><li>流量削峰。可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请 求。</li><li>应用解偶。系统间通过消息通信，不用关心其他系统的处理。 </li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 </li></ul><blockquote><p>主要是：解耦、异步、削峰。 </p></blockquote><h1><span id="为什么选择rabbitmq">为什么选择rabbitmq？</span></h1><ul><li>支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 </li><li>支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。</li><li>开 源的，比较稳定的支持，活跃度也高</li></ul><blockquote><p>缺点： 确实 erlang 语言阻止了大量的 Java 工程师 去深入研究和掌控它，对公司而言，几乎处于不可控的状态，</p></blockquote><h1><span id="rabbitmq的基本概念">RabbitMQ的基本概念</span></h1><ul><li><p>Broker： 简单来说就是消息队列服务器实体 </p></li><li><p>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 </p></li><li><p>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 </p></li><li><p>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 </p></li><li><p>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 </p></li><li><p>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部 均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的 权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，类似mysql中的database创建一个table 需要指明用哪个数据库。</p></li></ul><h1><span id="channel信道">channel信道</span></h1><ul><li>信道是生产者/消费者与rbabitmq通信的渠道。生产者publish或者消费者consume一个队列都是通过信道完成的。</li><li>多线程时，rabbitMQ在一条tcp上建立多个信道来处理多线程。</li><li>每个信道在rabbitmq上有唯一的id,保证一个信道对应一个线程使用。</li></ul><h1><span id="交换机">交换机</span></h1><ul><li><p>交换机就类似是路由器，他会根据路由键（在rabbitMQ就是routing key），将消息分发到相应的队列上去。</p></li><li><p>交换机的四种类型</p><ul><li>fanout: 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。(1:N)</li><li>Direct :   把消息路由到BindingKey和RoutingKey完全匹配的队列中。(1:1)</li><li>topic: 可以根据模糊匹配，可以将多个消息路由到同一个队列，比如一个队列的routing_key是’’.test”那么凡是到达路由器的消息的后缀为“.test”，都会进到这个队列。<ul><li>“* ”只能是一个单词，如“”aa.test“</li><li>“#”可以是&gt;= 0的单词，如“”test“,”aa.bb.test”</li></ul></li><li><code>headers</code>:不依赖路由键匹配规则路由消息。是根据发送消息内容中的<code>headers</code>属性进行匹配。性能差，基本用不到。</li></ul></li></ul><h1><span id="rabbitmq的6种工作模式"><strong>RabbitMQ的6种工作模式</strong></span></h1><p><strong>一.simple模式（即最简单的收发模式）</strong></p><p>一个生产者，一个消费者，通过队列收发消息。不常用</p><p><strong>二.work工作模式(资源的竞争)</strong> </p><ul><li><p>一个生产者，多个消费者。</p></li><li><p>消费者1,消费者2同时监听同一 个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费 消息</p></li><li><p>(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。 </p></li></ul><p><strong>三.publish/subscribe发布订阅(共享资源)</strong></p><p>1、每个消费者监听自己的队列； </p><p>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。</p><p><strong>四.routing路由模式</strong> </p><p>根据routing_key 进行匹配，生产者，发送消息的时候会制定routing_key，交换机根据routing_key，去匹配绑定改routing_key的队列</p><p>,只能匹配上路由key对应 的消息队列,对应的消费者才能消费消息</p><p><strong>五.topic 主题模式(路由模式的一种)</strong> </p><p>.交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费。类似sq l的模糊匹配</p><p><strong>六.RPC模式(路由模式的一种)</strong> </p><p>实现不同服务间的远程调用</p><h2><span id="消息的分发策略">消息的分发策略</span></h2><ul><li><p>消息的分发策略</p><p>  假设队列里有100条消息，有 A,B,C   3个队列</p><ul><li>发布订阅。三个队列都收到100条</li><li>轮训分发。3个队列都是至少33条，剩下一条随机，不论你数据库性能怎么样，大家接受的都是公平的</li><li>公平分发。根据服务器性能，去分发，哪个性能高，哪个处理的消息可能就多，能者多劳，会造成数据倾斜</li><li>重发。发送消息中出现了异常后，消息没有得到应答，就会重发，kafka不支持</li><li>消息拉取。就是RPC去拉取数据</li></ul><blockquote><p>Rabbitmq以上集中策略都支持，且是开源的</p><p>kafka速度最快</p></blockquote></li></ul><h1><span id="rabbitmq的高级特性">RabbitMQ的高级特性</span></h1><h2><span id="消息的可靠性投递">消息的可靠性投递</span></h2><ol><li><p>作为发送方，我们希望杜绝任何消息丢失或者投递失败，因此rabbitMQ 给我们提供了两种方式，来控制消息投递的可靠性。</p><ul><li>confirm确认机制</li><li>return 退回模式</li></ul></li><li><p>rabbitMQ 的整个消息投递的路径为：<code>producer-&gt; rabbitmq broker -&gt; exchange-&gt;queue-&gt;consumer</code></p><ul><li><p>消息从producer -&gt;  exchange 会返回一个confirmCallBack</p></li><li><p>消息从exchange -&gt; queue 会反回一个returnCallBack</p><p>我们将利用这两个CallBack来控制消息的可靠性投递</p></li></ul></li></ol><h2><span id="consumer-ack-消费端收到消息后的确认方式">Consumer Ack 消费端收到消息后的确认方式</span></h2><ol><li>有三种确认方式<ul><li>自动确认 acknowledge = “none”。 消息一旦到达consumer就会被确认，并将对应的message 从消息缓存中移除，实际场景中，很可能消息被收到，但是处理业务时异常，这种确认机制下，消息就会丢失。</li><li>手动确认acknowledge = “manual”。设置了手动确认，则需要在业务处理成成功后，手动调用<code>channer.basicAck()</code>,如果出现异常则调用<code>channer.basicNAck()</code>,设置消息是重新返回队列，还是直接丢掉。</li><li>根据异常情况确认 acknowledge = “auto”</li></ul></li></ol><h2><span id="消费端限流">消费端限流</span></h2><ul><li>在<a href="rabbit:listener-container">rabbit:listener-container</a> 中配置<code>prefetch</code>属性设置消费端一次拉取多少消息</li><li>消费端的确认模式需要是手动确认</li></ul><h2><span id="ttl">TTL</span></h2><ol><li>TTL全称：time to live 消息存活时间或消息过期时间</li><li>消息达到了存活时间后，如果还没被消费，会被自动移除</li><li>RabbitMQ卡哇伊对消息设置过期时间，也可以对整个队列设置过期时间。</li></ol><h2><span id="死信队列">死信队列</span></h2><ul><li><p>当消息成为死信后，可以被重新发送到一个交换机，这个交换机就是死信交换机，它绑定的队列就是死信队列</p></li><li><p>成为死信的条件：</p><ul><li>消息达到了存活时间，还没有被消费。</li><li>消费者拒收消息，并且不重回队列。  </li><li>队列到达了指定的长度限制</li></ul></li></ul><h2><span id="延迟队列">延迟队列</span></h2><p>延迟队列，消息进入队列后，不会立即被消费，而是等到一定的时间，才会被消费。</p><p>使用场景：</p><ol><li>用户下单后，30分钟未支付，取消订单，回滚库存</li><li>新用户注册7天后，发送短信问候</li></ol><blockquote><p>当然上面的场景也可以用定时器实现</p></blockquote><p>rabbitmq现在不支持延迟队列，延迟队列的实现需要借助TTL和死信队列。具体实现流程：</p><ul><li>用户下单，把消息发送到Queue1中，不设置Consumer1，设置Queue1队列里的消息存活时间为30分钟，等待30分钟后，消息成为死信。</li><li>死信的消息发送到Queue2，添加Consumer2监听Queue2</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwld73gtjaj31ga0o440f.jpg" style="zoom:43%;"><h4><span id="死信队列和延时队列的区别">死信队列和延时队列的区别</span></h4><ul><li>死信队列，监听的是Queue1,成为死信的消息会被丢到DLX中，或者不处理自己清理掉</li><li>延迟队列，监听的是死信队列</li></ul><hr><h2><span id="消息积压和解决">消息积压和解决</span></h2><h4><span id="为什么会有消费积压">为什么会有消费积压？</span></h4><ol><li>消费者宕机了</li><li>发送方发送流量太大</li><li>消费者能力不足</li></ol><h4><span id="解决方式">解决方式</span></h4><ol><li>上线更多的消费者</li><li>上线专门的队列消费服务</li><li>先取出来放到数据库，再慢慢处理</li></ol><h2><span id="消息的幂等性">消息的幂等性</span></h2><p>造成消息重复的根本原因是：网络不可达。 </p><p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收 到两条一样的消息，应该怎样处理？ </p><p>方案一： 利用一张日志表来记录已经处理成功的消息的 ID，如 果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 </p><p>方案二：</p><ul><li><p>第一次 执行更新语句的是一样，version =1 </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">update account <span class="hljs-keyword">set</span> price = price <span class="hljs-number">-100</span>, <span class="hljs-built_in">version</span> = <span class="hljs-built_in">version</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">version</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>第二次, 执行更新语句的是一样，version 已经变成了2，此时找<code>where version = 1 </code> 就无法找到</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">update account <span class="hljs-keyword">set</span> price = price <span class="hljs-number">-100</span>, <span class="hljs-built_in">version</span> = <span class="hljs-built_in">version</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">version</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><h2><span id="中间件">中间件</span></h2><ul><li>中间件<ul><li>是一种应用于分布式系统的基础软件。</li><li>常见的中间件：mysql，rabbit MQ</li></ul></li><li>怎么选择中间件<ul><li>可以通信，跨平台。比方两个项目一个java，一个go之间要通信，就要遵循同一种协议</li><li>高可用<ul><li>是否拥有持久化。比方中间件挂了，重启后是否可以把消息重新存储起来的能力</li><li>支持集群。系统cpu不够用了，就得搭集群</li></ul></li><li>有分发能力，多个系统，往那个系统去发送消息</li></ul></li></ul><h2><span id="协议">协议</span></h2><ul><li><p>网络协议三要素：</p><ul><li>语法：用户数据的结构与形式，如：http中规定了请求和响应报文的格式</li><li>语义：规定了何种信息需要对应发出何种响应，如：请求get要把参数放在url中，post把参数放在body中</li><li>时序：事件的执行顺序，如：先有请求后有响应</li></ul></li><li><p>为什么消息中间件不用http？</p><ul><li>http的请求和响应报文比较复杂，有cookie, 状态码，响应码这些，但消息中间件：只需要接受消息，存储消息，分发消息，不需要这么复杂</li><li>http大部分是短链接，不利于出现故障时消息持久化</li></ul></li><li><p>AMQP（advanced message. Queuing protocol） 高级消息队列协议</p><ul><li>采用Erlang，底层是C，速度很快</li><li>特性<ul><li>支持分布式事务</li><li>消息持久化</li><li>高性能高可靠的消息处理优势</li></ul></li></ul></li><li><p>kafka 协议</p><ul><li>基于TCP/IP的二进制协议，消息内部由长度分割，由基本数据类型构成</li><li>特性<ul><li>结构简单</li><li>解析速度快</li><li>消息持久化</li><li>不支持事务</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>rabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒杀模块学习</title>
    <link href="/2021/10/14/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2021/10/14/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1><span id="秒杀模块">秒杀模块</span></h1><h2><span id="1-秒杀接口优化">1. 秒杀接口优化</span></h2><ul><li>用户是否登陆</li><li>判断库存（备份在redis中一份）<ul><li>在初始化contoller接口的时候，就把商品id和对应的库存数存入到redis</li></ul></li><li>判断是否已经秒杀到了</li><li>减缓存， 下订单（订单和秒杀订单）<ul><li>队列里面存的消息message，有两个变量用户和商品id,</li><li>receiver监听该队列，减库存，减库存成功了，根据用户和商品id,下订单</li><li>contoller需要的就是给队列发消息，最终给前端返回一个状态值（排队中）</li></ul></li></ul><span id="more"></span><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn32zi2y7j30o40n0wfo.jpg" style="zoom: 67%;"><ul><li>前端轮询：是否生成了订单<ul><li>查询该笔订单是否存在<ul><li>存在，生成订单</li><li>不存在，查看商品是否已经秒杀完了：<ul><li>没秒杀完，就是排队中</li><li>完了，就返回该商品已经卖完了，并且在缓存中记录下该商品已经售罄了。goods_over+goodsId, true</li></ul></li></ul></li></ul></li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3541p3cj30qk0hkq4d.jpg" style="zoom:50%;"><h2><span id="2-秒杀接口地址隐藏">2. 秒杀接口地址隐藏:</span></h2><p>针对不同的用户，生成不同的秒杀地址，即秒杀地址上带一个参数，参数根据当前【用户id，商品id】随机生成，并保存在redis中，做秒杀的时候，先检查该参数是否匹配，只有匹配了才可以进行秒杀，不匹配是非法请求。</p><h2><span id="3-验证码生成">3. 验证码生成</span></h2><p>点击秒杀之前，先让用户输入验证码。有2个目的：</p><ul><li>防止机器人</li><li>用户输入验证码结果时间不同，因此分散用户的请求。</li></ul><p>实现：</p><ul><li>生成秒杀验证码，放在redis中</li><li>在秒杀的时候，先验证验证码，验证成功，删除ke y</li></ul><h2><span id="4-接口限流防刷">4. 接口限流防刷</span></h2><p>思路：</p><p>把每个用户访问接口的次数写入到缓存中，并设置失效时长s，因为可能每个方法设置的参数可能不同，所以可以通过注解+拦截器实现。</p><p>实现在 <strong>Controller</strong> 处理请求之前 先判断是否已经超过了设置的最大访问次数。</p><p>具体实现：</p><p>Step1: 在需要防刷的方法上加注解annotation，注解里设置两个参数时间seconds和最大访问次数maxCount</p><p>Step2: 添加拦截器(Interceptor)，在拦截器里先判断该方法上是否加了对应注解</p><p>Step3: 通过request中取得的method uri, 用户id 可以得到当前用户访问的该方法的次数</p><p>step4: 将该次数和注解里存的最大访问次数进行比较，看是否已经超过了限制的最大次数</p><p>Step5: redis中存放的key设置最大过期时间为注解的时间</p><p>Step5: 注册该拦截器</p><h2><span id="5-分布式session">5. 分布式session</span></h2><p>用户登陆成功后，给用户生成一个session_id标识这个用户，写在客户端cookie中，客户端访问服务器的时候会带上cookie，服务端在处理的时候，会从cookie中解码出session_id，从而取到用户信息。</p><hr><h2><span id="为什么要使用分布式session">为什么要使用分布式Session</span></h2><p>Web应用在单机部署的情况下，Session是被单个应用服务器存储管理的，由于只有一个应用服务器，用户的所有请求都是通过它进行响应处理的，所以能够很容易实现会话跟踪和保持。随着业务量的增长，系统架构需要做出调整以适应发展的需要，可能会使用分布式架构或微服务架构，无论使用哪种架构方式，应用系统单机部署的模式已经不能满足需求，所以会将应用系统部署到多台应用服务器上，用户的请求也会通过负载均衡转发到某个具体应用服务器上执行，可能会出现在A1系统登录后创建并保存Session，再次发起请求，请求被转发到A2系统上显示未登录的情况，此时单机部署模式下的Session机制已不能满足要求。所以，在分布式架构或微服务架构下，必须保证一个应用服务器上保存Session后，其它应用服务器可以同步或共享这个Session。</p><h2><span id="分布式session管理实现方案">分布式session管理实现方案</span></h2><p>分布式Session有如下几种实现方式。</p><h2><span id="1session复制">1.Session复制</span></h2><p>在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。<br>优点：代码上不需要做支持和修改。<br>缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。<br>适用场景：只适用于Web服务器比较少且Session数据量少的情况。<br>可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。</p><h2><span id="2session粘滞">2.Session粘滞</span></h2><p>将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。<br>优点：使用简单，没有额外开销。<br>缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。<br>适用场景：对稳定性要求不是很高的业务情景。</p><h2><span id="3session集中管理">3.Session集中管理</span></h2><p>在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。<br>优点：可靠性高，减少Web服务器的资源开销。<br>缺点：实现上有些复杂，配置较多。<br>适用场景：Web服务器较多、要求高可用性的情况。<br>可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。</p><h2><span id="4基于cookie管理">4.基于Cookie管理</span></h2><p>这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。<br>优点：不需要依赖额外外部存储，不需要额外配置。<br>缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。<br>适用场景：数据不重要、不敏感且数据量小的情况。</p><h2><span id="总结">总结</span></h2><p>这四种方式，相对来说，Session集s管理更加可靠，使用也是最多的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Spock框架编写测试代码</title>
    <link href="/2021/10/07/%E4%BD%BF%E7%94%A8Spock%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/10/07/%E4%BD%BF%E7%94%A8Spock%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2><span id="spock-介绍">Spock 介绍</span></h2><blockquote><ul><li><p>Spock是一个为groovy和java语言应用程序来测试和规范的框架。</p></li><li><p>这个框架的突出点在于它美妙和高效表达规范的语言。</p></li><li><p>得益于JUnit runner，Spock能够在大多数IDE、编译工具、持续集成服务下工作。</p></li><li><p>Spock的灵感源于JUnit,jMock, RSpec, Groovy, Scala, Vulcans以及其他优秀的框架形态。</p></li></ul></blockquote><h2><span id="基本操作">基本操作</span></h2><ul><li>a simple assertion</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be a simple assertion&quot;</span>() &#123;<br>    <span class="hljs-symbol">expect:</span><br>    <span class="hljs-number">1</span> == <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><ul><li>given when then 使用</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should demo given-when-then&quot;</span>()&#123;<br>     <span class="hljs-symbol">given:</span><br>     <span class="hljs-keyword">def</span> user = <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">10</span>)<br><br>     <span class="hljs-symbol">when:</span><br>     <span class="hljs-keyword">int</span> age = user.numberOfSides<br><br>     <span class="hljs-symbol">then:</span><br>     age == <span class="hljs-number">10</span><br> &#125;<br></code></pre></td></tr></table></figure><ul><li>expecting exceptions</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should expect exceptions&quot;</span>()&#123;<br>     <span class="hljs-symbol">when:</span><br>     <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">0</span>)<br><br>     <span class="hljs-symbol">then:</span><br>     thrown(TooFewSidesException)<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>data pipes.     where设置所有期望值</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should expect an exception to be throw for a number of invalid inputs&quot;</span>()&#123;<br>       <span class="hljs-symbol">when:</span><br>       <span class="hljs-keyword">new</span> Polygon(sides)<br><br>       <span class="hljs-symbol">then:</span><br>       thrown(TooFewSidesException)<br><br>       <span class="hljs-comment">//The where block says &quot;run this test with each of the following values: a negative value, zero, one and two&quot;.</span><br>       <span class="hljs-comment">// where设置所有期望值</span><br>       <span class="hljs-symbol">where:</span><br>       sides &lt;&lt; [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to create polygon with valid inputs&quot;</span>()&#123;<br>      <span class="hljs-symbol">expect:</span><br>      <span class="hljs-keyword">new</span> Polygon(sides).numberOfSides == sides<br><br>      <span class="hljs-comment">//The where block says &quot;run this test with each of the following values: a negative value, zero, one and two&quot;.</span><br>      <span class="hljs-symbol">where:</span><br>      sides &lt;&lt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>data tables</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use data tables for calculating max&quot;</span>()&#123;<br>      <span class="hljs-comment">// 如果我们只有一条语句设置了测试和断言，我们可以直接使用`expect`标签</span><br>      <span class="hljs-symbol">expect:</span><br>      Math.max(a,b) == max<br><br>      <span class="hljs-symbol">where:</span><br>      a | b | max<br>      <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">2</span><br>      <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">4</span><br>      <span class="hljs-number">5</span> | <span class="hljs-number">9</span> | <span class="hljs-number">9</span><br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>mocks 模拟出类或API来声明预期的行为</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to mock a specific class&quot;</span>() &#123;<br>        <span class="hljs-symbol">given:</span><br>        Renderer renderer = Mock()<br><br>        <span class="hljs-comment">//@Subject只是为了标记我们正在测试的对象，对代码没有任何影响</span><br>        <span class="hljs-meta">@Subject</span><br>        <span class="hljs-keyword">def</span> ploygon = <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">4</span>, renderer)<br><br>        <span class="hljs-symbol">when:</span><br>        ploygon.draw()<br><br>        <span class="hljs-symbol">then:</span><br>        <span class="hljs-number">4</span> * renderer.drawLine()<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>stubs 在测试的代码里提供数据或者值</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to create a stubs&quot;</span>() &#123;<br>       <span class="hljs-symbol">given:</span><br>       Palette palette = Stub()<br>       palette.getPrimaryColor() &gt;&gt; Color.red<br><br>       <span class="hljs-keyword">def</span> renderer =  <span class="hljs-keyword">new</span> Renderer(palette)<br><br>       <span class="hljs-symbol">expect:</span><br>       renderer.getForeGroundColor() == Color.red<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li> help methods</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use a helper methods&quot;</span>() &#123;<br>    <span class="hljs-symbol">given:</span><br>    Renderer renderer = Mock()<br>    <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>    <span class="hljs-symbol">when:</span><br>    <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>    <span class="hljs-symbol">then:</span><br>    checkDefaultShape(polygon, renderer)<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-keyword">void</span> checkDefaultShape(Polygon polygon, Renderer renderer) &#123;<br>    <span class="hljs-keyword">assert</span> polygon.numberOfSides == <span class="hljs-number">4</span><br>    <span class="hljs-keyword">assert</span> renderer == renderer<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>with 测试但个对象的多个属性</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use #with()&quot;</span>() &#123;<br>        <span class="hljs-symbol">given:</span><br>        Renderer renderer = Mock()<br>        <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>        <span class="hljs-symbol">when:</span><br>        <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>        <span class="hljs-symbol">then:</span><br>        with(polygon)&#123;<br>            numberOfSides == <span class="hljs-number">4</span><br>            renderer == render<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>verifyAll() 确保所有断言都在执行，而不管其中之一是否失败了。</p><p>当使用with时，第一行测试失败了，第二行测试就不会执行了，而verifyAll 会运行所有行测试</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use #verifyAll()&quot;</span>() &#123;<br>       <span class="hljs-symbol">given:</span><br>       Renderer renderer = Mock()<br>       <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>       <span class="hljs-symbol">when:</span><br>       <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>       <span class="hljs-symbol">then:</span><br>       verifyAll(polygon)&#123;<br>           numberOfSides == <span class="hljs-number">5</span><br>           renderer == <span class="hljs-literal">null</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p>setup-and-teardown</p><ul><li>setupSpec():  在规范的开始设置状态一次，这是为了在各个测试方法之间不应该改变的东西</li><li>setup(): 将在该类中的每个单独测试方法之前运行。这可用于在每次测试开始时设置干净状态。</li><li> cleanup(): 在每个测试方法结束时清理数据或状态</li><li>cleanupSpec() :  对于最终的分解代码，该方法将在运行所有测试的最后调用一次。</li></ul></li><li><p>and可以增加多个使代码根据可读性：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">given: <span class="hljs-string">&quot;test method&quot;</span><br><span class="hljs-regexp">//</span> code ....<br><br>and: <span class="hljs-string">&quot;test method with user1&quot;</span><br><span class="hljs-regexp">//</span> code ...<br><br>and: <span class="hljs-string">&quot;test method with user2&quot;</span><br><span class="hljs-regexp">//</span> code ...<br></code></pre></td></tr></table></figure></li></ul><p>​</p>]]></content>
    
    
    <categories>
      
      <category>spock</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kotlin学习</title>
    <link href="/2021/10/06/kotlin%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/10/06/kotlin%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2><span id="1kotlin-是什么">1.Kotlin 是什么？</span></h2><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。</p><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><h2><span id="2为什么选择-kotlin">2.为什么选择 Kotlin？</span></h2><ul><li>简洁: 大大减少样板代码的数量。</li><li>安全: 避免空指针异常等整个类的错误。</li><li>互操作性: 充分利用 JVM、Android 和浏览器的现有库。</li><li>工具友好: 可用任何 Java IDE 或者使用命令行构建。</li></ul><span id="more"></span><h2><span id="3我的第一个-kotlin-程序">3.我的第一个 Kotlin 程序</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello word!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Kotlin 程序文件以 <strong>.kt</strong> 结尾，如：hello.kt 、app.kt。</p></blockquote><h2><span id="4基础语法">4.基础语法</span></h2><ul><li>函数定义</li></ul><p>格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 方法名<span class="hljs-params">(参数A : 类型<span class="hljs-type">A</span>, 参数B : 类型<span class="hljs-type">B</span>)</span></span>: 返回值类型(可以为空) &#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;   <span class="hljs-comment">// Int 参数，返回值 Int</span><br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> result = add(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br>    println(result)<br>&#125;<br><br><span class="hljs-comment">//fun add(x: Int, y: Int): Int &#123;</span><br><span class="hljs-comment">//  return x+ y</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x+ y<br></code></pre></td></tr></table></figure><ul><li>可变长参数</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">vars</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> v:<span class="hljs-type">Int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vt <span class="hljs-keyword">in</span> v)&#123;<br>        print(vt)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    vars(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出12345</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认参数和具名参数</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calThePerimeterOfCircle</span><span class="hljs-params">(pi: <span class="hljs-type">Float</span> = Pi, r: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>* pi * r<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;圆的周长为：<span class="hljs-subst">$&#123;calThePerimeterOfCircle(r = <span class="hljs-number">2.0</span>f)&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数表达式</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> i = &#123;x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x+ y&#125;<br>    println(i(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))<br><br>    <span class="hljs-comment">// 输入类型是两个int ，返回值是int，输入参数为x,y 表达式为x+y</span><br>    <span class="hljs-keyword">var</span> j:(<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123;x,y -&gt; x+y&#125;<br>    println(i(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>条件控制 if</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnBigValue</span><span class="hljs-params">(a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>)</span></span>:<span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (a&gt;b) a <span class="hljs-keyword">else</span> b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a= <span class="hljs-number">3</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">5</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;a&#125;</span>和<span class="hljs-subst">$&#123;b&#125;</span>中较大的数是<span class="hljs-subst">$&#123;returnBigValue(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>When 表达式</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gradeStudent</span><span class="hljs-params">(score:<span class="hljs-type">Int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">when</span>(score)&#123;<br>        <span class="hljs-number">10</span> -&gt; println(<span class="hljs-string">&quot;优秀！&quot;</span>)<br>        <span class="hljs-number">1</span> -&gt; println(<span class="hljs-string">&quot;差劲！&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;努力努力！&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(gradeStudent(<span class="hljs-number">9</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>list</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> items = listOf&lt;String&gt;(<span class="hljs-string">&quot;语文&quot;</span>,<span class="hljs-string">&quot;数学&quot;</span>,<span class="hljs-string">&quot;英语&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> items)&#123;<br>        println(<span class="hljs-string">&quot;科目有：<span class="hljs-subst">$&#123;i&#125;</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> ((i,index) <span class="hljs-keyword">in</span> items.withIndex())&#123;<br>        println(<span class="hljs-string">&quot;科目为：<span class="hljs-subst">$&#123;i&#125;</span>，序号为<span class="hljs-subst">$&#123;index&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>map</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> map = TreeMap&lt;String,String&gt;()<br>    map[<span class="hljs-string">&quot;好&quot;</span>] = <span class="hljs-string">&quot;good&quot;</span><br>    map[<span class="hljs-string">&quot;坏&quot;</span>] = <span class="hljs-string">&quot;bad&quot;</span><br>    println(map[<span class="hljs-string">&quot;好&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>字符串和数字的转换</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;string&quot;</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span><br>    println(<span class="hljs-string">&quot;字符串转数字：<span class="hljs-subst">$&#123;a.toString()&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;数字转字符串：<span class="hljs-subst">$&#123;b.toInt()&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>控制台输入变量</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;请输入第一个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str1 = readLine()<br>    println(<span class="hljs-string">&quot;请输入第二个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str2 = readLine()<br><br>    <span class="hljs-keyword">var</span> num1 = str1!!.toInt()<br>    <span class="hljs-keyword">var</span> num2 = str2!!.toInt()<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;num1&#125;</span>+<span class="hljs-subst">$&#123;num2&#125;</span>=<span class="hljs-subst">$&#123;num1+num2&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>处理异常-&gt; try…catch()</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;请输入第一个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str1 = readLine()<br>    println(<span class="hljs-string">&quot;请输入第二个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str2 = readLine()<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">var</span> num1 = str1!!.toInt()<br>        <span class="hljs-keyword">var</span> num2 = str2!!.toInt()<br>        println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;num1&#125;</span>+<span class="hljs-subst">$&#123;num2&#125;</span>=<span class="hljs-subst">$&#123;num1+num2&#125;</span>&quot;</span>)<br>    &#125;<span class="hljs-keyword">catch</span> (e: Exception)&#123;<br>        println(<span class="hljs-string">&quot;输入的数据有误！&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>字符串模板</p><p>$ 表示一个变量名或者变量值</p><p>$varName 表示变量值</p><p>${varName.fun()} 表示变量的方法返回值:</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 模板中的简单名称：</span><br>    <span class="hljs-keyword">val</span> s1 = <span class="hljs-string">&quot;a is <span class="hljs-variable">$a</span>&quot;</span><br><br>    a = <span class="hljs-number">2</span><br><span class="hljs-comment">// 模板中的任意表达式：</span><br>    <span class="hljs-keyword">val</span> s2 = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;s1.replace(<span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;was&quot;</span>)&#125;</span>, but now is <span class="hljs-variable">$a</span>&quot;</span><br>    println(s2)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>空值处理</p><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式。</p><ul><li><p>字段后加!!像Java一样抛出空异常</p></li><li><p>字段后加?可不做处理返回值为 null或配合?:做空判断处理</p></li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//类型后面加?表示可为空</span><br><span class="hljs-keyword">var</span> age: String? = <span class="hljs-string">&quot;23&quot;</span> <br><span class="hljs-comment">//抛出空指针异常</span><br><span class="hljs-keyword">val</span> ages = age!!.toInt()<br><span class="hljs-comment">//不做处理返回 null</span><br><span class="hljs-keyword">val</span> ages1 = age?.toInt()<br><span class="hljs-comment">//age为空返回-1</span><br><span class="hljs-keyword">val</span> ages2 = age?.toInt() ?: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2><span id="5类">5.类</span></h2><h3><span id="51-类的创建">5.1 类的创建</span></h3><p>Kotlin 中没有 new 关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangular</span></span>&#123;<br>    <span class="hljs-keyword">var</span> width:<span class="hljs-built_in">Int</span> = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> height:<span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> rectangular = Rectangular()<br>    println(rectangular.height)<br>&#125;<br></code></pre></td></tr></table></figure><h3><span id="52-枚举类">5.2 枚举类</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>&#123;<br>    RED,BLACK,BLUE,GREEN,WHITE<br>&#125;<br></code></pre></td></tr></table></figure><h3><span id="6-kotlin-继承">6. Kotlin 继承</span></h3><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span> // 从 <span class="hljs-symbol">Any</span> 隐式继承<br></code></pre></td></tr></table></figure><p>Any 默认提供了三个函数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">equals</span><span class="hljs-params">()</span></span><br><br><span class="hljs-function"><span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><br><span class="hljs-function"><span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>注意：Any 不是 java.lang.Object。</p><p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">open <span class="hljs-keyword">class</span> <span class="hljs-symbol">Base</span>(<span class="hljs-symbol">p: <span class="hljs-symbol">Int</span></span>)           // 定义基类<br><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Derived</span>(<span class="hljs-symbol">p: <span class="hljs-symbol">Int</span></span>) : <span class="hljs-symbol">Base</span>(<span class="hljs-symbol">p</span>)<br></code></pre></td></tr></table></figure><h1><span id="7kotlin-接口">7.Kotlin 接口</span></h1><p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 未实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">//已实现</span><br>      <span class="hljs-comment">// 可选的方法体</span><br>      println(<span class="hljs-string">&quot;foo&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> : <span class="hljs-type">MyInterface1</span>,<span class="hljs-type">MyInterface2 &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar1</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 方法体</span><br>    &#125;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot整合graphql</title>
    <link href="/2021/10/06/springboot%E6%95%B4%E5%90%88graphql/"/>
    <url>/2021/10/06/springboot%E6%95%B4%E5%90%88graphql/</url>
    
    <content type="html"><![CDATA[<p>GraphQL是比REST更高效、强大和灵活的<strong>新一代API标准</strong>。详细的可以看官网<a href="https://graphql.cn/">GraphQL</a>。</p><p>下面介绍一个Spring boot整合graphql简单的例子。</p><span id="more"></span><ul><li><p>项目准备：相关依赖的引入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">&lt;dependencies&gt;</span><br><span class="hljs-meta">&lt;!--web</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--lombok</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--graphql</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;version&gt;11.0.0&lt;/version&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--playground</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;playground-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;version&gt;11.0.0&lt;/version&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-attr">&lt;/dependencies&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4><span id="query">Query</span></h4><ul><li><p>定义schema，分别为：</p><p><code>query.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">type Query&#123;<br>  billingAccount(id: ID): BillingAccount<br>&#125;<br></code></pre></td></tr></table></figure><p><code>billingAccount.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">type BillingAccount &#123;<br>  id: ID!<br>  name: String!<br>  currency: Currency<br>&#125;<br></code></pre></td></tr></table></figure><p><code>currency.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Currency</span></span>&#123;<br>    RMB,<br>    USD<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义基础要操作的模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccount</span> </span>&#123;<br>    UUID id;<br>    String name;<br>    Currency currency;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Currency</span> </span>&#123;<br>    RMB, USD<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义resolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccountResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GraphQLQueryResolver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BillingAccount <span class="hljs-title">billingAccount</span><span class="hljs-params">(UUID id)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;receive billingAccount id is: &quot;</span>+ id);<br>        <span class="hljs-keyword">return</span> BillingAccount.builder()<br>                .id(id)<br>                .currency(Currency.RMB)<br>                .name(<span class="hljs-string">&quot;张三&quot;</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li>效果图</li></ul><p><img src="/images/resolver.png" alt="img"></p><h4><span id="mutation">mutation</span></h4><ul><li>定义schema</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Mutation</span>&#123;<br>    createBillingAccount(input: <span class="hljs-type">CreateBillingAccountInput</span>): <span class="hljs-type">BillingAccount</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义input</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span> CreateBillingAccountInput&#123;<br>    name: String<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义input 对应的model</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateBillingAccountInput</span> </span>&#123;<br>  String name;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义mutationResolver</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccountMutation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GraphQLMutationResolver</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BillingAccount <span class="hljs-title">createBillingAccount</span><span class="hljs-params">(CreateBillingAccountInput input)</span></span>&#123;<br><br>    <span class="hljs-keyword">return</span> BillingAccount.builder()<br>      .id(UUID.randomUUID())<br>      .currency(Currency.RMB)<br>      .name(input.getName())<br>      .build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图</p><p>!<img src="/images/mutation.png" alt="mutation"></p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Webflux</title>
    <link href="/2021/10/05/%20Spring%20Webflux/"/>
    <url>/2021/10/05/%20Spring%20Webflux/</url>
    
    <content type="html"><![CDATA[<p><strong>1.响应式编程是什么？</strong></p><ul><li><p>响应式编程（<strong>reactive programming</strong>）是一种基于数据流和变化传递的声明式的编程范式</p><p>本来数据是我们自行处理的，后来我们把要处理的数据抽象出来（变成了数据流），然后通过<strong>API</strong>去处理数据流中的数据（是声明式的,如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum2 = IntStream.of(nums).parallel().sum();<br></code></pre></td></tr></table></figure></li></ul><p>​      将数组中的数据变成数据流，通过显式声明调用**.sum()**来处理数据流中的数据，得到最终的结果。</p><ul><li><p>响应式编程是关于非阻塞应用程序的，这些应用程序是异步的、事件驱动的，并且需要少量的线程来垂直伸缩(即在 JVM 中)，而不是水平伸缩(即通过集群)。</p><blockquote><p>工作太多，做不完时，水平伸缩就相当于加人，垂直伸缩相当于加班。</p></blockquote></li></ul><h3><span id="2响应式流reactive-streams-是什么">2.响应式流（Reactive Streams） 是什么?</span></h3><span id="more"></span><ul><li><p>响应式流是JDK9引入的，基于发布-订阅者模式的一套数据处理的机制。</p></li><li><p>响应式流从2013年开始，作为提供非阻塞背压的异步流处理标准的倡议。 它旨在解决处理元素流的问题——如何将元素流从发布者传递到订阅者，而不需要发布者阻塞，或订阅者有无限制的缓冲区或丢弃。</p></li></ul><blockquote><p>背压：说白了就是一种反馈，发布者和订阅者之间的一种互动</p></blockquote><blockquote><p>之前的老模式，订阅者很被动，发布者给订阅者多少他就消费多少，不能多也不能多少。</p><p>Reactive Streams就可以做到发布者和订阅者之间可以进行交流，订阅者可以告诉发布者我需要多少数据，订阅者处理完了，可以再向发布者要，没处理完就不要给我。</p><p>起到了一种调节流量的作用，不会导致发布者数据太多，订阅者处理不完浪费，或者直接把订阅者压垮的场景。</p></blockquote><h3><span id="2-spring-webflux-是什么">2. Spring Webflux 是什么？</span></h3><p>Spring WebFlux是<a href="https://rumenz.com/java-topic/spring-mvc-tutorial/index.html">Spring MVC</a>并行版本，并支持完全无阻塞的反应流的web框架。 它支持背压概念，可以处理大量的并发连接，并使用**<a href="https://netty.io/">Netty</a>**作为内置服务器来运行响应式应用程序。 </p><h3><span id="3spring-webflux-和spring-mvc-的关系">3.Spring Webflux 和Spring mvc 的关系</span></h3><img src="https://spring.io/images/diagram-reactive-1290533f3f01ec9c57baf2cc9ea9fa2f.svg" style="zoom: 25%;"><p>Spring MVC</p><ul><li>构建于 Servlet API 之上</li><li>同步阻塞 I/O 模型, 认为应用会阻塞当前线程，所以一个 Request 对应一个 Thread，需要有一个含有大量线程的线程池</li></ul><p>Spring WebFlux</p><ul><li>构建于 Reactive Streams Adapters 之上</li><li>异步非阻塞 I/O 模型，认为应用不会阻塞当前线程，所以只是需要一个包含少数固定线程数的线程池 (event loop workers) 来处理请求</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringWebflux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性之Stream流</title>
    <link href="/2021/10/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/"/>
    <url>/2021/10/04/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3><span id="java8新特性之stream流">Java8新特性之Stream流</span></h3><h3><span id="1什么是stream">1.什么是Stream？</span></h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。通过声明性方式，能够对集合中的每个元素进行一系列并行或串行的流水线操作。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">int</span> num2 = IntStream.of(numbers).sum();<br>        System.out.println(num2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3><span id="2创建流的几种方式">2.创建流的几种方式</span></h3><span id="more"></span><h4><span id="21-使用集合">2.1 使用集合</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList();<br>arrayList.stream();<br>arrayList.parallelStream();  <br></code></pre></td></tr></table></figure><h4><span id="22-使用数组">2.2 使用数组</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><h4><span id="23-数字stream">2.3 数字Stream</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>IntStream.rangeClosed(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h4><span id="24-使用streamgenerate">2.4 使用Stream.generate()</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.generate(()-&gt; <span class="hljs-string">&quot;stream&quot;</span>).limit(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h3><span id="3-常用方法">3. 常用方法</span></h3><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><blockquote><ul><li>延迟方法：返回值任然是Stream接口自身类型的方法，因此支持链式调用(除了终结方法外，其他都是方法均为延迟方法)</li><li>终结方法：返回值类型不再是Stream接口自身类型的方法。</li></ul></blockquote><h4><span id="31-延迟方法">3.1 延迟方法</span></h4><h5><span id="1-filter">1. filter</span></h5><p>可以通过<code>filter</code>方法将一个流转换成另一个子集流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>).filter(i -&gt; i&gt;<span class="hljs-number">2</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5><span id="2peek">2.peek</span></h5><p>用于debug，foreach是最终操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).peek(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out::println).<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><h5><span id="3map">3.map</span></h5><p>将流中的元素映射到另一个流中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).map(String::length).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5><span id="4limit">4.limit</span></h5><p>对流进行截取，只取用前n个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5><span id="5skip">5.skip</span></h5><p>跳过前几个</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).skip(<span class="hljs-number">2</span>).<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><h4><span id="32-终止方法">3.2 终止方法</span></h4><h5><span id="1foreach">1.forEach</span></h5><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5><span id="2count">2.count</span></h5><p>计算个数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).count<span class="hljs-literal">()</span>);<br></code></pre></td></tr></table></figure><h5><span id="3collect">3.collect</span></h5><p>收集到list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).collect(Collectors.toList());<br>System.out.println(<span class="hljs-string">&quot;收集到list:&quot;</span>+list);<br></code></pre></td></tr></table></figure><h5><span id="4reduce">4.reduce</span></h5><p>从Stream中生成一个值</p><ul><li>使用reduce拼接字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; newStr = Stream.of(str.split(<span class="hljs-string">&quot;&quot;</span>)).reduce((str1, str2) -&gt; str1 + <span class="hljs-string">&quot;-&quot;</span> + str2);<br>System.out.println(newStr.orElse(<span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>使用reduce拼接字符串-+ 带有初始值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String newStr2 = Stream.of(str.split(<span class="hljs-string">&quot;&quot;</span>)).reduce(<span class="hljs-string">&quot;&quot;</span>, (str1, str2) -&gt; str1 + <span class="hljs-string">&quot;-&quot;</span> + str2);<br>System.out.println(newStr2);<br></code></pre></td></tr></table></figure><ul><li>使用reduce计算所有单词总长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Integer&gt; length = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).map(s -&gt; s.length()).reduce((len1, len2) -&gt; len1 + len2);<br>System.out.println(<span class="hljs-string">&quot;length:&quot;</span> + length.get());<br></code></pre></td></tr></table></figure><h5><span id="5max">5.max</span></h5><p>求最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; maxValue = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).max((str1, str2) -&gt; str1.length() - str2.length());<br>System.out.println(<span class="hljs-string">&quot;maxValue:&quot;</span> + maxValue.get());<br></code></pre></td></tr></table></figure><h5><span id="6findfirst">6.findFirst</span></h5><p>找第一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; firstValue = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).findFirst();<br>System.out.println(<span class="hljs-string">&quot;firstValue:&quot;</span> + firstValue.get());<br></code></pre></td></tr></table></figure><h3><span id="4-惰性求值">4. 惰性求值</span></h3><p>惰性求值：终结没有调用的情况下，延迟方法不会执行。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">int</span> num2 = IntStream.of(numbers).map(StreamDemo1::doubleNum).sum();<br>        System.out.println(num2);<br>      <br>      <span class="hljs-comment">// 这里没有执行中间操作</span><br>        IntStream.of(numbers).map(StreamDemo1::doubleNum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doubleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了乘以2&quot;</span>);<br>        <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">Task :StreamDemo1.main()</span><br>执行了乘以2<br>执行了乘以2<br>执行了乘以2<br>12<br></code></pre></td></tr></table></figure><p>中间操作就是：返回stream的操作，如：map</p><p>终止操作就是：sum()</p><p>从输出结果可以看出doubleNum执行了3次</p><h3><span id="5并行流">5.并行流</span></h3><h4><span id="51-创建一个并行流">5.1 创建一个并行流</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>).parallel().peek(ParallelStream::debugger).count();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;debugger&quot;</span>+i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">Task :ParallelStream.main()</span><br>debugger90<br>debugger81<br>debugger82<br>debugger83<br>debugger84<br>debugger85<br>debugger86<br>debugger65<br>debugger66<br>debugger67<br><span class="hljs-meta">...</span><br></code></pre></td></tr></table></figure><ul><li>多次调用parallel / sequential，以最后一个为准，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>                .parallel().peek(ParallelStream::debugger)<br>                .sequential().peek(ParallelStream::debugger2)<br>                .count();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.err.println(<span class="hljs-string">&quot;debugger2: &quot;</span> + i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;debugger1: &quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4><span id="52-并行流使用自己定义的线程池">5.2 并行流使用自己定义的线程池</span></h4><blockquote><p>原因：避免使用默认线程池，防止任务被阻塞</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">20</span>);<br>        forkJoinPool.submit(() -&gt; IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>                .parallel().peek(ParallelStream::debugger)<br>                .count());<br>        forkJoinPool.shutdown();<br><br>        <span class="hljs-keyword">synchronized</span> (forkJoinPool) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                forkJoinPool.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;debugger1: &quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3><span id="6-stream-流的运行机制">6. Stream 流的运行机制</span></h3><p>所有的操作都是链式调用，每个操作只会对每个元素操作一次；（是通过维护一个链表实现的。）具体实现：</p><blockquote><ul><li>每个中间操作都会返回一个新的流，每个流里面都会有一个SourceStage属性，所有流的SourceStage属性都指向同一个地方head【就是原始流的头部】；</li><li>如果一个中间操作之后还有中间操作，那么这个中间操作对应的流中nextStage属性就会执行下一个中间操作对应的流，否则就是null</li></ul></blockquote><p>注：parallel / sequential也是中间操作，但是他们呢不创建流，只是修改head 里的并行标志：parallel</p>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8的新特性之lambda表达式</title>
    <link href="/2021/10/04/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/10/04/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3><span id="1函数接口">1.函数接口</span></h3><p>函数接口（<code>@FunctionalInterface</code>）需要满足两个条件：</p><ul><li>类型是接口</li><li>有且只有一个抽象方法</li></ul><p>例如：Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这也是要求我们接口的设计尽量小，符合单一责任制，一个接口只做一个事，这样使用lambda就会比较方便。</p><h3><span id="2-lambda表达式是个啥">2. lambda表达式是个啥？</span></h3><p><strong>lambda表达式</strong>是<strong>Java8</strong>的新特性，它就是就是一个匿名函数，箭头左边是函数的参数，右边是函数的执行体。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>              System.out.println(<span class="hljs-string">&quot;正常创建一个线程&quot;</span>);<br>          &#125;<br>      &#125;).start();<br>      # 实际上是返回了一个实现了Runnable的实例，箭头左边是参数，右边是方法体<br>      <span class="hljs-keyword">new</span> Thread(()-&gt; System.out.println(<span class="hljs-string">&quot;Lambda创建一个线程&quot;</span>)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上面的代码为例，Runnable接口仅有一个run方法，并且该方法没有参数，所以编译器可以自动推断出箭头后的内容为run方法的方法体。</p><p>如果Runnable接口中含有多个方法，编译器将无法编译lambda表达式，可以看出，lambda表达式是根据编译器的隐式推断来简化代码的。所以，<strong>lambda表达式需要函数式接口的支持。</strong></p><p><strong>实例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MoneyFormat</span></span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">format</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMoney</span><span class="hljs-params">(MoneyFormat moneyFormat)</span></span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;金额数为：&quot;</span> + moneyFormat.format(<span class="hljs-keyword">this</span>.money)));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MoneyDemo moneyDemo = <span class="hljs-keyword">new</span> MoneyDemo(<span class="hljs-number">999</span>);<br>        moneyDemo.printMoney(i -&gt; <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#,##&quot;</span>).format(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上可见，我们不关心接口的名字是什么，只关心输入是int，输出 是string，因此上面代码可优化为：</p><p>删除interface MoneyFormat，使用jdk8带的函数接口Function&lt;Integer,String&gt;替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMoney</span><span class="hljs-params">(Function&lt;Integer,String&gt; moneyFormat)</span></span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;金额数为：&quot;</span> + moneyFormat.apply(<span class="hljs-keyword">this</span>.money)));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MoneyDemo moneyDemo = <span class="hljs-keyword">new</span> MoneyDemo(<span class="hljs-number">999</span>);<br>        moneyDemo.printMoney(i -&gt; <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#,##&quot;</span>).format(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3><span id></span></h3><h2><span id="3-lambda表达式常用的函数式接口">3. lambda表达式常用的函数式接口</span></h2><p>主要是分布在java.util.function包中，下面只简单列举2种：</p><h4><span id="21-supplier接口">2.1 Supplier接口</span></h4><ul><li><code>java.util.function.Supplier&lt;T&gt;</code> 接口仅含有一个无参方法,<code>T get()</code></li><li><code>Supplier&lt;T&gt;</code> 接口是生产型接口,接口泛型指定什么类型,就返回什么泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupplierDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">supplyName</span><span class="hljs-params">(Supplier&lt;String&gt; supplier)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SupplierDemo supplierDemo = <span class="hljs-keyword">new</span> SupplierDemo();<br>        String name = supplierDemo.supplyName(() -&gt; <span class="hljs-string">&quot;张三&quot;</span>);<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3><span id="32-consumer接口">3.2 Consumer接口</span></h3><ul><li><code>java.util.function.Consumer接口&lt;T&gt;</code> 接口仅含有一个有参方法,<code>void accept(T t)</code></li><li><code>Consumer接口&lt;T&gt;</code> 接口是消费型接口,接口泛型制定什么类型,就接受什么泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(String name, Consumer&lt;String&gt; consumer)</span> </span>&#123;<br>        consumer.accept(name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConsumerDemo consumerDemo = <span class="hljs-keyword">new</span> ConsumerDemo();<br>        consumerDemo.printName(<span class="hljs-string">&quot;张三&quot;</span>, (String name) -&gt; System.out.println(<span class="hljs-string">&quot;姓名为 : &quot;</span> + name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3><span id></span></h3>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lambda表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8的新特性之方法引用</title>
    <link href="/2021/10/04/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/2021/10/04/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3><span id="1方法引用是什么">1.方法引用是什么？</span></h3><blockquote><p>Java8的新特性之二：方法引用。方法引用其实也离不开Lambda表达式。</p></blockquote><ul><li><p>方法引用通过方法的名字来指向一个方法。</p></li><li><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p>方法引用使用一对冒号 <strong>::</strong> 。</p></li></ul><h2><span id="2-方法引用的分类">2、方法引用的分类</span></h2><p>下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。</p><span id="more"></span><table><thead><tr><th align="center">类型</th><th>语法</th><th>对应lambda表达式</th></tr></thead><tbody><tr><td align="center">静态方法引用</td><td>类名::staticMethod</td><td>(args) -&gt; 类名.staticMethod(args)</td></tr><tr><td align="center">实例方法引用</td><td>instance::instance_Method</td><td>(args) -&gt; instance.instance_Method(args)</td></tr><tr><td align="center">对象方法引用</td><td>类名::instance_Method</td><td>(inst,args) -&gt; 类名.instance_Method(args)</td></tr><tr><td align="center">构建方法引用</td><td>类名::new</td><td>(args) -&gt; new 类名(args)</td></tr></tbody></table><h3><span id="3-方法引用举例">3、方法引用举例</span></h3><h4><span id="31-静态方法引用">3.1 静态方法引用</span></h4><ul><li><p>实例1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s); 输出的参数和输入的参数一致，可以缩写</span><br>    Consumer&lt;String&gt; consumer = System.out::println;<br>    consumer.accept(<span class="hljs-string">&quot;接受的数据&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> 实例中我们将 System.out::println 方法作为静态方法来引用。</p></li><li><p>实例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>            System.out.println(dog + <span class="hljs-string">&quot;狗叫了&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">//静态方法</span><br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        Consumer&lt;Dog&gt; consumer2 = Dog::bark;<br>        consumer2.accept(dog);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4><span id="32-实例方法引用">3.2 实例方法引用</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> food_weight = <span class="hljs-number">10</span>;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;小狗吃了&quot;</span> + weight + <span class="hljs-string">&quot;斤狗粮&quot;</span>);<br>            <span class="hljs-keyword">this</span>.food_weight -= weight;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.food_weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">// Function&lt;Integer, Integer&gt; function = dog::eat;</span><br>        <span class="hljs-comment">// UnaryOperator&lt;Integer&gt; function = dog::eat;</span><br>        <span class="hljs-comment">// int weight = function.apply(3);</span><br>        IntUnaryOperator function = dog::eat;<br>        <span class="hljs-keyword">int</span> weight = function.applyAsInt(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;还剩余&quot;</span> + weight + <span class="hljs-string">&quot;斤狗粮&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的eat方法，页可改写为<code>public int eat(Dog this, int weight) </code>编译也不会报错。因此=》</p><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">JDk会默认把当前实例传入到非静态方法，参数名为<span class="hljs-keyword">this</span>，位置是第一个<br></code></pre></td></tr></table></figure></blockquote><h4><span id="33-构建方法引用">3.3 构建方法引用</span></h4><ul><li>无参数的构造方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;Dog&gt; supplier = Dog::<span class="hljs-keyword">new</span>;<br>        System.out.println(supplier.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有参数的构造方法的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;String,Dog&gt; function2 =  Dog::<span class="hljs-keyword">new</span>;;<br>        System.out.println(function2.apply(<span class="hljs-string">&quot;小杂毛&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式引擎基础</title>
    <link href="/2021/09/28/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/09/28/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1><span id="搜索引擎">搜索引擎</span></h1><h2><span id="搜索引擎是什么">搜索引擎是什么？</span></h2><p>是一个检索服务，主要分全文检索和垂直检索。</p><h2><span id="es是什么">Es是什么？</span></h2><ul><li>ElasticSearch，分布式的索引库，Nosql。mysql</li><li>-对外提供检索服务，http或者transport协议对外提供搜索。Restful的json。Es6.6.0  es2.x。</li><li>对内就是一个数据库，nosql</li></ul><blockquote><p>缺点：nosql 非关系型的s没有办法链接查询的，也就是跨索引查询。</p></blockquote><h1><span id></span></h1>]]></content>
    
    
    <categories>
      
      <category>分布式搜索引擎</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oauth2</title>
    <link href="/2021/09/26/oauth2/"/>
    <url>/2021/09/26/oauth2/</url>
    
    <content type="html"><![CDATA[<hr><h1><span id="oauth20">oauth2.0</span></h1><h2><span id="一-oauth20-产生">一. oauth2.0 产生</span></h2><ol><li>传统方式：用户和第三方共享密码<ul><li>不安全。未来可能会持久访问资源，第三方存储用户密码不安全，因为他可以访问用户的所有资源</li><li>改密码的话，第三方会失效</li></ul></li></ol><h2><span id="二-oauth20是什么">二. oauth2.0是什么？</span></h2><blockquote><ul><li><p>oauth2.0 是一种授权方式，使第三方可以获得对用户资源的访问</p></li><li><p>他的核心就是：向第三方应用颁发令牌</p></li><li><p>不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）</p></li></ul></blockquote><h2><span id="三oauth-20-规定了四种获得令牌的流程">三.OAuth 2.0 规定了四种获得令牌的流程</span></h2><span id="more"></span><h3><span id="31-授权码模式">3.1 授权码模式</span></h3><p><strong>第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><ol><li><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">https:<span class="hljs-comment">//b.com/oauth/authorize?</span><br>  response_type=code&amp;                        <br>  client_id=CLIENT_ID&amp;<br>  redirect_uri=CALLBACK_URL&amp;<br>  scope=read<br></code></pre></td></tr></table></figure><ul><li>response_type表示要求返回授权码</li><li>client_id让B网站知道是谁在请求</li><li>redirect_uri 是B网站接受或处理后跳转的URL</li><li>scope 表示授权的范围，这里是只读</li></ul></li><li><p>第二步，此时B网站会询问用户是否给予A网站授权，用户表示同意，这时B网站就会跳转到上一步<code>redirect_uri</code> 中的地址（也就是我们常说的callback地址），同时返回一个授权码，如下面的地址，其中，<code>code</code>参数就是授权码</p></li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//a.com/callback?code=AUTHORIZATION_CODE</span><br></code></pre></td></tr></table></figure><ol start="3"><li>第三步，A网站拿到授权码后，就可以根据该授权码，在后端向B网站请求<strong>令牌</strong></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/token?</span><br> <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br> <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET&amp;</span><br> <span class="hljs-attr">grant_type</span>=<span class="hljs-string">authorization_code&amp;</span><br> <span class="hljs-attr">code</span>=<span class="hljs-string">AUTHORIZATION_CODE&amp;</span><br> <span class="hljs-attr">redirect_uri</span>=<span class="hljs-string">CALLBACK_URL</span><br></code></pre></td></tr></table></figure><ul><li><p><code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求）</p></li><li><p><code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码</p></li><li><p><code>code</code>参数是上一步拿到的授权码</p></li><li><p><code>redirect_uri</code>参数是令牌颁发后的回调网址。</p></li></ul><ol start="4"><li><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim">&#123;    <br>  <span class="hljs-string">&quot;access_token&quot;</span>:<span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span>,<br>  <span class="hljs-string">&quot;token_type&quot;</span>:<span class="hljs-string">&quot;bearer&quot;</span>,<br>  <span class="hljs-string">&quot;expires_in&quot;</span>:<span class="hljs-number">2592000</span>,<br>  <span class="hljs-string">&quot;refresh_token&quot;</span>:<span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span>,<br>  <span class="hljs-string">&quot;scope&quot;</span>:<span class="hljs-string">&quot;read&quot;</span>,<br>  <span class="hljs-string">&quot;uid&quot;</span>:<span class="hljs-number">100101</span>,<br>  <span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p></li></ol><h4><span id="32-隐藏式模式适合没有后台的第三方">3.2 隐藏式模式（适合没有后台的第三方）</span></h4><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/authorize?</span><br>  <span class="hljs-attr">response_type</span>=<span class="hljs-string">token&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">redirect_uri</span>=<span class="hljs-string">CALLBACK_URL&amp;</span><br>  <span class="hljs-attr">scope</span>=<span class="hljs-string">read</span><br></code></pre></td></tr></table></figure><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>a.com/callback<span class="hljs-comment">#token=ACCESS_TOKEN</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p><ol><li>点击链接，跳转至第三方</li><li>第三方直接把令牌给客户端</li></ol><p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h4><span id="33-密码模式风险极大适合于用户极其信任第三方">3.3 密码模式（风险极大，适合于用户极其信任第三方）</span></h4><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌</strong></p><ol><li>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。、</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//oauth.b.com/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">password&amp;</span><br>  <span class="hljs-attr">username</span>=<span class="hljs-string">USERNAME&amp;</span><br>  <span class="hljs-attr">password</span>=<span class="hljs-string">PASSWORD&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><ol start="2"><li>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</li></ol><h4><span id="34-凭证式模式适合没有前端的第三方">3.4 凭证式模式（适合没有前端的第三方）</span></h4><p><strong>命令行下请求令牌。</strong>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><ol><li>第一步，A 应用在命令行向 B 发出请求。</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//oauth.b.com/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">client_credentials&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET</span><br></code></pre></td></tr></table></figure><ul><li><p><code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式</p></li><li><p><code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p></li></ul><ol start="2"><li>第二步，B 网站验证通过以后，直接返回令牌。</li></ol><p>适合场景：向该平台所有用户发送消息提醒</p><h2><span id="四-令牌的使用">四、令牌的使用</span></h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">curl -H <span class="hljs-string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> <span class="hljs-string">\</span><br><span class="hljs-string">&quot;https://api.b.com&quot;</span><br></code></pre></td></tr></table></figure><p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p><h2><span id="五-更新令牌">五、更新令牌</span></h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">refresh_token&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET&amp;</span><br>  <span class="hljs-attr">refresh_token</span>=<span class="hljs-string">REFRESH_TOKEN</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p>]]></content>
    
    
    <categories>
      
      <category>oauth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper典型使用场景</title>
    <link href="/2021/09/25/zookeeper%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2021/09/25/zookeeper%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>课程概要：</strong></p><ol><li><strong>分布式集群管理</strong></li><li><strong>分布式注册中心</strong></li><li><strong>分布式JOB</strong></li><li><strong>分布式锁</strong></li></ol><h2><span id="一-分布式集群管理">一、 分布式集群管理</span></h2><hr><h3><span id="分布式集群管理的需求"><strong>分布式集群管理的需求：</strong></span></h3><ol><li>主动查看线上服务节点</li><li>查看服务节点资源使用情况</li><li>服务离线通知</li><li>服务资源（CPU、内存、硬盘）超出阀值通知</li></ol><h3><span id="架构设计"><strong>架构设计：</strong></span></h3><p><img src="https://uploader.shimo.im/f/5cdojbpemNQGhLaK.png!thumbnail" alt="图片"><br><strong>节点结构：</strong></p><ol><li>tuling-manger // 根节点</li><li>server00001 :<json> //服务节点 1</json></li><li>server00002 :<json>//服务节点 2</json></li><li>server……..n :<json>//服务节点 n</json></li></ol><p>服务状态信息:</p><pre><code>1. ip2. cpu3. memory4. disk</code></pre><h3><span id="功能实现"><strong>功能实现：</strong></span></h3><p><strong>数据生成与上报：</strong></p><ol><li>创建临时节点：</li><li>定时变更节点状态信息：</li></ol><p><strong>主动查询：</strong><br>1、实时查询 zookeeper 获取集群节点的状态信息。<br><strong>被动通知：</strong></p><ol><li>监听根节点下子节点的变化情况,如果CPU 等硬件资源低于警告位则发出警报。</li></ol><p><strong>关键示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tuling;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> com.tuling.os.CPUMonitorCalc;<br><span class="hljs-keyword">import</span> com.tuling.os.OsBean;<br><span class="hljs-keyword">import</span> org.I0Itec.zkclient.IZkChildListener;<br><span class="hljs-keyword">import</span> org.I0Itec.zkclient.ZkClient;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.instrument.Instrumentation;<br><span class="hljs-keyword">import</span> java.lang.management.ManagementFactory;<br><span class="hljs-keyword">import</span> java.lang.management.MemoryUsage;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Tommy</span><br><span class="hljs-comment"> * Created by Tommy on 2019/9/22</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String server = <span class="hljs-string">&quot;192.168.0.149:2181&quot;</span>;<br>    ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Agent instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String rootPath = <span class="hljs-string">&quot;/tuling-manger&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String servicePath = rootPath + <span class="hljs-string">&quot;/service&quot;</span>;<br>    <span class="hljs-keyword">private</span> String nodePath;<br>    <span class="hljs-keyword">private</span> Thread stateThread;<br>    List&lt;OsBean&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">premain</span><span class="hljs-params">(String args, Instrumentation instrumentation)</span> </span>&#123;<br>        instance = <span class="hljs-keyword">new</span> Agent();<br>        <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<br>            instance.server = args;<br>        &#125;<br>        instance.init();<br><br>    &#125;<br><br>    <span class="hljs-comment">// 初始化连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(server, <span class="hljs-number">5000</span>, <span class="hljs-number">10000</span>);<br>        System.out.println(<span class="hljs-string">&quot;zk连接成功&quot;</span> + server);<br>        buildRoot();<br>        createServerNode();<br>        stateThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                updateServerNode();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;zk_stateThread&quot;</span>);<br>        stateThread.setDaemon(<span class="hljs-keyword">true</span>);<br>        stateThread.start();<br><br>    &#125;<br><br>    <span class="hljs-comment">// 构建根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRoot</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(rootPath)) &#123;<br>            zkClient.createPersistent(rootPath);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 生成服务节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createServerNode</span><span class="hljs-params">()</span> </span>&#123;<br>        nodePath = zkClient.createEphemeralSequential(servicePath, getOsInfo());<br>        System.out.println(<span class="hljs-string">&quot;创建节点:&quot;</span> + nodePath);<br>    &#125;<br><br>    <span class="hljs-comment">// 监听服务节点状态改变</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateServerNode</span><span class="hljs-params">()</span> </span>&#123;<br>        zkClient.writeData(nodePath, getOsInfo());<br>    &#125;<br><br>    <span class="hljs-comment">// 更新服务节点状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOsInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        OsBean bean = <span class="hljs-keyword">new</span> OsBean();<br>        bean.lastUpdateTime = System.currentTimeMillis();<br>        bean.ip = getLocalIp();<br>        bean.cpu = CPUMonitorCalc.getInstance().getProcessCpu();<br>        MemoryUsage memoryUsag = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();<br>        bean.usableMemorySize = memoryUsag.getUsed() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        bean.usableMemorySize = memoryUsag.getMax() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> mapper.writeValueAsString(bean);<br>        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateNode</span><span class="hljs-params">(String path, Object data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (zkClient.exists(path)) &#123;<br>            zkClient.writeData(path, data);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            zkClient.createEphemeral(path, data);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getLocalIp</span><span class="hljs-params">()</span> </span>&#123;<br>        InetAddress addr = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            addr = InetAddress.getLocalHost();<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> addr.getHostAddress();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现效果图：<br><img src="https://uploader.shimo.im/f/X3VSNpo2iAorQA4n.png!thumbnail" alt="图片"></p><h2><span id="二-分布式注册中心">二 、分布式注册中心</span></h2><hr><p>在单体式服务中，通常是由多个客户端去调用一个服务，只要在客户端中配置唯一服务节点地址即可，当升级到分布式后，服务节点变多，像阿里一线大厂服务节点更是上万之多，这么多节点不可能手动配置在客户端，这里就需要一个中间服务，专门用于帮助客户端发现服务节点，即许多技术书籍经常提到的<strong>服务发现</strong>。<br>  <img src="https://uploader.shimo.im/f/l1l3j9Jxt4AsAxTT.png!thumbnail" alt="图片"></p><p>一个完整的注册中心涵盖以下功能特性：</p><ul><li><strong>服务注册：</strong>提供者上线时将自提供的服务提交给注册中心。</li><li><strong>服务注销：</strong>通知注册心提供者下线。</li><li><strong>服务订阅</strong>：动态实时接收服务变更消息。</li><li><strong>可靠</strong>：注册服务本身是集群的，数据冗余存储。避免单点故障，及数据丢失。</li><li><strong>容错</strong>：当服务提供者出现宕机，断电等极情况时，注册中心能够动态感知并通知客户端服务提供者的状态。</li></ul><h3><span id="dubbo-对zookeeper的使用"><strong>Dubbo 对zookeeper的使用</strong></span></h3><p>阿里著名的开源项目Dubbo 是一个基于JAVA的RCP框架，其中必不可少的注册中心可基于多种第三方组件实现，但其官方推荐的还是Zookeeper做为注册中心服务。<br><img src="https://uploader.shimo.im/f/fn7EPT7reCAxHBkx.png!thumbnail" alt="图片"></p><h3><span id="dubbo-zookeeper注册中心存储结构"><strong>Dubbo Zookeeper注册中心存储结构：</strong></span></h3><p><img src="https://uploader.shimo.im/f/inAfwBuh1eEEw1Dj.png!thumbnail" alt="图片"></p><p><strong>节点说明：</strong></p><table><thead><tr><th align="left"><strong>类别</strong></th><th align="left"><strong>属性</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><strong>Root</strong></td><td align="left">持久节点</td><td align="left">根节点名称，默认是 “dubbo”</td></tr><tr><td align="left"><strong>Service</strong></td><td align="left">持久节点</td><td align="left">服务名称，完整的服务类名</td></tr><tr><td align="left"><strong>type</strong></td><td align="left">持久节点</td><td align="left">可选值：providers(提供者)、consumers（消费者）、configurators(动态配置)、routers</td></tr><tr><td align="left"><strong>URL</strong></td><td align="left">临时节点</td><td align="left">url名称 包含服务提供者的 IP 端口 及配置等信息。</td></tr></tbody></table><p><strong>流程说明：</strong></p><ol><li>服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址</li><li>服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址</li><li>监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。</li></ol><h3><span id="示例演示"><strong>示例演示：</strong></span></h3><p>服务端代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.tuling.zk.dubbo;<br><br>import com.alibaba.dubbo.config.ApplicationConfig;<br>import com.alibaba.dubbo.config.ProtocolConfig;<br>import com.alibaba.dubbo.config.RegistryConfig;<br>import com.alibaba.dubbo.config.ServiceConfig;<br><br>import java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author Tommy</span><br><span class="hljs-comment"> * Created by Tommy on 2019/10/8</span><br><span class="hljs-comment"> **/</span><br>public <span class="hljs-keyword">class</span> Server &#123;<br>    public void <span class="hljs-keyword">open</span><span class="hljs-constructor">Server(<span class="hljs-params">int</span> <span class="hljs-params">port</span>)</span> &#123;<br>        <span class="hljs-comment">// 构建应用</span><br>        ApplicationConfig config = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ApplicationConfig()</span>;<br>        config.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;simple-app&quot;</span>)</span>;<br><br>        <span class="hljs-comment">// 通信协议</span><br>        ProtocolConfig protocolConfig = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ProtocolConfig(<span class="hljs-string">&quot;dubbo&quot;</span>, <span class="hljs-params">port</span>)</span>;<br>        protocolConfig.set<span class="hljs-constructor">Threads(200)</span>;<br><br>        ServiceConfig&lt;UserService&gt; serviceConfig = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServiceConfig()</span>;<br>        serviceConfig.set<span class="hljs-constructor">Application(<span class="hljs-params">config</span>)</span>;<br>        serviceConfig.set<span class="hljs-constructor">Protocol(<span class="hljs-params">protocolConfig</span>)</span>;<br>        serviceConfig.set<span class="hljs-constructor">Registry(<span class="hljs-params">new</span> RegistryConfig(<span class="hljs-string">&quot;zookeeper://192.168.0.149:2181&quot;</span>)</span>);<br>        serviceConfig.set<span class="hljs-constructor">Interface(UserService.<span class="hljs-params">class</span>)</span>;<br>        UserServiceImpl <span class="hljs-built_in">ref</span> = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UserServiceImpl()</span>;<br>        serviceConfig.set<span class="hljs-constructor">Ref(<span class="hljs-params">ref</span>)</span>;<br>        <span class="hljs-comment">//开始提供服务  开张做生意</span><br>        serviceConfig.export<span class="hljs-literal">()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;服务已开启!端口:&quot;</span>+serviceConfig.get<span class="hljs-constructor">ExportedUrls()</span>.get(<span class="hljs-number">0</span>).get<span class="hljs-constructor">Port()</span>);<br>        <span class="hljs-built_in">ref</span>.set<span class="hljs-constructor">Port(<span class="hljs-params">serviceConfig</span>.<span class="hljs-params">getExportedUrls</span>()</span>.get(<span class="hljs-number">0</span>).get<span class="hljs-constructor">Port()</span>);<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Server()</span>.<span class="hljs-keyword">open</span><span class="hljs-constructor">Server(-1)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span><span class="hljs-keyword">in</span>.read<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.tuling.zk.dubbo;<br><br><span class="hljs-keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;<br><span class="hljs-keyword">import</span> com.alibaba.dubbo.config.ReferenceConfig;<br><span class="hljs-keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author Tommy</span><br><span class="hljs-comment"> * Created by Tommy on 2018/11/20</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;</span><br>    UserService service;<br><br>    <span class="hljs-comment">// URL 远程服务的调用地址</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">buildService</span><span class="hljs-params">(<span class="hljs-keyword">String</span> url)</span> </span>&#123;<br>        ApplicationConfig config = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ApplicationConfig</span>(<span class="hljs-string">&quot;young-app&quot;</span>);<br>        <span class="hljs-comment">// 构建一个引用对象</span><br>        ReferenceConfig&lt;UserService&gt; referenceConfig = <span class="hljs-keyword">new</span> ReferenceConfig&lt;&gt;();<br>        referenceConfig.<span class="hljs-built_in">setApplication</span>(config);<br>        referenceConfig.<span class="hljs-built_in">setInterface</span>(UserService.class);<br><span class="hljs-comment">//        referenceConfig.setUrl(url);</span><br>        referenceConfig.<span class="hljs-built_in">setRegistry</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegistryConfig</span>(<span class="hljs-string">&quot;zookeeper://192.168.0.149:2181&quot;</span>));<br>        referenceConfig.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">// 透明化</span><br>        <span class="hljs-keyword">this</span>.service = referenceConfig.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">return</span> service;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws IOException </span>&#123;<br>        <span class="hljs-built_in">Client</span> client1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-built_in">Client</span></span>();<br>        client1.<span class="hljs-built_in">buildService</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">String</span> cmd;<br>        <span class="hljs-keyword">while</span> (!(cmd = <span class="hljs-built_in">read</span>()).<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;exit&quot;</span>)) &#123;<br>            UserVo u = client1.service.<span class="hljs-built_in">getUser</span>(Integer.<span class="hljs-built_in">parseInt</span>(cmd));<br>            System.out.<span class="hljs-built_in">println</span>(u);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> throws IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> size = System.in.<span class="hljs-built_in">read</span>(b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(b, <span class="hljs-number">0</span>, size).<span class="hljs-built_in">trim</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询zk 实际存储内容：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sas">/dubbo<br>/dubbo/com.tuling.zk.dubbo.UserService<br>/dubbo/com.tuling.zk.dubbo.UserService/configurators<br>/dubbo/com.tuling.zk.dubbo.UserService/routers<br><br>/dubbo/com.tuling.zk.dubbo.UserService/providers<br>/dubbo/com.tuling.zk.dubbo.UserService/providers/dubbo://192.168.0.132:20880/com.tuling.zk.dubbo.UserService?anyhost=true<span class="hljs-variable">&amp;application</span>=simple-app<span class="hljs-variable">&amp;dubbo</span>=2.6.2<span class="hljs-variable">&amp;generic</span>=false<span class="hljs-variable">&amp;interface</span>=com.tuling.zk.dubbo.UserService<span class="hljs-variable">&amp;methods</span>=getUser<span class="hljs-variable">&amp;pid</span>=11128<span class="hljs-variable">&amp;side</span>=provider<span class="hljs-variable">&amp;threads</span>=200<span class="hljs-variable">&amp;timestamp</span>=1570518302772<br>/dubbo/com.tuling.zk.dubbo.UserService/providers/dubbo://192.168.0.132:20881/com.tuling.zk.dubbo.UserService?anyhost=true<span class="hljs-variable">&amp;application</span>=simple-app<span class="hljs-variable">&amp;dubbo</span>=2.6.2<span class="hljs-variable">&amp;generic</span>=false<span class="hljs-variable">&amp;interface</span>=com.tuling.zk.dubbo.UserService<span class="hljs-variable">&amp;methods</span>=getUser<span class="hljs-variable">&amp;pid</span>=12956<span class="hljs-variable">&amp;side</span>=provider<span class="hljs-variable">&amp;threads</span>=200<span class="hljs-variable">&amp;timestamp</span>=1570518532382<br>/dubbo/com.tuling.zk.dubbo.UserService/providers/dubbo://192.168.0.132:20882/com.tuling.zk.dubbo.UserService?anyhost=true<span class="hljs-variable">&amp;application</span>=simple-app<span class="hljs-variable">&amp;dubbo</span>=2.6.2<span class="hljs-variable">&amp;generic</span>=false<span class="hljs-variable">&amp;interface</span>=com.tuling.zk.dubbo.UserService<span class="hljs-variable">&amp;methods</span>=getUser<span class="hljs-variable">&amp;pid</span>=2116<span class="hljs-variable">&amp;side</span>=provider<span class="hljs-variable">&amp;threads</span>=200<span class="hljs-variable">&amp;timestamp</span>=1570518537021<br><br>/dubbo/com.tuling.zk.dubbo.UserService/consumers<br>/dubbo/com.tuling.zk.dubbo.UserService/consumers/consumer://192.168.0.132/com.tuling.zk.dubbo.UserService?application=young-app<span class="hljs-variable">&amp;category</span>=consumers<span class="hljs-variable">&amp;check</span>=false<span class="hljs-variable">&amp;dubbo</span>=2.6.2<span class="hljs-variable">&amp;interface</span>=com.tuling.zk.dubbo.UserService<span class="hljs-variable">&amp;methods</span>=getUser<span class="hljs-variable">&amp;pid</span>=9200<span class="hljs-variable">&amp;side</span>=consumer<span class="hljs-variable">&amp;timeout</span>=5000<span class="hljs-variable">&amp;timestamp</span>=1570518819628<br></code></pre></td></tr></table></figure><h2><span id></span></h2><h2><span id="三-分布式job">三、分布式JOB</span></h2><hr><h3><span id="分布式job需求">分布式JOB需求：</span></h3><ol><li>多个服务节点只允许其中一个主节点运行JOB任务。</li><li>当主节点挂掉后能自动切换主节点，继续执行JOB任务。</li></ol><h3><span id="架构设计">架构设计：</span></h3><p><img src="https://uploader.shimo.im/f/cGX66wOXVq0FAeqc.png!thumbnail" alt="图片"><br><strong>node结构：</strong></p><ol><li>tuling-master</li><li>server0001:master</li><li>server0002:slave</li><li>server000n:slave</li></ol><p><strong>选举流程：</strong><br>服务启动：</p><ol><li>在tuling-maste下创建server子节点，值为slave</li><li>获取所有tuling-master 下所有子节点</li><li>判断是否存在master 节点</li><li>如果没有设置自己为master节点</li></ol><p>子节点删除事件触发：</p><ol><li>获取所有tuling-master 下所有子节点</li><li>判断是否存在master 节点</li><li>如果没有设置最小值序号为master 节点</li></ol><h2><span id="四-分布式锁">四、分布式锁</span></h2><hr><h3><span id="锁的的基本概念"><strong>锁的的基本概念：</strong></span></h3><p>开发中锁的概念并不陌生，通过锁可以实现在多个线程或多个进程间在争抢资源时，能够合理的分配置资源的所有权。在单体应用中我们可以通过 synchronized 或ReentrantLock 来实现锁。但在分布式系统中，仅仅是加synchronized 是不够的，需要借助第三组件来实现。比如一些简单的做法是使用 关系型数据行级锁来实现不同进程之间的互斥，但大型分布式系统的性能瓶颈往往集中在数据库操作上。为了提高性能得采用如Redis、Zookeeper之内的组件实现分布式锁。</p><p><strong>共享锁：</strong>也称作只读锁，当一方获得共享锁之后，其它方也可以获得共享锁。但其只允许读取。在共享锁全部释放之前，其它方不能获得写锁。<br><strong>排它锁：</strong>也称作读写锁，获得排它锁后，可以进行数据的读写。在其释放之前，其它方不能获得任何锁。</p><h3><span id="锁的获取">锁的获取：</span></h3><p>某银行帐户，可以同时进行帐户信息的读取，但读取其间不能修改帐户数据。其帐户ID为:888</p><ul><li>获得读锁流程：</li></ul><p><img src="https://uploader.shimo.im/f/BFpx2XQYWf8ruFUt.png!thumbnail" alt="图片"><br>1、基于资源ID创建临时序号读锁节点<br>   /lock/888.R0000000002 Read<br>2、获取 /lock 下所有子节点，判断其最小的节点是否为读锁，如果是则获锁成功<br>3、最小节点不是读锁，则阻塞等待。添加lock/ 子节点变更监听。<br>4、当节点变更监听触发，执行第2步</p><p><strong>数据结构：</strong><br><img src="https://uploader.shimo.im/f/hgOxo7b5SPIdcXS1.png!thumbnail" alt="图片"></p><ul><li>获得写锁s</li></ul><p>1、基于资源ID创建临时序号写锁节点<br>   /lock/888.R0000000002 Write<br>2、获取 /lock 下所有子节点，判断其最小的节点是否为自己，如果是则获锁成功<br>3、最小节点不是自己，则阻塞等待。添加lock/ 子节点变更监听。<br>4、当节点变更监听触发，执行第2步</p><ul><li>释放锁：</li></ul><p>读取完毕后，手动删除临时节点，如果获锁期间宕机，则会在会话失效后自动删除。</p><h3><span id="关于羊群效应"><strong>关于羊群效应：</strong></span></h3><p>在等待锁获得期间，所有等待节点都在监听 Lock节点，一但lock 节点变更所有等待节点都会被触发，然后在同时反查Lock 子节点。如果等待对例过大会使用Zookeeper承受非常大的流量压力。</p><p>  <img src="https://uploader.shimo.im/f/VsMAGsJSxhAOKnia.png!thumbnail" alt="图片"></p><p>为了改善这种情况，可以采用监听链表的方式，每个等待对列只监听前一个节点，如果前一个节点释放锁的时候，才会被触发通知。这样就形成了一个监听链表。<br> <img src="https://uploader.shimo.im/f/JgVYw2L6xJcny6CN.png!thumbnail" alt="图片"></p><h3><span id="示例演示"><strong>示例演示：</strong></span></h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.tuling.zookeeper.lock;<br><br>import org.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">I0Itec</span>.</span></span>zkclient.IZkDataListener;<br>import org.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">I0Itec</span>.</span></span>zkclient.ZkClient;<br><br>import java.util.List;<br>import java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author Tommy</span><br><span class="hljs-comment"> * Created by Tommy on 2019/9/23</span><br><span class="hljs-comment"> **/</span><br>public <span class="hljs-keyword">class</span> ZookeeperLock &#123;<br>    <span class="hljs-keyword">private</span> String server = <span class="hljs-string">&quot;192.168.0.149:2181&quot;</span>;<br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> static final String rootPath = <span class="hljs-string">&quot;/tuling-lock&quot;</span>;<br><br>    public <span class="hljs-constructor">ZookeeperLock()</span> &#123;<br>        zkClient = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ZkClient(<span class="hljs-params">server</span>, 5000, 20000)</span>;<br>        build<span class="hljs-constructor">Root()</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 构建根节点</span><br>    public void build<span class="hljs-constructor">Root()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(rootPath)) &#123;<br>            zkClient.create<span class="hljs-constructor">Persistent(<span class="hljs-params">rootPath</span>)</span>;<br>        &#125;<br>    &#125;<br><br>    public Lock lock(String lockId, long timeout) &#123;<br>        Lock lockNode = create<span class="hljs-constructor">LockNode(<span class="hljs-params">lockId</span>)</span>;<br>        lockNode = <span class="hljs-keyword">try</span><span class="hljs-constructor">ActiveLock(<span class="hljs-params">lockNode</span>)</span>;<span class="hljs-comment">// 尝试激活锁</span><br>        <span class="hljs-keyword">if</span> (!lockNode.is<span class="hljs-constructor">Active()</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                synchronized (lockNode) &#123;<br>                    lockNode.wait(timeout);<br>                &#125;<br>            &#125; catch (InterruptedException e) &#123;<br>                throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!lockNode.is<span class="hljs-constructor">Active()</span>) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-string">&quot; lock  timeout&quot;</span>)</span>;<br>        &#125;<br>        return lockNode;<br>    &#125;<br><br>    public void unlock(Lock lock) &#123;<br>        <span class="hljs-keyword">if</span> (lock.is<span class="hljs-constructor">Active()</span>) &#123;<br>            zkClient.delete(lock.get<span class="hljs-constructor">Path()</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试激活锁</span><br>    <span class="hljs-keyword">private</span> Lock <span class="hljs-keyword">try</span><span class="hljs-constructor">ActiveLock(Lock <span class="hljs-params">lockNode</span>)</span> &#123;<br>        <span class="hljs-comment">// 判断当前是否为最小节点</span><br>        List&lt;String&gt; <span class="hljs-built_in">list</span> = zkClient.get<span class="hljs-constructor">Children(<span class="hljs-params">rootPath</span>)</span><br>                .stream<span class="hljs-literal">()</span><br>                .sorted<span class="hljs-literal">()</span><br>                .map(p -&gt; rootPath + <span class="hljs-string">&quot;/&quot;</span> + p)<br>                .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<br>        String firstNodePath = <span class="hljs-built_in">list</span>.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (firstNodePath.equals(lockNode.get<span class="hljs-constructor">Path()</span>)) &#123;<br>            lockNode.set<span class="hljs-constructor">Active(<span class="hljs-params">true</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String upNodePath = <span class="hljs-built_in">list</span>.get(<span class="hljs-built_in">list</span>.index<span class="hljs-constructor">Of(<span class="hljs-params">lockNode</span>.<span class="hljs-params">getPath</span>()</span>) - <span class="hljs-number">1</span>);<br>            zkClient.subscribe<span class="hljs-constructor">DataChanges(<span class="hljs-params">upNodePath</span>, <span class="hljs-params">new</span> IZkDataListener()</span> &#123;<br>                @Override<br>                public void handle<span class="hljs-constructor">DataChange(String <span class="hljs-params">dataPath</span>, Object <span class="hljs-params">data</span>)</span> throws Exception &#123;<br><br>                &#125;<br><br>                @Override<br>                public void handle<span class="hljs-constructor">DataDeleted(String <span class="hljs-params">dataPath</span>)</span> throws Exception &#123;<br>                    <span class="hljs-comment">// 事件处理 与心跳 在同一个线程，如果Debug时占用太多时间，将导致本节点被删除，从而影响锁逻辑。</span><br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;节点删除:&quot;</span> + dataPath);<br>                     Lock lock = <span class="hljs-keyword">try</span><span class="hljs-constructor">ActiveLock(<span class="hljs-params">lockNode</span>)</span>;<br>                    synchronized (lockNode) &#123;<br>                        <span class="hljs-keyword">if</span> (lock.is<span class="hljs-constructor">Active()</span>) &#123;<br>                            lockNode.notify<span class="hljs-literal">()</span>;<br>                        &#125;<br>                    &#125;<br>                    zkClient.unsubscribe<span class="hljs-constructor">DataChanges(<span class="hljs-params">upNodePath</span>, <span class="hljs-params">this</span>)</span>;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        return lockNode;<br>    &#125;<br><br><br>    public Lock create<span class="hljs-constructor">LockNode(String <span class="hljs-params">lockId</span>)</span> &#123;<br>        String nodePath = zkClient.create<span class="hljs-constructor">EphemeralSequential(<span class="hljs-params">rootPath</span> + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-params">lockId</span>, <span class="hljs-string">&quot;lock&quot;</span>)</span>;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Lock(<span class="hljs-params">lockId</span>, <span class="hljs-params">nodePath</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper集群特性</title>
    <link href="/2021/09/24/zookeeper%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7/"/>
    <url>/2021/09/24/zookeeper%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2><span id="zookeeper集群">Zookeeper集群</span></h2><hr><h2><span id="目的">目的</span></h2><p>zookeeper集群是为了保证系统的性能，能够承载更多的客户端连接。通过集群可以实现以下功能：</p><ul><li>读写分离：提高承载，为更多的客户端提供连接，并保障性能。</li><li>主从自动切换：提高服务容错性，部分节点故障不会影响整个服务集群。</li></ul><h2><span id="半数以上运行机制说明">半数以上运行机制说明</span></h2><p>集群至少需要三台服务器，并且强烈建议使用奇数个服务器。</p><p>因为zookeeper 通过判断大多数节点的存活来判断整个服务是否可用。比如3个节点，挂掉了2个表示整个集群挂掉，而用偶数4个，挂掉了2个也表示其并不是大部分存活，因此也会挂掉。</p><h2><span id="集群部署">集群部署</span></h2><h3><span id="配置语法">配置语法：</span></h3><p><code>server.&lt;节点ID&gt;=&lt;ip&gt;:&lt;数据同步端口&gt;:&lt;选举端口&gt;</code></p><ul><li>节点ID：服务id手动指定1至125之间的数字，并写到对应服务节点的 {dataDir}/myid 文件中。</li><li>IP地址：节点的远程IP地址，可以相同。但生产环境就不能这么做了，因为在同一台机器就无法达到容错的目的。所以这种称作为伪集群。</li><li>数据同步端口：主从同时数据复制端口，（做伪集群时端口号不能重复）。</li><li>远举端口：主从节点选举端口，（做伪集群时端口号不能重复）。</li></ul><p><strong>配置文件示例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attribute">dataDir</span>=/var/lib/zookeeper/<br><span class="hljs-attribute">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-attribute">initLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attribute">syncLimit</span>=<span class="hljs-number">2</span><br><span class="hljs-comment">#以下为集群配置，必须配置在所有节点的zoo.cfg文件中</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">1</span>=zoo<span class="hljs-number">1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">2</span>=zoo<span class="hljs-number">2</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">3</span>=zoo<span class="hljs-number">3</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br></code></pre></td></tr></table></figure><h3><span id="集群配置流程">集群配置流程：</span></h3><ol><li>分别创建3个data目录用于存储各节点数据</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span></span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/1</span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/3</span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/3</span><br></code></pre></td></tr></table></figure><ol start="2"><li>编写myid文件</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> <span class="hljs-number">1</span> &gt; data/<span class="hljs-number">1</span>/myid<br><span class="hljs-attribute">echo</span> <span class="hljs-number">3</span> &gt; data/<span class="hljs-number">3</span>/myid<br><span class="hljs-attribute">echo</span> <span class="hljs-number">2</span> &gt; data/<span class="hljs-number">2</span>/myid<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ls -R data<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><br>data/<span class="hljs-number">1</span>:<br>myid<br><br>data/<span class="hljs-number">2</span>:<br>myid<br><br>data/<span class="hljs-number">3</span>:<br>myid<br></code></pre></td></tr></table></figure><p>3、编写配置文件</p><ul><li><code>vim conf/zoo1.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">1</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><ul><li><code>vim conf/zoo2.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">2</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2182</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><ul><li><code>vim conf/zoo3.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">3</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2183</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><p>4.分别启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo1.cfg<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo2.cfg<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo3.cfg<br></code></pre></td></tr></table></figure><p>5.分别查看状态</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo1.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo2.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo3.cfg<br>Mode: leader<br></code></pre></td></tr></table></figure><ol start="6"><li>进入客户端，在server1中创建节点，server 3查看节点是否同步</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">.<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>zkCli.sh <span class="hljs-operator">-</span>server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span><br><br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">0</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">1</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>tt<br>Created <span class="hljs-operator">/</span>tt0000000001<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">2</span>] ls <span class="hljs-operator">/</span><br>[tt0000000001, zookeeper]<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">.<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>zkCli.sh <span class="hljs-operator">-</span>server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2183</span><br><br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2183</span>(CONNECTED) <span class="hljs-number">1</span>] ls <span class="hljs-operator">/</span><br>[tt0000000001, zookeeper]<br></code></pre></td></tr></table></figure><h2><span id="集群角色说明">集群角色说明</span></h2><p>zookeeper 集群中总共有三种角色，分别是leader（主节点）follower(子节点) observer（次级子节点）</p><table><thead><tr><th align="left">角色</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>leader</strong></td><td align="left">主节点，又名领导者。用于写入数据，通过选举产生，如果宕机将会选举新的主节点。</td></tr><tr><td align="left"><strong>follower</strong></td><td align="left">子节点，又名追随者。用于实现数据的读取。同时他也是主节点的备选节点，并用拥有投票权。</td></tr><tr><td align="left"><strong>observer</strong></td><td align="left">次级子节点，又名观察者。用于读取数据，与fllower区别在于没有投票权，不能选为主节点。并且在计算集群可用状态时不会将observer计算入内。</td></tr></tbody></table><p><strong>observer配置：</strong><br>只要在集群配置中加上observer后缀即可，示例如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">server</span>.<span class="hljs-number">3</span>=<span class="hljs-number">127.0.0.1:2889</span>:<span class="hljs-number">3889</span>:observer<br></code></pre></td></tr></table></figure><h2><span id="选举机制">选举机制</span></h2><p>通过 ./bin/zkServer.sh status &lt;zoo配置文件&gt; 命令可以查看到节点状态，可以发现中间的2182 是leader状态</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo1.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo2.cfg<br>Mode: leader<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo3.cfg<br>Mode: follower<br></code></pre></td></tr></table></figure><h3><span id="投票机制说明">投票机制说明</span></h3><ol><li><p>第一轮投票全部投给自己</p></li><li><p>第二轮投票给myid比自己大的相邻节点，</p></li><li><p>如果得票超过半数，选举结束。</p></li></ol><p>其选举机制如下图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gywytfrbw1j31bi0u0gpa.jpg"></p><h3><span id="选举触发"><strong>选举触发：</strong></span></h3><p>当集群中的服务器出现已下两种情况时会进行Leader的选举</p><ol><li>服务节点初始化启动。当节点初始起动时会在集群中寻找Leader节点，如果找到则与Leader建立连接，其自身状态变化<strong>follower</strong>或<strong>observer。</strong>如果没有找到Leader，当前节点状态将变化LOOKING，进入选举流程。</li><li>半数以上的节点无法和Leader建立连接。在集群运行其间如果有follower或observer节点宕机只要不超过半数并不会影响整个集群服务的正常运行。但如果leader宕机，将暂停对外服务，所有follower将进入LOOKING 状态，进入选举流程。</li></ol><h2><span id="数据同步机制">数据同步机制</span></h2><p>zookeeper 的数据同步是为了保证各节点中数据的一至性，同步时涉及两个流程，一个是正常的客户端数据提交，另一个是集群某个节点宕机在恢复后的数据同步。</p><h3><span id="客户端写入请求">客户端写入请求</span></h3><p>写入请求的大至流程是，收leader接收客户端写请求，并同步给各个子节点。如下图：</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gywz51yujxj30xi0r2taw.jpg" style="zoom:50%;"><p>但实际情况要复杂的多，比如client 它并不知道哪个节点是leader 有可能写的请求会发给follower ，由follower在转发给leader进行同步处理</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gywz6vog9pj316g0u00wf.jpg" style="zoom: 50%;"><p>客户端写入流程说明：</p><ol><li>client向zk中的server发送写请求，如果该server不是leader，则会将该写请求转发给leader server，leader将请求事务以proposal（建议）形式分发给follower；</li><li>当follower收到收到leader的proposal时，根据接收的先后顺序处理proposal；</li><li>当Leader收到follower针对某个proposal过半的ack后，（即follower过半都已经同步完成）则发起事务提交，重新发起一个commit的proposal</li><li>Follower收到commit的proposal后，记录事务提交，并把数据更新到内存数据库；</li><li>当写成功后，反馈给client。</li></ol><h3><span id="服务节点初始化同步">服务节点初始化同步</span></h3><ul><li><p>在集群运行过程当中如果有一个follower节点宕机，由于宕机节点没过半，集群仍然能正常服务。</p></li><li><p>当leader 收到新的客户端请求，此时无法同步给宕机的节点。造成数据不一致。为了解决这个问题，当节点启动时，第一件事情就是找当前的Leader，比对数据是否一致。不一致则开始同步,同步完成之后在进行对外提供服务。故在节点同步数据期间，该节点不会对外提供服务。</p></li><li><p>Leader挂了后，选举leader的过程中，集群不可以对外提供服务。</p></li></ul><h3><span id="5四字运维命令">5.四字运维命令</span></h3><p>ZooKeeper响应少量命令。每个命令由四个字母组成。可通过telnet或nc向ZooKeeper发出命令。<br>这些命令默认是关闭的，需要配置4lw.commands.whitelist来打开，可打开部分或全部示例如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#打开指定命令</span><br>4lw.commands.<span class="hljs-attribute">whitelist</span>=stat, ruok, conf, isro<br><span class="hljs-comment">#打开全部</span><br>4lw.commands.<span class="hljs-attribute">whitelist</span>=*<br><span class="hljs-comment">#查看服务器及客户端连接状态</span><br>echo stat | nc localhost 2181<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo stat | nc localhost <span class="hljs-number">2181</span><br>stat is not executed because it is not in the whitelist.<br><br>## 打开全部nc命令<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo1.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo2.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo3.cfg<br><br>## 重启服务<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo1.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo2.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo3.cfg<br></code></pre></td></tr></table></figure><h3><span id="zxid说明">ZXID说明</span></h3><blockquote><p>如何比对Leader的数据版本呢，这里通过ZXID事物ID来确认。比Leader小就需要同步。</p></blockquote><ul><li><p>ZXID是一个长度64位的数字，其中低32位是按照数字递增，任何数据的变更都会导致低32位的数字加1。</p></li><li><p>高32位是leader周期编号，每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的。 </p></li></ul><p>eg1: 节点数据的变更</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyx6ctcstxj31460siaea.jpg"></p><p>Eg2: 某个节点挂掉重新选举</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyx6bhhfxpj30we0qmgpn.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyx66k725nj31620tytd3.jpg"></p><p><strong>思考题：</strong><br>如果leader 节点宕机，在恢复后它还能被选为leader吗？</p><p>不会，因为它的数据不是最新的。</p>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper客户端使用</title>
    <link href="/2021/09/23/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/09/23/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2><span id="客户端api常规应用">客户端API常规应用</span></h2><hr><p>zookeeper 提供了java与C两种语言的客户端。我们要学习的就是java客户端。引入最新的maven依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;<br>  &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">3.6</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2><span id="初始连接">初始连接</span></h2><p>常规的客户端类是 org.apache.zookeeper.ZooKeeper，实例化该类之后将会自动与集群建立连接。</p><ul><li>connectString    连接串，包括ip+端口 ,集群模式下用逗号隔开</li><li>sessionTimeout  会话超时时间，该值不能超过服务端所设置的 minSessionTimeout 和maxSessionTimeout</li><li>watcher 会话监听器，服务端事件将会触该监听</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(<span class="hljs-string">&quot;192.168.2.103:2181&quot;</span>, <span class="hljs-number">4000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;init:&quot;</span>+watchedEvent.getPath());<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2><span id="创建-查看节点">创建、查看节点</span></h2><h3><span id="创建节点">创建节点</span></h3><p>通过org.apache.zookeeper.ZooKeeper#create()即可创建节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  List&lt;ACL&gt; aclList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">int</span> perm = ZooDefs.Perms.ADMIN | ZooDefs.Perms.READ;<br>  <br>  <span class="hljs-comment">// perms 对应权限位permission</span><br>  <span class="hljs-comment">// id 对应权限模式scheme + id</span><br>  ACL acl1 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;anyone&quot;</span>));<br>  ACL acl2 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;ip&quot;</span>,<span class="hljs-string">&quot;192.168.2.103&quot;</span>));<br>  ACL acl3 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;ip&quot;</span>,<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br><br>  aclList.add(acl1);<br>  aclList.add(acl2);<br>  aclList.add(acl3);<br>  zooKeeper.create(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-string">&quot;hello word!&quot;</span>.getBytes(), aclList, CreateMode.PERSISTENT);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行完成后，在zookeeper进行查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">64</span>] getAcl /hello<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: ra<br><span class="hljs-string">&#x27;ip,&#x27;</span><span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.103</span><br>: ra<br><span class="hljs-string">&#x27;ip,&#x27;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>: ra<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">65</span>] get /hello<br>hello word<br></code></pre></td></tr></table></figure><h3><span id="查看节点">查看节点</span></h3><h4><span id="查看当前节点">查看当前节点</span></h4><p>通过org.apache.zookeeper.ZooKeeper#getData()即可查看节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>  System.out.println(<span class="hljs-string">&quot;testData:&quot;</span> + <span class="hljs-keyword">new</span> String(keeperData));<br>&#125;<br></code></pre></td></tr></table></figure><h4><span id="查看子节点">查看子节点</span></h4><p>通过org.apache.zookeeper.ZooKeeper#getChildren()即可获取子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetChildrenWithoutWatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> List&lt;String&gt; children = zooKeeper.getChildren(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">false</span>);<br>  children.stream().forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h2><span id="监听节点">监听节点</span></h2><ul><li><p>在getData() 与getChildren()两个方法中可分别设置监听数据变化和子节点变化。</p></li><li><p>通过设置watch为true，当前事件触发时会调用zookeeper()构建函数中Watcher.process()方法。也可以添加watcher参数来实现自定义监听。一般采用后者。</p></li><li><p>所有的监听都是一次性的，如果要持续监听需要触发后在添加一次监听。</p></li></ul><p><strong>使用默认监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDataWithWatcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>);<br>  System.out.println(<span class="hljs-string">&quot;testGetDataWithWatcher:&quot;</span> + <span class="hljs-keyword">new</span> String(keeperData));<br>  Thread.sleep(Long.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDataWithCustomWatcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        zooKeeper.getData(<span class="hljs-string">&quot;/temp&quot;</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (KeeperException | InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;testGetDataWithCustomWatcher:&quot;</span> + watchedEvent.getPath());<br><br>    &#125;<br>  &#125;, <span class="hljs-keyword">null</span>);<br>  Thread.sleep(Long.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h2><span id="第三方客户端zkclient">第三方客户端ZkClient</span></h2><p>zkClient 是在zookeeper客户端基础之上封装的，使用上更加友好。主要变化如下：</p><ul><li>可以设置持久监听，或删除某个监听</li><li>可以插入JAVA对象，自动进行序列化和反序列化</li><li>简化了基本的增删改查操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper特性与节点介绍</title>
    <link href="/2021/09/22/zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/09/22/zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1><span id="zookeeper">zookeeper</span></h1><h2><span id="产生背景">产生背景</span></h2><ol><li><p>单体向分布式服务转变，会产生多个节点间协同问题，如：</p><blockquote><ul><li><p>假设有3个节点，1个job，该job该由哪个节点执行？</p></li><li><p>若该job由节点1执行，要是1挂了，现在该2还是3执行？</p></li></ul></blockquote></li><li><p>上游和下游服务的发现，如：</p><blockquote><ul><li>上游挂了，下游怎么知道？</li><li>下游服务新增，上游怎么知道？</li></ul></blockquote></li><li><p>多节点的协调问题，如：并发产生了请求，该怎么保证请求的幂等性？</p></li></ol><blockquote><p><strong>由于节点自身协调不可靠，性能不高，故需要一个独立服务来做协调，他必须可靠且保证性能。</strong></p></blockquote><h2><span id="概要">概要</span></h2><ol><li>zookeeper是用于分布式服务的协调服务。</li><li>它对外公布了一组简单的API，分布式应用程序可以基于这些API，用于同步节点状态，节点配置，服务注册等信息</li><li>它支持java和c两种语言。</li></ol><h2><span id="工作机制">工作机制</span></h2><p>从设计模式的角度理解，zookeeper基于观察者模式。他负责存储和管路大家都关心的数据，然后接受观察，一旦数据状态发生变化，zookeeper就通知注册者。</p><h2><span id="特点">特点</span></h2><ol><li>zookeeper是由一个leader和多个follower组成的集群</li><li>半数以上节点存活，zookeeper 即可以正常服务</li><li>每个server的数据一致</li><li>来自同一个client的请求依次执行</li><li>原子性，数据更新要么成功，要么失败</li><li>zookeeper数据量少，故同步快，一定时间内，client可以读到最新数据</li></ol><h2><span id="zookeeper-启动">zookeeper 启动</span></h2><ul><li>官网下载最新版本 <a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz">Apache Downloads</a>，并解压</li><li>进入conf目录，拷贝默认配置  <code>cp zoo_sample.cfg   zoo.cfg</code></li><li>进入bin目录，启动服务端<code>./zkServer.sh start</code></li><li>进入bin目录，进入客户端<code>./zkCli.sh</code></li></ul><h2><span id="常规配置文件说明">常规配置文件说明</span></h2><blockquote><p>tickTime=2000   #zookeeper时间配置中的基本单位 (毫秒) </p></blockquote><blockquote><p>initLimit=10     #允许follower初始化连接到leader最大时长，它表示tickTime时间倍数 即:initLimit*tickTime</p></blockquote><blockquote><p>syncLimit=5     #允许follower与leader数据同步最大时长,它表示tickTime时间倍数</p></blockquote><blockquote><p>dataDir=/tmp/zookeeper  #zookeper 数据存储目录</p></blockquote><blockquote><p>clientPort=2181  #对客户端提供的端口号</p></blockquote><blockquote><p>maxClientCnxns=60  #单个客户端与zookeeper最大并发连接数</p></blockquote><blockquote><p>autopurge.snapRetainCount=3. #保存的数据快照数量，之外的将会被清除</p></blockquote><blockquote><p>autopurge.purgeInterval=1  #自动触发清除任务时间间隔，小时为单位。默认为0，表示不自动清除。</p></blockquote><h2><span id="客户端命令">客户端命令</span></h2><ul><li><p>close     关闭当前会话</p></li><li><p>connect host:port        重新连接指定Zookeeper服务</p></li><li><p>create [-s] [-e] [-c] [-t ttl] path [data] [acl]          创建节点</p></li><li><p>delete [-v version] path             删除节点，(不能存在子节点） </p></li><li><p>deleteall path [-b batch size]      删除路径及所有子节点</p></li><li><p>get [-s] [-w] path.        查看节点数据 -s 包含节点状态 -w 添加监听 </p></li><li><p>getAcl [-s] path.      列出子节点 -s状态 -R 递归查看所有子节点 -w 添加监听</p></li><li><p>history     查看执行的历史记录</p></li><li><p>redo cmdno  重复 执行命令，history 中命令编号确定</p></li><li><p>quit  退出客户端</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">1</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">2</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<br>Created <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">3</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-keyword">null</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">4</span>] <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>node1 &quot;node1 value&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">5</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br>node1 <span class="hljs-keyword">value</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">6</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>Created <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">7</span>] <span class="hljs-keyword">set</span>  <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">8</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-string">&#x27;get path [watch]&#x27;</span> has been deprecated. Please use <span class="hljs-string">&#x27;get [-s] [-w] path&#x27;</span> instead.<br>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">10</span>] <span class="hljs-keyword">delete</span> <span class="hljs-operator">/</span>node1<br>Node <span class="hljs-keyword">not</span> <span class="hljs-keyword">empty</span>: <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">11</span>] deleteall <span class="hljs-operator">/</span>node1<br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeDeleted path:<span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">12</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] history<br><span class="hljs-number">3</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">4</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>node1 &quot;node1 value&quot;<br><span class="hljs-number">5</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">6</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br><span class="hljs-number">7</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">set</span>  <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-number">8</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-number">9</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br><span class="hljs-number">10</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">delete</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">11</span> <span class="hljs-operator">-</span> deleteall <span class="hljs-operator">/</span>node1<br><span class="hljs-number">12</span> <span class="hljs-operator">-</span> ls <span class="hljs-operator">/</span><br><span class="hljs-number">13</span> <span class="hljs-operator">-</span> history<br><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">16</span>] redo <span class="hljs-number">2</span><br>Created <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">17</span>] ls <span class="hljs-operator">/</span><br>[node1, zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">18</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>node1<br><span class="hljs-keyword">null</span><br>cZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>ctime <span class="hljs-operator">=</span> Thu Jan <span class="hljs-number">13</span> <span class="hljs-number">22</span>:<span class="hljs-number">49</span>:<span class="hljs-number">37</span> CST <span class="hljs-number">2022</span><br>mZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>mtime <span class="hljs-operator">=</span> Thu Jan <span class="hljs-number">13</span> <span class="hljs-number">22</span>:<span class="hljs-number">49</span>:<span class="hljs-number">37</span> CST <span class="hljs-number">2022</span><br>pZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>cversion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>dataVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>aclVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>ephemeralOwner <span class="hljs-operator">=</span> <span class="hljs-number">0x0</span><br>dataLength <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>numChildren <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2><span id="节点介绍">节点介绍</span></h2><h3><span id="数据基本单元">数据基本单元</span></h3><ul><li>zookeepe中的基本数据单元是——节点（znode）。节点之下可以包含子节点，最后以树级方式呈现。</li></ul><ul><li>每个节点拥有唯一的路径path.</li><li>客户端基于path上传节点数据，zookeepe收到数据后，会通知监听该节点的客户端（一个或多个）。</li><li>之前，各个节点的数据是相互孤立的（也可以自己同步，但是没有zookeeper性能高，可靠）。现在，有了zookeeper,各节点的数据可以通过zookeeper可以得到一个高性能高可靠的同步。</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycegg0aihj30u00v0wgk.jpg" style="zoom:50%;"><h3><span id="节点的结构">节点的结构</span></h3><ul><li><strong>path</strong>:唯一路径 </li><li><strong>childNode</strong>：子节点</li><li><strong>stat</strong>:状态属性:即path对应的值</li><li><strong>type</strong>:节点类型</li></ul><h3><span id="节点类型">节点类型</span></h3><table><thead><tr><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">PERSISTENT</td><td align="left">持久节点</td></tr><tr><td align="left">PERSISTENT_SEQUENTIAL</td><td align="left">持久序号节点</td></tr><tr><td align="left">EPHEMERAL</td><td align="left">临时节点(不可在拥有子节点)</td></tr><tr><td align="left">EPHEMERAL_SEQUENTIAL</td><td align="left">临时序号节点(不可在拥有子节点)</td></tr></tbody></table><h4><span id="persistent持久节点">PERSISTENT（持久节点）</span></h4><ul><li>持久化保存的节点，也是默认创建的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>test<br></code></pre></td></tr></table></figure><h4><span id="persistent_sequential持久序号节点">PERSISTENT_SEQUENTIAL(持久序号节点)</span></h4><p>创建时zookeeper 会在路径上加上序号作为后缀，。非常适合用于分布式锁、分布式选举等场景。创建时添加 -s 参数即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s  <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000004<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">14</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000005<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">15</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000006<br></code></pre></td></tr></table></figure><h4><span id="ephemeral临时节点">EPHEMERAL（临时节点）</span></h4><ul><li>只存在于当前会话，当对话断开后会被删除。创建的时候增加 -e </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><ul><li>适用于心跳，服务发现等场景。如下图当node1挂掉了，它zookeeper1中创建的临时节点和其存储的数据就会就会被删除，zookeeper1就知道node1挂掉了。</li></ul><img src="/Users/panyurou/Library/Application Support/typora-user-images/image-20220116230200083.png" alt="image-20220116230200083" style="zoom:50%;"><h4><span id="ephemeral_sequential临时序号节点">EPHEMERAL_SEQUENTIAL（临时序号节点）</span></h4><p>与持久序号节点类似，不同之处在于EPHEMERAL_SEQUENTIAL是临时的会在会话断开后删除。创建时添加 -e -s </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">2</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000000<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">3</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000001<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">4</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000002<br></code></pre></td></tr></table></figure><h3><span id="节点属性">节点属性</span></h3><ul><li>查看节点属性</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">stat <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure><ul><li>属性说明</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">cZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x2</span>   #创建节点的事务ID<br>ctime <span class="hljs-operator">=</span> Mon Jan <span class="hljs-number">17</span> <span class="hljs-number">21</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16</span> CST <span class="hljs-number">2022</span> #创建节点的时间<br>mZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x2</span> #修改当前节点数据的事务ID<br>mtime <span class="hljs-operator">=</span> Mon Jan <span class="hljs-number">17</span> <span class="hljs-number">21</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16</span> CST <span class="hljs-number">2022</span> #最后修改时间<br>pZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x5</span> #子节点变更（包括自节点的删除和增加，不包括修改）的事务ID<br>cversion <span class="hljs-operator">=</span> <span class="hljs-number">3</span>  #这表示对此znode的子节点进行的更改次数，只包括自节点的删除和增加<br>dataVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #数据版本，当前节点数据变更次数<br>aclVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #权限版本，变更次数<br>ephemeralOwner <span class="hljs-operator">=</span> <span class="hljs-number">0x0</span> #临时节点所属会话ID，永久节点值为<span class="hljs-number">0x0</span><br>dataLength <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #数据长度<br>numChildren <span class="hljs-operator">=</span> <span class="hljs-number">3</span> #子节点数(不包括子子节点)<br></code></pre></td></tr></table></figure><h3><span id="节点的监听">节点的监听</span></h3><p>客户添加 -w 参数可实时监听节点与子节点的变化，并且实时收到通知。非常适用保障分布式情况下的数据一致性。其使用方式如下：</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ls -w path</td><td align="left">监听子节点的变化（增，删）</td></tr><tr><td align="left">get -w path</td><td align="left">监听节点数据的变化</td></tr><tr><td align="left">stat -w path</td><td align="left">监听节点属性的变化</td></tr><tr><td align="left">printwatches on|off</td><td align="left">触发监听后，是否打印监听事件(默认on)</td></tr></tbody></table><h4><span id="监听节点数据的变化">监听节点数据的变化</span></h4><ul><li><p>step1：打开客户端A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>Step2：打开客户端B:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;aaa&quot;<br></code></pre></td></tr></table></figure></li><li><p>此时客户端A，出现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">8</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br><span class="hljs-keyword">null</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>]<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeDataChanged path:<span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>再次在客户端B输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;ddd&quot;<br></code></pre></td></tr></table></figure><p>此时可以发现，客户端A没有收到任何通知，故这里的watch是一次性的，第二次触发不再生效。</p></li></ul><h4><span id="监听子节点的变化">监听子节点的变化</span></h4><ul><li><p>step1：打开客户端A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ls <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>Step2：打开客户端B:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br></code></pre></td></tr></table></figure></li><li><p>此时客户端A，出现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>] ls <span class="hljs-operator">-</span>w <span class="hljs-operator">/</span>temp<br>[c10000000000, c10000000001, c10000000002]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">10</span>]<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:<span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure><h3><span id="acl权限设置">ACL权限设置</span></h3></li><li><p>ACL全称为Access Control List（访问控制列表），用于控制资源的访问权限。   </p></li><li><p>ZooKeeper使用ACL来控制对其znode的防问。</p></li><li><p>基于<code>scheme:id:permission</code>的方式进行权限控制。scheme表示授权模式、id模式对应值、permission即具体的增删改权限位。</p></li></ul><h4><span id="scheme授权模型">scheme:授权模型</span></h4><table><thead><tr><th align="left">方案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">world</td><td align="left">开放模式，world表示全世界都可以访问（这是默认设置）</td></tr><tr><td align="left">ip</td><td align="left">ip模式，限定客户端IP防问</td></tr><tr><td align="left">auth</td><td align="left">用户密码认证模式，只有在会话中添加了认证才可以防问</td></tr><tr><td align="left">digest</td><td align="left">与auth类似，区别在于auth用明文密码，而digest 用sha-1+base64加密后的密码。在实际使用中digest 更常见。</td></tr></tbody></table><h4><span id="permission权限位"><strong>permission权限位</strong></span></h4><table><thead><tr><th align="left">权限位</th><th align="left">权限</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">CREATE</td><td align="left">可以创建子节点</td></tr><tr><td align="left">d</td><td align="left">DELETE</td><td align="left">可以删除子节点（仅下一级节点）</td></tr><tr><td align="left">r</td><td align="left">READ</td><td align="left">可以读取节点数据及显示子节点列表</td></tr><tr><td align="left">w</td><td align="left">WRITE</td><td align="left">可以设置节点数据</td></tr><tr><td align="left">a</td><td align="left">ADMIN</td><td align="left">可以设置节点访问控制列表权限</td></tr></tbody></table><h4><span id="acl-相关命令">acl 相关命令</span></h4><table><thead><tr><th align="left">命令</th><th align="left">使用方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getAcl</td><td align="left">getAcl <path></path></td><td align="left">读取ACL权限</td></tr><tr><td align="left">setAcl</td><td align="left">setAcl <path></path> <acl></acl></td><td align="left">设置ACL权限</td></tr><tr><td align="left">addauth</td><td align="left">addauth <scheme> <auth></auth></scheme></td><td align="left">添加认证用户</td></tr></tbody></table><h4><span id="示例">示例</span></h4><ul><li>world</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">11</span>] getAcl <span class="hljs-operator">/</span>temp<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: cdrwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">12</span>] setAcl <span class="hljs-operator">/</span>temp world:anyone:rwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] getAcl <span class="hljs-operator">/</span>temp<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: rwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">14</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>temp<br>ddd<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">15</span>] <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;bbb&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">16</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>t<br>Insufficient permission : <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>t<br></code></pre></td></tr></table></figure><ul><li><p>IP</p><p>语法： setAcl <path></path> ip:&lt;ip地址|地址段&gt;:&lt;权限位&gt;</p></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[zk: localhost<span class="hljs-function">:2181</span><span class="hljs-params">(CONNECTED)</span> 18] <span class="hljs-keyword">set</span>Acl <span class="hljs-string">/temp</span> ip<span class="hljs-function">:192.168.2.103</span><span class="hljs-function">:ra</span><br>[zk: localhost<span class="hljs-function">:2181</span><span class="hljs-params">(CONNECTED)</span> 19] getAcl <span class="hljs-string">/temp</span><br>Insufficient permission : <span class="hljs-string">/temp</span><br></code></pre></td></tr></table></figure><ul><li><p>auth</p><p>语法： </p><ol><li>setAcl <path></path> auth:&lt;用户名&gt;:&lt;密码&gt;:&lt;权限位&gt;</li><li>addauth digest &lt;用户名&gt;:&lt;密码&gt;</li></ol></li><li><p>digest</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> echo <span class="hljs-operator">-</span>n pyr:<span class="hljs-number">123456</span> <span class="hljs-operator">|</span> openssl dgst <span class="hljs-operator">-</span><span class="hljs-type">binary</span> <span class="hljs-operator">-</span>sha1 <span class="hljs-operator">|</span> openssl base64<br>zj9LbzdoKijw<span class="hljs-operator">/</span>kCo1pQJnXBFiq4<span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 28</span>] create /temp2<br>Created /temp2<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 30</span>] getAcl /temp2<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: cdrwa<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 31</span>] setAcl /temp2 digest:pyr:zj9LbzdoKijw/kCo1pQJnXBFiq4=:rwa<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 32</span>] getAcl /temp2<br>Insufficient permission : /temp2<br>[<span class="hljs-meta">zk: 127.0.0.1:2181(CONNECTED) 45</span>] addauth digest pyr:<span class="hljs-number">123456</span><br>[<span class="hljs-meta">zk: 127.0.0.1:2181(CONNECTED) 46</span>] <span class="hljs-keyword">get</span> /temp2<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
