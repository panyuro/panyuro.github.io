<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RabbitMQ的消息零丢失方案</title>
    <link href="/RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%B6%E4%B8%A2%E5%A4%B1%E6%96%B9%E6%A1%88/"/>
    <url>/RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E9%9B%B6%E4%B8%A2%E5%A4%B1%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ如何保证消息不丢失？"><a href="#RabbitMQ如何保证消息不丢失？" class="headerlink" title="RabbitMQ如何保证消息不丢失？"></a>RabbitMQ如何保证消息不丢失？</h1><h2 id="哪些环节会有丢消息的可能？"><a href="#哪些环节会有丢消息的可能？" class="headerlink" title="哪些环节会有丢消息的可能？"></a>哪些环节会有丢消息的可能？</h2><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h63pq7alokj219l0u0gpa.jpg" style="zoom:50%;" /><ul><li>1，2，4三个场景，都是跨网络的，而跨网络就肯定会有丢消息的可能。</li><li>关于3这个环节，通常MQ存盘时都会先写入操作系统的缓存page cache中，然后再由操作系统异步的将消息写入硬盘。这个中间有个时间差，就可能会造成消息丢失。如果服务挂了，缓存中还没有来得及写入硬盘的消息就会丢失。这也是任何用户态的应用程序无法避免的。</li><li>对于任何MQ产品，都应该从这四个方面来考虑数据的安全性。那我们看看用RabbitMQ时要如何解决这个问题。</li></ul><h2 id="RabbitMQ消息零丢失方案"><a href="#RabbitMQ消息零丢失方案" class="headerlink" title="RabbitMQ消息零丢失方案?"></a>RabbitMQ消息零丢失方案?</h2><h3 id="1-生产者保证消息正确发送到RibbitMQ"><a href="#1-生产者保证消息正确发送到RibbitMQ" class="headerlink" title="1. 生产者保证消息正确发送到RibbitMQ?"></a>1. 生产者保证消息正确发送到RibbitMQ?</h3><ul><li><p><strong>方案一：</strong>可以使用生产者确认机制。</p><p>通过多次确认的方式，保证生产者的消息能够正确的发送到RabbitMQ中。RabbitMQ的生产者确认机制分为同步确认和异步确认。</p><ul><li><p>同步确认主要是通过在生产者端使用Channel.waitForConfirmsOrDie()指定一个等待确认的完成时间。</p></li><li><p>异步确认机制则是通过在生产者端注入两个回调确认函数。第一个函数是在生产者发送消息时调用，第二个函数则是生产者收到Broker的消息确认请求时调用。两个函数需要通过sequenceNumber自行完成消息的前后对应。sequenceNumber的生成方式需要通过channel的序列获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.addConfirmListener(ConfirmCallback var1,ConfirmCallback var2)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>方案二：</strong>手动事务</p><ul><li><p>手动事务机制主要有几个关键的方法： channel.txSelect() 开启事务；channel.txCommit() 提交事务； channel.txRollback() 回滚事务。用这几个方法来进行事务管理。比如在创建订单后开启事务，减库存成功后提交事务，失败时回滚。</p></li><li><p>这种方式需要手动控制事务逻辑，并且手动事务会对channel产生阻塞，造成吞吐量下降</p></li></ul></li></ul><h3 id="2-RabbitMQ-主从消息同步时不丢消息"><a href="#2-RabbitMQ-主从消息同步时不丢消息" class="headerlink" title="2. RabbitMQ 主从消息同步时不丢消息?"></a>2. <strong>RabbitMQ 主从消息同步时不丢消息</strong>?</h3><ul><li>不使用普通集群模式， 使用镜像集群模式</li><li>给包含重要消息的队列建立一个远端备份。</li></ul><blockquote><ul><li><p>普通集群模式</p><ul><li><strong>queue的消息</strong>，只会放在<strong>一个rabbtimq实例</strong>上。<strong>每个实例都同步queue的结构和queue消息的真正位置</strong>。</li><li>消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。</li><li>这种集群模式的消息可靠性不是很高。因为如果其中有个节点服务宕机了，那这个节点上的数据就无法消费了，需要等到这个节点服务恢复后才能消费。</li></ul></li><li><p>镜像集群模式</p><ul><li><p>这种模式是在普通集群模式基础上的一种增强方案，这也就是RabbitMQ的官方HA高可用方案。</p></li><li><p>这种模式会在镜像节点中间主动进行消息同步，而不是在客户端拉取消息时临时同步。这种模式的消息可靠性更高，因为每个节点上都存着全量的消息。</p></li><li><p>他的弊端也是明显的，集群内部的网络带宽会被这种同步通讯大量的消耗，进而降低整个集群的性能。这种模式下，队列数量最好不要过多。</p></li></ul></li></ul></blockquote><h3 id="3-RabbitMQ消息存盘不丢消息"><a href="#3-RabbitMQ消息存盘不丢消息" class="headerlink" title="3. RabbitMQ消息存盘不丢消息?"></a>3. RabbitMQ消息存盘不丢消息?</h3><p>对于Classic经典队列，直接将队列声明成为持久化队列即可。</p><p>而新增的Quorum（[ˈkwɔrəm] 仲裁）队列和Stream队列，都是明显的持久化队列，能更好的保证服务端消息不会丢失。</p><blockquote><p>Quorum队列实现了持久化，多备份的FIFO队列，主要就是针对RabbitMQ的镜像模式设计的。大部分功能都是在Classic队列基础上做减法，比如不支持是非持久化的内存队列。某些功能（例如有害消息处理）是特定于仲裁队列的。</p><p>Stream队列是RabbitMQ自3.9.0版本开始引入的一种新的数据队列类型，更适合于消费者多，读消息非常频繁的场景。</p></blockquote><blockquote><p>毒消息是指消息一直不能被消费者正常消费(可能是由于消费者失败或者消费逻辑有问题等)，就会导致消息不断的重新入队，这样这些消息就成为了毒消息。这些读消息应该有保障机制进行标记并及时删除。Quorum队列会持续跟踪消息的失败投递尝试次数，并记录在”x-delivery-count”这样一个头部参数中。然后，就可以通过设置 Delivery limit参数来定制一个毒消息的删除策略。当消息的重复投递次数超过了Delivery limit参数阈值时，RabbitMQ就会删除这些毒消息。当然，如果配置了死信队列的话，就会进入对应的死信队列。</p></blockquote><h3 id="4-RabbitMQ消费者不丢失消息"><a href="#4-RabbitMQ消费者不丢失消息" class="headerlink" title="4. RabbitMQ消费者不丢失消息?"></a>4. <strong>RabbitMQ消费者不丢失消息</strong>?</h3><ul><li><p>RabbitMQ在消费消息时可以指定是自动应答，还是手动应答。将RabbitMQ的应答模式设定为手动应答可以提高消息消费的可靠性。</p></li><li><p>设置了手动确认，则需要在业务处理成成功后，手动调用<code>channer.basicAck()</code>,如果出现异常则调用<code>channer.basicNAck()</code>,设置消息是重新返回队列，还是直接丢掉。</p></li></ul><p><strong>最后，任何用户态的应用程序都无法保证绝对的数据安全，所以，备份与恢复的方案也需要考虑到。</strong></p><h2 id="Consumer-Ack-消费端收到消息后的确认方式"><a href="#Consumer-Ack-消费端收到消息后的确认方式" class="headerlink" title="Consumer Ack 消费端收到消息后的确认方式"></a>Consumer Ack 消费端收到消息后的确认方式</h2><ol><li><p>有三种确认方式</p><ul><li>自动确认 acknowledge &#x3D; “none”。 消息一旦到达consumer就会被确认，并将对应的message 从消息缓存中移除，实际场景中，很可能消息被收到，但是处理业务时异常，这种确认机制下，消息就会丢失。</li><li>手动确认acknowledge &#x3D; “manual”。设置了手动确认，则需要在业务处理成成功后，手动调用<code>channer.basicAck()</code>,如果出现异常则调用<code>channer.basicNAck()</code>,设置消息是重新返回队列，还是直接丢掉。</li><li>根据异常情况确认 acknowledge &#x3D; “auto”</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>rabbitMQ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的高级特性</title>
    <link href="/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/RabbitMQ%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ的高级特性"><a href="#RabbitMQ的高级特性" class="headerlink" title="RabbitMQ的高级特性"></a>RabbitMQ的高级特性</h1><h2 id="如何保证消息的顺序？"><a href="#如何保证消息的顺序？" class="headerlink" title="如何保证消息的顺序？"></a><strong>如何保证消息的顺序？</strong></h2><p>消息的顺序是指的是，一个组内消息的顺序，而不是整个mq里的消息顺序。比如一个下单过程需要完成扣款，减库存，通知快递发货，这一组消息的顺序不能乱。</p><ul><li><p>发送端：一组有序消息，只发到一个队列中，利用队列的FIFO特性保证消息在发送时顺序不会乱。</p><p>如果发送端配置了重试机制，就可能出现发送方发送时是1，2，3，但1发送失败，重试发送1，这样收到的消息就是2，3，1。这种情况下，需要同步的去发消息，只有第一个消息发送成功了，再去发送2，3。</p></li><li><p>消费者端：进行消费时，保证只有一个消费者，同时指定prefetch属性为1，即每次RabbitMQ都只往消费端推送一个消息。这样可以保证消费时的有序。</p></li></ul><p><strong>显然，这是以极度消耗性能作为代价的，在实际适应过程中，应该尽量避免这种场景。</strong></p><h2 id="消息积压和解决"><a href="#消息积压和解决" class="headerlink" title="消息积压和解决"></a>消息积压和解决</h2><h3 id="1-发送方发送流量太大"><a href="#1-发送方发送流量太大" class="headerlink" title="1.发送方发送流量太大"></a>1.发送方发送流量太大</h3><ul><li>降低消息生产的速度。生产者端产生消息的速度通常是跟业务息息相关的，一般情况下不太好直接优化。但是可以采用批量发送消息的方式，降低IO频率。</li></ul><h3 id="2-消费者能力不足"><a href="#2-消费者能力不足" class="headerlink" title="2. 消费者能力不足"></a>2. 消费者能力不足</h3><ul><li><p>修改消费端程序，写一个临时的分发数据的 consumer 程序，将收到的消息快速转发给临时建立好原先 10 倍的 queue， 接着临时征用 10 倍的机器来部署 consumer，每一个 consumer 消费一个临时 queue 的数据。</p></li><li><p>上线专门的消费者组。专门用来将消息快速转录。保存到数据库或者Redis，然后再慢慢进行处理。</p></li><li><p>对于单个消费者端，可以通过配置提升消费者端的吞吐量。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># 单次推送消息数量<br>spring.rabbitmq.listener.simple.prefetch=<span class="hljs-number">1</span><br># 消费者的消费线程数量<br>spring.rabbitmq.listener.simple.concurrency<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-消费者有bug或者宕机了"><a href="#3-消费者有bug或者宕机了" class="headerlink" title="3.消费者有bug或者宕机了"></a>3.消费者有bug或者宕机了</h3><ul><li>将消费不成功的消息转发到其他队列里，类似死信队列，后面再慢慢分析。kafka没有死信队列需要自己实现。</li></ul><h4 id="其他解决方式"><a href="#其他解决方式" class="headerlink" title="其他解决方式"></a>其他解决方式</h4><ul><li>RabbitMQ服务端：尝试使用新推出的Quorum以及Stream队列，也能很好的提高服务端的消息堆积能力。但是这两种队列的稳定性和周边生态都还不够完善。</li><li>RabbitMQ一直以来，就是对于消息堆积问题的处理不好。当RabbitMQ中有大量消息堆积时，整体性能会严重下降。不行就换kafka</li></ul><h2 id="消息的幂等性"><a href="#消息的幂等性" class="headerlink" title="消息的幂等性"></a>消息的幂等性</h2><p>造成消息重复的根本原因是：网络不可达。 </p><p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收 到两条一样的消息，应该怎样处理？ </p><p>方案一： 利用一张日志表来记录已经处理成功的消息的 ID，如 果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 </p><p>方案二：消息生成唯一的id，存储在redis中。</p><p>方案二：</p><ul><li><p>第一次 执行更新语句的是一样，version &#x3D;1 </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">update account <span class="hljs-keyword">set</span> price = price <span class="hljs-number">-100</span>, <span class="hljs-built_in">version</span> = <span class="hljs-built_in">version</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">version</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>第二次, 执行更新语句的是一样，version 已经变成了2，此时找<code>where version = 1 </code> 就无法找到</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">update account <span class="hljs-keyword">set</span> price = price <span class="hljs-number">-100</span>, <span class="hljs-built_in">version</span> = <span class="hljs-built_in">version</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">version</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><ul><li>在<a href="rabbit:listener-container">rabbit:listener-container</a> 中配置<code>prefetch</code>属性设置消费端一次拉取多少消息</li><li>消费端的确认模式需要是手动确认</li></ul><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><ol><li>TTL全称：time to live 消息存活时间或消息过期时间</li><li>消息达到了存活时间后，如果还没被消费，会被自动移除</li><li>RabbitMQ可以对消息设置过期时间，也可以对整个队列设置过期时间。</li></ol><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><ul><li><p>当消息成为死信后，可以被重新发送到一个交换机，这个交换机就是死信交换机，它绑定的队列就是死信队列</p></li><li><p>成为死信的条件：</p><ul><li>消息达到了存活时间，还没有被消费。</li><li>消费者拒收消息，并且不重回队列。  </li><li>队列到达了指定的长度限制</li></ul></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"># 指定了消息的过期时间为10s <br>AMQP.BasicProperties properties = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder()<br>                .deliveryMode(<span class="hljs-number">2</span>)<br>                .contentEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>                .expiration(<span class="hljs-string">&quot;10000&quot;</span>)<br>                .build();<br>  channel.basicPublish(exchange, routingKey, <span class="hljs-keyword">true</span>, properties, msg.getBytes());<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String exchangeName = <span class="hljs-string">&quot;test_dlx_exchange&quot;</span>;<br>channel.exchangeDeclare(exchangeName, <span class="hljs-string">&quot;topic&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br># 在队列加上一个参数，指定死信队列<br>Map&lt;String, Object&gt; agruments = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>agruments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, <span class="hljs-string">&quot;dlx.exchange&quot;</span>);<br>channel.queueDeclare(queueName, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, agruments);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列，消息进入队列后，不会立即被消费，而是等到一定的时间，才会被消费。</p><p>使用场景：</p><ol><li>用户下单后，30分钟未支付，取消订单，回滚库存</li><li>新用户注册7天后，发送短信问候</li></ol><blockquote><p>当然上面的场景也可以用定时器实现</p></blockquote><p>rabbitmq现在不支持延迟队列，延迟队列的实现需要借助TTL和死信队列。具体实现流程：</p><ul><li>用户下单，把消息发送到Queue1中，不设置Consumer1，设置Queue1队列里的消息存活时间为30分钟，等待30分钟后，消息成为死信。</li><li>死信的消息发送到Queue2，添加Consumer2监听Queue2</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwld73gtjaj31ga0o440f.jpg" style="zoom:43%;" /><h4 id="死信队列和延时队列的区别"><a href="#死信队列和延时队列的区别" class="headerlink" title="死信队列和延时队列的区别"></a>死信队列和延时队列的区别</h4><ul><li>死信队列，监听的是Queue1,成为死信的消息会被丢到DLX中，或者不处理自己清理掉</li><li>延迟队列，监听的是死信队列</li></ul>]]></content>
    
    
    <categories>
      
      <category>rabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitMQ入门</title>
    <link href="/rabbitMQ%E5%85%A5%E9%97%A8/"/>
    <url>/rabbitMQ%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MQ介绍"><a href="#MQ介绍" class="headerlink" title="MQ介绍"></a>MQ介绍</h1><h2 id="什么是MQ？"><a href="#什么是MQ？" class="headerlink" title="什么是MQ？"></a>什么是MQ？</h2><ul><li>MQ：MessageQueue，消息队列。 队列，是一种FIFO 先进先出的数据结构。</li><li>消息由生产者发送到MQ进行排队，然后按原来的顺序交由消息的消费者进行处理。</li><li>QQ和微信就是典型的MQ。</li></ul><h2 id="MQ的的优点："><a href="#MQ的的优点：" class="headerlink" title="MQ的的优点："></a>MQ的的优点：</h2><ul><li><p><strong>异步</strong>：相比于传统的串行、并行执行，可以提高吞吐量。 比如：发快递的时候，我们不需要等待用户接收到快递，而是把快递放进菜鸟驿站，发消息后，离开，用户闲暇时去取快递。</p></li><li><p><strong>解偶</strong>：服务之间进行解耦，才可以减少服务之间的影响。提高系统整体的稳定性以及可扩展性。比如用户下单的场景，用户下单后，订单系统需要通知库存系统减库存，传统的模式，当库存系统无法访问时，用户调用接口失败，从而导致下单失败。但引入MQ后，用户下单后，将下单消息写入消息队列，然后返回用户下单成功，库存系统去订阅下单的消息，去拉取下单信息，从而进行减库存，这时即使库存系统不可用，依旧可以下单成功，实现了订单系统和库存系统的解耦。</p></li><li><p><strong>削峰</strong>：可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请 求。 比如双十一，请求量比较大的时候，我们可以把请求放到MQ里，下游服务再慢慢消费。</p></li></ul><h2 id="MQ的缺点"><a href="#MQ的缺点" class="headerlink" title="MQ的缺点"></a><strong>MQ的缺点</strong></h2><ul><li>系统可用性降低。系统引入的外部依赖增多，系统的稳定性就会变差。一旦MQ宕机，对业务会产生影响。这就需要考虑如何保证MQ的高可用</li><li>系统复杂度提高。引入MQ后系统的复杂度会大大提高。以前服务之间可以进行同步的服务调用，引入MQ后，会变为异步调用，数据的链路就会变得更复杂。并且还会带来其他一些问题。比如：如何保证消费不会丢失？不会被重复调用？怎么保证消息的顺序性等问题</li><li>消息一致性问题。A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统处理成功，C系统处理失败怎么办？这就需要考虑如何保证消息数据处理的一致性。</li></ul><h1 id="什么是RabbitMQ？"><a href="#什么是RabbitMQ？" class="headerlink" title="什么是RabbitMQ？"></a><strong>什么是RabbitMQ？</strong></h1><p>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件</p><h1 id="为什么选择rabbitmq？"><a href="#为什么选择rabbitmq？" class="headerlink" title="为什么选择rabbitmq？"></a>为什么选择rabbitmq？</h1><ul><li>支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 </li><li>支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。</li><li>开 源的，比较稳定的支持，活跃度也高</li></ul><blockquote><p>缺点： 确实 erlang 语言阻止了大量的 Java 工程师 去深入研究和掌控它，对公司而言，几乎处于不可控的状态，</p></blockquote><h1 id="RabbitMQ的基本概念"><a href="#RabbitMQ的基本概念" class="headerlink" title="RabbitMQ的基本概念"></a>RabbitMQ的基本概念</h1><ul><li>connection： 客户端与RabbitMQ进行交互，首先就需要建立一个TPC连接，这个连接就是Connection</li></ul><ul><li><p>Broker： 简单来说就是消息队列服务器实体 </p></li><li><p>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 </p></li><li><p>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 </p></li><li><p>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 </p></li><li><p>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 </p></li><li><p>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部 均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的 权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，类似mysql中的database创建一个table 需要指明用哪个数据库。</p></li></ul><h1 id="channel信道"><a href="#channel信道" class="headerlink" title="channel信道"></a>channel信道</h1><ul><li>信道是生产者&#x2F;消费者与rbabitmq通信的渠道。生产者publish或者消费者consume一个队列都是通过信道完成的。</li><li>多线程时，rabbitMQ在一条tcp上建立多个信道来处理多线程。</li><li>每个信道在rabbitmq上有唯一的id,保证一个信道对应一个线程使用。</li></ul><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><ul><li><p>交换机就类似是路由器，他会根据路由键（在rabbitMQ就是routing key），将消息分发到相应的队列上去。</p></li><li><p>交换机的四种类型</p><ul><li>fanout: 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。(1:N)</li><li>Direct :   把消息路由到BindingKey和RoutingKey完全匹配的队列中。(1:1)</li><li>topic: 可以根据模糊匹配，可以将多个消息路由到同一个队列，比如一个队列的routing_key是’’.test”那么凡是到达路由器的消息的后缀为“.test”，都会进到这个队列。<ul><li>“* ”只能是一个单词，如“”aa.test“</li><li>“#”可以是&gt;&#x3D; 0的单词，如“”test“,”aa.bb.test”</li></ul></li><li><code>headers</code>:不依赖路由键匹配规则路由消息。是根据发送消息内容中的<code>headers</code>属性进行匹配。性能差，基本用不到。</li></ul></li></ul><h1 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h1><ul><li><p>交换机就类似是路由器，他会根据路由键（在rabbitMQ就是routing key），将消息分发到相应的队列上去。</p></li><li><p>交换机的四种类型</p><ul><li>fanout: 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。(1:N)</li><li>Direct :   把消息路由到BindingKey和RoutingKey完全匹配的队列中。(1:1)</li><li>topic: 可以根据模糊匹配，可以将多个消息路由到同一个队列，比如一个队列的routing_key是’’.test”那么凡是到达路由器的消息的后缀为“.test”，都会进到这个队列。<ul><li>“* ”只能是一个单词，如“”aa.test“</li><li>“#”可以是&gt;&#x3D; 0的单词，如“”test“,”aa.bb.test”</li></ul></li><li><code>headers</code>:不依赖路由键匹配规则路由消息。是根据发送消息内容中的<code>headers</code>属性进行匹配。性能差，基本用不到。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>rabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制的深度解析</title>
    <link href="/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <url>/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="类加载运行全过程"><a href="#类加载运行全过程" class="headerlink" title="类加载运行全过程"></a>类加载运行全过程</h2><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过<strong>类加载器</strong>把主类加载到 JVM。</p><p>有如下几步： <strong>加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;</strong> 使用 &gt;&gt; 卸载 </p><ul><li>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个<strong>代表这个类的</strong> <strong>.Class对象</strong>，作为这个类的各种数据的访问入口 。</li><li>验证：校验字节码文件的正确性 </li><li>准备：给类的静态变量分配内存，并赋予默认值 </li><li>解析：将<strong>符号引用</strong>替换为直接引用（地址引用）</li><li><strong>初始化</strong>：对类的静态变量初始化为指定的值，执行静态代码块</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h2><ul><li>bootstrap ClassLoader引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等 </li><li>ExtClassLoader 扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包</li><li>AppClassLoader 应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li><li>自定义加载器：负责加载用户自定义路径下的类包</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><strong>双亲委派机制</strong></h2><p>加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类</p>]]></content>
    
    
    <categories>
      
      <category>性能调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类加载机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud知识点整理</title>
    <link href="/springCloud%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/springCloud%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么会出现SpringCloud"><a href="#为什么会出现SpringCloud" class="headerlink" title="为什么会出现SpringCloud?"></a>为什么会出现SpringCloud?</h2><p>单体架构的优缺点</p><p>优点：</p><ul><li>部署简单：只有一个包</li><li>技术单一：同一个架构来说，基本上是一个一种技术，类似springboot + java</li><li>用人成本低：因为只需要一种技术</li></ul><p>缺点：</p><ul><li>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。</li><li>经常需要解决冲突，开发效率低：开发人员同时维护同一套代码，很难避免代码冲突。开发过程中会伴随解决冲突，严重影响开发效率。</li><li>排查解决问题成本高：线上发现了bug，可能bu g很简单，但是由于只有一套代码，需要编译打包上线，成本很高。</li><li>监控很难：很多功能点，杂在一个系统中。</li></ul><p>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。</p><h2 id="什么是Spring-Cloud？"><a href="#什么是Spring-Cloud？" class="headerlink" title="什么是Spring Cloud？"></a><strong>什么是Spring Cloud</strong>？</h2><p>SpringCloud是基于SpringBoot的一整套实现微服务的<strong>框架</strong>。它提供了微服务开发所需的服务注册与发现、服务调用，负载均衡，API网关，配置管理、熔断器等组件。最重要的是，基于SpringBoot，会让开发微服务架构非常方便。</p><h2 id="springCloud的优缺点"><a href="#springCloud的优缺点" class="headerlink" title="springCloud的优缺点"></a>springCloud的优缺点</h2><p>优点：</p><ul><li>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善 。</li><li>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例 如、配置管理、服务发现、断路器、微服务网关等； </li><li>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案</li><li>服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率</li><li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发 </li><li>微服务可以是跨平台的，可以用任何一种语言开发</li></ul><p>缺点：</p><ul><li>微服务过多，治理成本高，不利于维护系统 </li><li>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</li></ul><h2 id="springboot-和springCloud-的区别和联系"><a href="#springboot-和springCloud-的区别和联系" class="headerlink" title="springboot 和springCloud 的区别和联系"></a>springboot 和springCloud 的区别和联系</h2><ul><li>springCloud 是基于Springboot 构建的，他里面的每个子项目就是一个springboot项目。SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不 开SpringBoot ，属于依赖的关系 </li><li>SpringBoot专注于快速方便的开发单个个体微服务。 SpringCloud是关注全局的微服务协调整理治理框架，为微服务架构提供了非常完整的支持。例 如、配置管理、服务发现、断路器、微服务网关等</li></ul><h2 id="服务注册和发现是什么意思？"><a href="#服务注册和发现是什么意思？" class="headerlink" title="服务注册和发现是什么意思？"></a>服务注册和发现是什么意思？</h2><ul><li>服务注册 ，就是将提供某个服务的模块信息 (通常是这个服务的ip和端口)注册到1个公共的组件上去。</li><li>服务发现 ，就是新<strong>注册的这个服务模块能够及时的被其他调用者发现。</strong></li></ul><h2 id="Spring-Cloud-如何实现服务注册和发现？"><a href="#Spring-Cloud-如何实现服务注册和发现？" class="headerlink" title="Spring Cloud 如何实现服务注册和发现？"></a>Spring Cloud 如何实<strong>现服务注册和发现？</strong></h2><p>由于所有服务都在 Eureka 服务器上注册并 通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h2 id="什么是服务熔断？"><a href="#什么是服务熔断？" class="headerlink" title="什么是服务熔断？"></a>什么是服务熔断？</h2><ul><li>服务熔断就是对服务的调用执行熔断，对于后续的请求，不再调用目标服务，而是直接返回一个合理的信息，比如说请求量太大，返回一个”此时服务过载”，从而可以快速释放资源</li><li>保护系统</li></ul><h2 id="为什么会有这种熔断机制的出现"><a href="#为什么会有这种熔断机制的出现" class="headerlink" title="为什么会有这种熔断机制的出现?"></a>为什么会有这种熔断机制的出现?</h2><p>在微服务相互调用的时候可能会出现服务调用发生异常或调用超时,多此请求造成服务积压导致服务无法使用后接着级联导致调用此服务的消费者也出现异常或调用超时,最后导致整个系统的全部崩溃.这就是雪崩效应.</p><blockquote><p><a href="https://so.csdn.net/so/search?q=%E7%BA%A7%E8%81%94&spm=1001.2101.3001.7020">级联</a>(失败)雪崩：一个服务失败，导致整条链路的服务都失败的情形。</p></blockquote><h2 id="熔断器的功能"><a href="#熔断器的功能" class="headerlink" title="熔断器的功能"></a>熔断器的功能</h2><ul><li>异常处理。需要可以根据异常的类型，去处理异常</li><li>日志记录。记录失败的数目，才可以开启熔断</li><li>测试失败的操作。周期性的检查来测试服务是否健康。</li><li>手动复位。管理员可以强行关闭断路器，重置故障的计数器</li><li>并发。断路器可以支持大并发量</li><li>加速断路：检测出问题的速度要快，及时响应</li><li>重试失败请求：在服务可用时，可以安排重试</li></ul><h2 id="熔断和降级的区别"><a href="#熔断和降级的区别" class="headerlink" title="熔断和降级的区别"></a>熔断和降级的区别</h2><p>相同点：</p><ul><li>目的一致。通过技术手段来保护系统</li><li>表现类似：让用户体验到某些服务暂时不可用</li><li>粒度相同：都是基于服务的</li></ul><p>不同点</p><ul><li>触发条件不同<ul><li>服务熔断：服务熔断由链路上某个服务故障引起的</li><li>服务降级，整体负荷来考虑。比如：原本有一个系统可以承载100个请求，但是后面由于请求数降低，相应的服务数量也需要降低</li></ul></li><li>管理目标层级不同<ul><li>服务熔断：服务熔断是一个框架层次的处理，</li><li>服务降级：服务降级是业务层次的处理。降级一般是从外围服务开始</li></ul></li></ul><h2 id="什么是-Hystrix？它如何实现容错？"><a href="#什么是-Hystrix？它如何实现容错？" class="headerlink" title="什么是 Hystrix？它如何实现容错？"></a><strong>什么是 Hystrix？它如何实现容错？</strong></h2><ul><li>Feign是Netflix开发的一款服务容错和保护组件</li><li>当出现服务异常或调用超时时，Hystrix 定义了一个回退方法，与公开服 务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br><span class="hljs-meta">@HystrixCommand(fallbackMethod=&quot;defaultCities&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> cityClient.listCity();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">defaultCities</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Micro weather city eureka is down!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="熔断的意义？"><a href="#熔断的意义？" class="headerlink" title="熔断的意义？"></a>熔断的意义？</h2><ul><li>让系统更加稳定</li><li>减少性能损耗<ul><li>响应很简单，所以产生的性能很小。</li><li>用户知道服务有问题了，就不再调用，避免一直重试，也可以减少性能损耗。</li></ul></li><li>及时响应。不需要其他计算，直接就可以返回一个简单的响应。</li><li>阀值可定制，比如请求到达10000，就开启熔断器</li></ul><h2 id="springCloud-config-是什么？"><a href="#springCloud-config-是什么？" class="headerlink" title="springCloud config 是什么？"></a>springCloud config 是什么？</h2><ul><li>Spring Cloud Config 是由 Spring Cloud 团队开发的项目，它可以为微服务架构中各个微服务提供集中化的外部配置支持。</li><li>Spring Cloud Config 可以将各个微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git 、SVN 等）中，对配置的统一管理，以支持各个微服务的运行。</li><li>Spring Cloud Config 包含以下两个部分：<ul><li>Config Server：也被称为分布式配置中心，它是一个独立运行的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密信息和解密信息的访问接口。</li><li>Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并从 Config Sever 中获取和加载配置信息。</li></ul></li></ul><h2 id="Spring-Cloud-Bus？"><a href="#Spring-Cloud-Bus？" class="headerlink" title="Spring Cloud Bus？"></a>Spring Cloud Bus？</h2><ul><li>Spring Cloud Bus 又被称为消息总线，它能够通过轻量级的消息代理（例如 RabbitMQ、Kafka 等）来构建一个公用的<strong>消息主题</strong>，将微服务架构中的各个服务都连接上来起来，从而实现广播状态更改、事件推送等功能，还可以实现微服务之间的通信功能。</li><li>目前 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka。</li></ul><h2 id="Spring-Cloud-Bus-的基本原理"><a href="#Spring-Cloud-Bus-的基本原理" class="headerlink" title="Spring Cloud Bus 的基本原理"></a>Spring Cloud Bus 的基本原理</h2><ul><li>Spring Cloud Bus 会使用一个轻量级的消息代理来构建一个公共的消息主题 Topic（默认为“springCloudBus”），<strong>这个 Topic 中的消息会被所有服务实例监听和消费</strong>。</li><li>当其中的一个服务刷新数据时，Spring Cloud Bus 会把信息保存到 Topic 中，这样监听这个 Topic 的服务就收到消息并自动消费。</li></ul><h2 id="Spring-Cloud-Bus-动态刷新配置的原理"><a href="#Spring-Cloud-Bus-动态刷新配置的原理" class="headerlink" title="Spring Cloud Bus 动态刷新配置的原理"></a>Spring Cloud Bus 动态刷新配置的原理</h2><ul><li>当 Git 仓库中的配置发生了改变，我们只需要向某一个服务Config 服务端，也可以是 Config 客户端发送一个 POST 请求，Spring Cloud Bus 就可以通过消息代理通知其他服务重新拉取最新配置，以实现配置的动态刷新。</li><li>利用 Spring Cloud Bus 的特殊机制可以实现很多功能，其中配合 Spring Cloud Config 实现配置的动态刷新就是最典型的应用场景之一。</li></ul><h2 id="Spring-Cloud-Bus-整合Spring-Cloud-Config实现配置的动态刷新"><a href="#Spring-Cloud-Bus-整合Spring-Cloud-Config实现配置的动态刷新" class="headerlink" title="Spring Cloud Bus 整合Spring Cloud Config实现配置的动态刷新"></a>Spring Cloud Bus 整合Spring Cloud Config实现配置的动态刷新</h2><ol><li>当 Git 仓库中的配置发生改变后，运维人员向 Config 服务端发送一个 POST 请求，请求路径为“&#x2F;actuator&#x2F;refresh”。</li><li>Config 服务端接收到请求后，会将该请求转发给服务总线 Spring Cloud Bus。</li><li>Spring Cloud Bus 接到消息后，会通知给所有 Config 客户端。</li><li>Config 客户端接收到通知，请求 Config 服务端拉取最新配置。</li><li>所有 Config 客户端都获取到最新的配置。</li></ol><h2 id="Spring-Cloud-Netflix核心组件？"><a href="#Spring-Cloud-Netflix核心组件？" class="headerlink" title="Spring Cloud Netflix核心组件？"></a><strong>Spring Cloud Netflix</strong>核心组件？</h2><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等 核心组件。</p><ul><li><p>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制； </p></li><li><p>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略； </p></li><li><p>Feign：基于Ribbon和Hystrix的声明式服务调用组件； </p></li><li><p>Zuul：API网关组件，对请求提供路由及过滤功能。</p></li><li><p>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了 容错能力；</p></li></ul><h3 id="Ribbon-和-Feign-的区别和联系"><a href="#Ribbon-和-Feign-的区别和联系" class="headerlink" title="Ribbon 和 Feign 的区别和联系"></a>Ribbon 和 Feign 的区别和联系</h3><ul><li><p>相同点：二者都是Netflix开发的，可以用来实现服务间的调用以及负载均衡。Feign 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端。</p></li><li><p>调用方式不同</p><ul><li><p>ribbon是一个基于 HTTP 和 TCP <strong>客户端</strong>的负载均衡的工具。简单来说，rubbon &#x3D; 负载均衡+ restTemplate，需要自己构建请求，步骤相当繁琐。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//面向微服务编程，即通过微服务的名称来获取调用地址</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REST_URL_PREFIX = <span class="hljs-string">&quot;http://micro-weather-city-eureka&quot;</span>;<br>    <br> <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="hljs-string">&quot;/cities&quot;</span>, String.class);<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>采用接口的方式， <strong><code>只需要创建一个接口，然后在上面添加注解@FeignClient即可</code></strong> ，将需要调用的其他服务的方法定义成抽象方法即可， 不需要自己构建http请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;micro-weather-city-eureka&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CityClient</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function">String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>启动类上使用的注解不同</p><p>Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。</p></li></ul><p> 由于Ribbon写起来还需要自己拼请求，所以采用了更简单的Feign</p><h3 id="Spring-Cloud-Gateway-和zuul"><a href="#Spring-Cloud-Gateway-和zuul" class="headerlink" title="Spring Cloud Gateway 和zuul"></a>Spring Cloud Gateway 和zuul</h3><p>相同点：二者都是可以用来实现API网关</p><p>不同点：</p><ul><li>开发团队不同。<ul><li>zuul是netfix开发的</li><li>spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，用来取代Zuul网关。</li></ul></li><li>zuul性能相对gateway较差。<ul><li>Zuul1.* 是一个极具阻塞IO的API GateWay，每次IO操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成。所以zuul的性能较差。zuu2理念更先进，基于netty非阻塞，但是springCloud还没有整合。</li><li>Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty。高并发和非阻塞通信就非常有优势</li><li>Spring Cloud Gateway还支持webSocket，并且与spring有很好的集成</li></ul></li></ul><blockquote><p>WebSocket 协议,大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p></blockquote><p> 多方面比较，gateWay是很理想的网关选择。</p><h2 id="CAP原则以及eureka和zookeeper的对比"><a href="#CAP原则以及eureka和zookeeper的对比" class="headerlink" title="CAP原则以及eureka和zookeeper的对比"></a>CAP原则以及eureka和zookeeper的对比</h2><p><a href="https://panyurou.github.io/2022/07/21/CAP%E5%8E%9F%E5%88%99%E4%BB%A5%E5%8F%8Aeureka%E5%92%8Czookeeper%E7%9A%84%E5%AF%B9%E6%AF%94/">CAP原则以及eureka和zookeeper的对比 - 楼上有只喵 (panyurou.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单体架构的优缺点</title>
    <link href="/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <url>/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="单体架构的优缺点"><a href="#单体架构的优缺点" class="headerlink" title="单体架构的优缺点"></a>单体架构的优缺点</h1><p>优点：</p><ul><li><p>部署简单：只有一个包</p></li><li><p>技术单一：同一个架构来说，基本上是一个一种技术，类似springboot + java</p></li><li><p>用人成本低：因为只需要一种技术</p></li></ul><p>缺点：</p><ul><li><p>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。</p></li><li><p>开发效率低：开发人员同时维护同一套代码，很难避免代码冲突。开发过程中会伴随解决冲突，严重影响开发效率。</p></li><li><p>排查解决问题成本高：线上发现了bug，可能bu g很简单，但是由于只有一套代码，需要编译打包上线，成本很高。</p></li><li><p>监控很难：很多功能点，杂在一个系统中。</p></li></ul><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ul><li>由很多服务组成，每个服务都可以独立部署，每个服务之间以一种轻量级的通讯方式进行交互，例如http。这些服务之间没有很强的技术关联，可以A用java，B用Go.</li><li>设计原则：<ul><li>拆分足够的微。颗粒太大，没法发挥微服务的优势，颗粒太小，管理混乱。</li><li>轻量级通信。rest，消息中间件</li><li>领域驱动原则。比如客户是一个领域，表单是一个领域</li><li>单一指责。服务应该尽可能不依赖其他服务，边界应该足够清晰，而且接口应该妥善设计，隐藏内部细节。</li><li>DevOps</li><li>不限技术栈。比如mongo, pg</li></ul></li><li>如何设计：<ul><li>服务拆分</li><li>服务注册。多个服务间的通信，需要一个服务注册机制。服务启动的时候，要将服务注册到注册中心；服务中心和微服务之间通过某种机制关联，例如心跳机制；不同服务之间可以进行发现，从服务注册中心，获取要调用的服务的信息。</li><li>服务消费，调用其他服务，调用方相当于是服务消费者，被调用方是服务供应商</li><li>统一入口，服务数量多起来之后，每一个消费者要记住所有服务的名称是比较困难的，所以需要一个统一的入口，我们只需要知道入口的名称，而不需要知道具体服务提供者的名称。</li><li>配置的管理。配置文件里写上不同服务需要的配置，不同服务去做个性化配置。</li><li>熔断机制：某个微服务出现异常时（请求反应慢或宕机），其整个流程还是可以友好的进行下去。即向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就可以保证调用方的线程不会被长时间、无厘头滴占用，从而保护整个系统，避免崩溃。</li><li>自动扩展：服务可以根据当前附在状况可以自动扩展。比如当前有10个实例，当负荷突然增大，比如请求数增大，可以自动扩展成20个。</li></ul></li><li>拆分的意义<ul><li>易于实现：服务更小，代码更少，更加利于理解，实现。</li><li>易于维护：更少的代码，更容易维护</li><li>易于部署：每个服务都是轻量级实现，jar包比较小</li><li>易于更新：服务之间都是隔离的，所以每个服务都可以独立更新，不会影响其他服务。</li></ul></li><li>拆分的方法<ul><li>横向拆分。数据采集，数据存储，数据查询，数据展示</li><li>纵向拆分。基础设施层，领域层，应用层，用户界面</li><li>使用DDD。不同的领域</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>postgreSQL、mysql、Mongoldb、redis的对比</title>
    <link href="/postgresql%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/postgresql%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>postgreSQL 和 mysql的对比</p><ul><li><p>PostgreSQL是进程模式，MySQL是线程模式。进程模式对多CPU利用率比较高。</p></li><li><p>事务的支持：PostgreSQL支持事务的强一致性，事务保证性好，完全支持ACID特性。MySQL只有innodb引擎支持事务，mysiam不支持事务。</p></li><li><p>分区的实现：MySQL分区表的实现要优于PG的基于继承表的分区实现，主要体现在分区个数达到上千上万后的处理性能差异较大。</p></li><li><p>PG主表采用堆表存放，MySQL采用索引组织表，能够支持比MySQL更大的数据量。</p></li><li><p>MySQL不支持XML 数据类型，PostgreSQL支持</p></li><li><p>PostgreSQL完全免费，而且是BSD协议，如果把PostgreSQL改一改，然后再拿去卖钱，也没有人管你，这一点很重要，这表明了PostgreSQL数据库不会被其他公司控制。相反，MySQL现在主要是被Oracle公司控制。</p></li></ul><p> postgresql 和Mongoldb对比</p><ul><li>postgresql是关系型数据库，Mongoldb 是非关系型数据库，</li><li>查询语法不同。postgresql使用基本的sql操作，mongodb使用pipeline，比如pg join ，mongo $lookup</li><li>mongodb的优势就是文档存储，业务经常变动，需要不时的添加字段，那么mongodb比较适合</li></ul><p>Redis:</p><ul><li>非常丰富的数据结构</li><li>Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断；</li><li>数据存在内存中，读写非常的高速，可以达到10w&#x2F;s的频率</li></ul>]]></content>
    
    
    <categories>
      
      <category>postgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka知识点整理</title>
    <link href="/kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="kafka和RabbitMq的对比"><a href="#kafka和RabbitMq的对比" class="headerlink" title="kafka和RabbitMq的对比"></a>kafka和RabbitMq的对比</h3><ol><li><p>存储上：</p><ul><li>kafka支持了分布式存储，也就是分区。相当于把原来rabbitMq 的queue拆分成了很多个小队列，分布式存储在不同的服务上，提高了消息的发送的效率（一次可以发到多个分区），提高了消费效率，不同分区，使用不同的消费者，提高了并发处理能力。</li></ul></li><li><p>应用场景上：</p><ul><li>RabbitMQ,遵循AMQP协议，用在实时的对可靠性要求比较高的消息传递上。</li><li>kafka它主要用于处理活跃的流式数据,大数据量的数据处理上。</li></ul></li><li><p>在架构模型上：</p><ul><li>RabbitMQ遵循AMQP协议，RabbitMQ的broker由Exchange,Binding,queue组成。其中exchange和binding组成了消息的路由键；客户端Producer通过连接channel和server进行通信，Consumer从queue获取消息进行消费（长连接，queue有消息会推送到consumer端，consumer循环从输入流读取数据）。rabbitMQ以broker为中心；有消息的确认机制。</li><li>kafka遵从一般的MQ结构，producer，broker，consumer，以consumer为中心，消息的消费信息保存的客户端consumer上，consumer根据消费的点，从broker上批量pull数据；无消息确认机制。</li></ul></li><li><p>吞吐量上：</p><ul><li>rabbitMQ在吞吐量方面稍逊于kafka，他们的出发点不一样，rabbitMQ支持对消息的可靠的传递，支持事务，不支持批量的操作</li><li>kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)的复杂度，消息处理的效率很高。</li></ul></li><li><p>在可用性方面:</p><ul><li>rabbitMQ支持miror的queue，主queue失效，miror queue接管。</li><li>kafka的broker支持主备模式。</li></ul></li><li><p>在集群负载均衡方面:</p><ul><li>rabbitMQ的负载均衡需要单独的loadbalancer进行支持。</li><li>kafka采用zookeeper对集群中的broker、consumer进行管理，可以注册topic到zookeeper上；通过zookeeper的协调机制，producer保存对应topic的broker信息，可以随机或者轮询发送到broker上；并且producer可以基于语义指定分片，消息发送到broker的某分片上。</li></ul></li><li><p>消息的删除时间上：</p><ol><li>rabbitMQ 消费完了就删除。</li><li>kafka一般不会删除消息，不管这些消息有没有被消费。只会根据配置的日志保留时间(log.retention.hours)确认消息多 久被删除，默认保留最近一周的日志消息。这些日志可以被重复读取和无限期保留。</li></ol></li></ol><h3 id="为什么要对Topic下数据进行分区存储？"><a href="#为什么要对Topic下数据进行分区存储？" class="headerlink" title="为什么要对Topic下数据进行分区存储？"></a>为什么要对Topic下数据进行分区存储？</h3><ol><li>commit log文件会受到所在机器的文件系统大小的限制，分区之后可以将不同的分区放在不同的机器上，相当于对</li></ol><p>数据做了<strong>分布式存储</strong>，理论上一个topic可以处理任意数量的数据。 </p><p>  2、为了<strong>提高并行度</strong>，consumer可以并行去处理不同分区拿到的数据。</p><h3 id="怎么理解Topic，Partition和Broker-？"><a href="#怎么理解Topic，Partition和Broker-？" class="headerlink" title="怎么理解Topic，Partition和Broker ？"></a>怎么理解<strong>Topic，Partition和Broker</strong> ？</h3><ol><li><p>一个topic，代表逻辑上的一个业务数据集，比如按数据库里不同表的数据操作消息区分放入不同topic。</p></li><li><p>订单相关操作消息放入订单topic，用户相关操作消息放入用户topic，对于大型网站来说，后端数据都是海量的，订单消息很可能是非常巨量的，比如有几百个G甚至达到TB级别，如果把这么多数据都放在一台机器上可定会有容量限制问题，那么就可以在 topic内部划分多个partition来分片存储数据。</p></li><li><p>不同的partition可以位于不同的机器上，每台机器上都运行一个Kafka的进程Broker。</p></li></ol><h3 id="kafka的消费者是-pull-拉-还是push-推-模式，这种模式有什么好处？"><a href="#kafka的消费者是-pull-拉-还是push-推-模式，这种模式有什么好处？" class="headerlink" title="kafka的消费者是**pull(拉)还是push(推)**模式，这种模式有什么好处？"></a><strong>kafka</strong>的消费者是**pull(<strong>拉</strong>)<strong>还是</strong>push(<strong>推</strong>)**模式，这种模式有什么好处？</h3><p>Kafka 遵循了一种大部分消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从broker 拉取消息。</p><p>优点：pull模式消费者自主决定是否批量从broker拉取数据，而push模式在无法知道消费者消费能力情况下，不易控制推送速度，太快可能造成消费者奔溃，太慢又可能造成浪费。</p><p>缺点：如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询，直到新消息到到达。为了避免这点，Kafka 有个参数可以让 consumer阻塞直到新消息到达，当然也可以阻塞直到消息的数量达到某个特定的量这样就可以批量发送。</p><h2 id="消费进度Offset的理解"><a href="#消费进度Offset的理解" class="headerlink" title="消费进度Offset的理解"></a>消费进度Offset的理解</h2><ul><li><p>在消费者对指定消息分区进行消息消费的过程中，<strong>需要定时地将分区消息的消费进度Offset记录到Zookeeper上</strong>，以便在该消费者进行重启或者其他消费者重新接管该消息分区的消息消费后，能够从之前的进度开始继续进行消息消费。</p></li><li><p>现在是放在了一个叫做__consumer_offset 的topic 里，<strong>key是</strong> consumerGroupId+topic+分区号，value就是当前offset的值。默认是50个分区，由consumer自己管理。 </p></li><li><p><strong>每个consumer是基于自己在commit log中的消费进度(offset)来进行工作的</strong>。</p></li><li><p>这意味kafka中的consumer对集群的影响是非常小的，添加一个或者减少一个consumer，对于集群或者其他consumer 来说，都是没有影响的，因为每个consumer维护各自的消费offset。</p></li><li><p>一般情况下我们按照顺序逐条消费commit log中的消息，当然我可以通过指定offset来重复消费某些消息， 或者跳过某些消息。</p></li></ul><h2 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h2><ul><li>leader处理所有的针对这个partition的读写请求。</li><li>而followers被动复制leader的结果，不提供读写(主要是为了保证多副本数据与消费的一致性）。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。</li></ul><h2 id="消费顺序怎么保证？"><a href="#消费顺序怎么保证？" class="headerlink" title="消费顺序怎么保证？"></a>消费顺序怎么保证？</h2><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><ul><li><p><strong>发送端：</strong>发送消息的时候，往一个partition 中去发。</p><p>如果发送端配置了重试机制，就可能出现发送方发送时是1，2，3，但1发送失败，重试发送1，这样收到的消息就是2，3，1。这种情况下，需要同步的去发消息，只有第一个消息发送成功了，再去发送2，3。</p></li><li><p><strong>消费端：</strong>取消息的时候也从一个partition 中去取。一个partition同一个时刻，在一个consumer group里只能有一个consumer去消费，从而保证消费顺序。</p></li></ul><h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><ul><li><strong>发送端：</strong>发送消息的时候，往多个partition 中去发。</li><li><strong>消费端：</strong>只设置一个consumer，消息来了不立即处理，而是自己逻辑排序后处理。搞一个类似CountDownLatch，比如总共有3条消息，就只有当3条消息都接受到了后，才进行处理，consumer端自己可以在业务逻辑中排序，比如给消息里加上一个type类型，检测是下单的消息，就优先处理，然后再处理减库存，通知快递。如果考虑到性能还不够高，可以在consumer端，考虑增加<strong>多线程</strong>去处理。</li></ul><p>注意：</p><ul><li>consumer group中保证，consumer 的数量 &lt; partition的数量，否则多出的consumer得不到信息。</li><li>如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group中的consumer 数量也设置为1，但是这样会影响性能，所以kafka的顺序消费很少用。</li></ul><h2 id="消息积压和解决"><a href="#消息积压和解决" class="headerlink" title="消息积压和解决"></a>消息积压和解决</h2><h3 id="1-生产者发送流量太大"><a href="#1-生产者发送流量太大" class="headerlink" title="1.生产者发送流量太大"></a>1.生产者发送流量太大</h3><ul><li>降低消息生产的速度。生产者端产生消息的速度通常是跟业务息息相关的，一般情况下不太好直接优化。但是可以采用批量发送消息的方式，降低IO频率。</li></ul><h3 id="2-消费者能力不足"><a href="#2-消费者能力不足" class="headerlink" title="2. 消费者能力不足"></a>2. 消费者能力不足</h3><ul><li>修改消费端程序，写一个临时的分发数据的 consumer 程序，将收到的消息快速转发给指定的新创建的topic，给这个topic设置原来10倍的分区。临时征用 10 倍的机器来部署 consumer，每一个 consumer 消费一个新主题的分区。</li><li>将消息快速转录。保存到数据库或者Redis，然后再慢慢进行处理。</li><li>kafka消费能力不足，则可以考虑增加Topic的Partition的个数，同时提升消费者组的消费者数量。</li></ul><h3 id="3-数据格式变动或者消费者有bug"><a href="#3-数据格式变动或者消费者有bug" class="headerlink" title="3. 数据格式变动或者消费者有bug"></a>3. 数据格式变动或者消费者有bug</h3><ul><li>将消费不成功的消息转发到其他队列里，类似死信队列，后面再慢慢分析。kafka没有死信队列需要自己实现。</li></ul><h4 id="kafka-producer-中ack的配置是什么意思？"><a href="#kafka-producer-中ack的配置是什么意思？" class="headerlink" title="kafka producer 中ack的配置是什么意思？"></a>kafka producer 中ack的配置是什么意思？</h4><p>Kafka通过配置request.required.acks属性来确认消息的生产：</p><ul><li>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的，存在丢消息：数据还没写入leader，leader就挂了</li><li>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。因为follo wer还没同步数据。</li><li>-1或all producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。这种性能不高，一般是金融级别或者和钱打交道的时候采用。</li></ul><p><strong>避免消息丢失就可以将ack设置成-1或all</strong></p><h3 id="kafka-如何不消费重复数据？"><a href="#kafka-如何不消费重复数据？" class="headerlink" title="kafka 如何不消费重复数据？"></a>kafka 如何不消费重复数据？</h3><p>重复数据的产生：</p><ul><li><p>发送方：发送消息如果配置了重试机制，比如网络抖动时间过长导致发送端发送超时，实际broker可能已经接收到消息，但发送方会重新发送消息</p></li><li><p>消费方：如果消费这边配置的是自动提交，刚拉取了一批数据处理了一部分，但还没来得及提交，服务挂了，下次重启又会拉取相同的一批数据重复处理。</p></li></ul><p> 解决方式：</p><ul><li><p>数据库&#x2F;redis：设置一个唯一的id去标志这条消息，消费时去查询一下，如果已经消费过了，则不进行消费。 </p></li><li><p>redis分布式锁</p></li></ul><h4 id="Zookeeper-在-Kafka-中的作用"><a href="#Zookeeper-在-Kafka-中的作用" class="headerlink" title="Zookeeper 在 Kafka 中的作用?"></a>Zookeeper 在 Kafka 中的作用?</h4><p>Zookeeper 主要用于在集群中不同节点之间进行通信</p><ul><li><p>在Zookeeper上会有一个专门<strong>用来进行Broker服务器列表记录</strong>的节点&#x2F;brokers&#x2F;ids</p></li><li><p>每个Broker在启动时，都会到Zookeeper上进行注册，即到&#x2F;brokers&#x2F;ids下创建属于自己的节点，如&#x2F;brokers&#x2F;ids&#x2F;[0…N]。</p></li><li><p>Kafka使用了全局唯一的数字来指代每个Broker服务器，不同的Broker必须使用不同的Broker ID进行注册，创建完节点后，<strong>每个Broker就会将自己的IP地址和端口信息记录</strong>到该节点中去。其中，Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除。</p></li></ul><h2 id="延迟队列的实现"><a href="#延迟队列的实现" class="headerlink" title="延迟队列的实现"></a>延迟队列的实现</h2><ol><li>发送延时消息时先把消息按照不同的延迟时间段发送到指定的队列中（topic_1s，topic_5s，topic_10s，…topic_2h，这个一 般不能支持任意时间段的延时）。</li><li>consumer通过定时器进行轮训消费这些topic，查看消息是否到期，如果到期就把这个消息发送到具体业务处理的topic中。提交时需要带上offset，便于下次知道从哪里开始消费。</li><li>队列中消息越靠前的到期时间越早，具体来说就是定时器在一次消费过程中，对消息的发送时间做判断，看下是否延迟到对 应时间了，如果到了就转发，如果还没到这一次定时任务就可以提前结束了。</li></ol><h2 id="kafka-高性能的原因？"><a href="#kafka-高性能的原因？" class="headerlink" title="kafka 高性能的原因？"></a>kafka 高性能的原因？</h2><ul><li><p>磁盘顺序读写：kafka消息不能修改以及不会从文件中间删除保证了磁盘顺序读，kafka的消息写入文件都是追加在文件末尾， </p><p>不会写入文件中的某个位置(随机写)保证了磁盘顺序写。 </p></li><li><p>读写数据的批量batch处理以及压缩传输 。Kafka采用的数据压缩的方式，以时间换空间，通过cpu时间的增加来尽量的减少磁盘空间的占用和网络IO的传输量，Kafka中消息的压缩是发生在生产者和Broker端的。</p><ul><li>在生产者端，消息发送的时候将消息进行压缩，可以通过参数来配置进行压缩的算法</li><li>在消费者端就需要对消息进行解压缩操作</li></ul></li><li><p>数据传输的零拷贝</p><ul><li><p>传统的IO流程，某台机器将一份数据（比如一个文件）通过网络传输到另外一台机器，主要包括 read 和 write 过程。</p><ul><li>read：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区</li><li>write：先把用户缓冲区的数据写入到 socket缓冲区，最后写入网卡设备</li></ul></li><li><p>需要经过四次拷贝和四次状态的转换</p><ul><li><p>用户空间的应用程序通过read()函数，向操作系统发起IO调用，<strong>上下文从用户态到切换到内核态（切换1）</strong>，然后再通过 DMA 控制器将数据从【磁盘文件】拷贝到【操作系统内核缓冲区】</p></li><li><p>CPU将数据从【内核缓冲区】拷贝到【用户缓冲区】，<strong>上下文从内核态转为用户态（切换2）</strong>，read函数返回。</p></li><li><p>用户应用进程通过write函数，发起IO调用，<strong>上下文从用户态转为内核态（切换3）</strong>，CPU将数据从【用户缓冲区】拷贝到【内核中Socket缓冲区】</p></li><li><p>MA控制器把数据从【内核中Socket缓冲区】拷贝到【内核中网卡的缓冲区】<strong>上下文从内核态切换回用户态（切换4）</strong>，write函数返回</p></li></ul></li><li><p>Kafka 使用sendfile 来实现零拷贝</p><ul><li>数据从从【磁盘文件】拷贝到【操作系统内核缓冲区】后，直接让操作系统内核缓冲区的数据发送到网卡，跳过了两次CPU拷贝数据的步骤。减少了内核态和用户态上下文状态的切换</li></ul></li></ul><p>注：<strong>其实零拷贝，并不是说拷贝的次数为零，只是说没有cup拷贝的过程，这里的零拷贝指的是cpu拷贝次数为零</strong>，</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h645mwunu9j214i0msn0o.jpg" style="zoom:50%;" /></li></ul><blockquote><p> 什么是用户态、内核态?</p></blockquote><blockquote><ul><li>如果进程运行于内核空间，被称为进程的内核态</li><li>如果进程运行于用户空间，被称为进程的用户态。</li></ul><p>操作系统为每个进程都分配了内存空间，一部分是用户空间，一部分是内核空间。<strong>内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 代理</title>
    <link href="/java-%E4%BB%A3%E7%90%86/"/>
    <url>/java-%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p> 代理是一种设计模式</p><ul><li>定义：通过代理对象访问目标对象。</li><li>好处：可以在不修改目标对象的基础上，扩展目标对象的功能</li></ul><p> 代理类可以分为静态代理和动态代理。</p><h2 id="1-静态代理和动态代理"><a href="#1-静态代理和动态代理" class="headerlink" title="1.静态代理和动态代理"></a><strong>1.静态代理</strong>和动态代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ol><li><p>定义： 通过声明一个明确的代理类来访问源对象。需要和目标对象一起实现相同的接口或者继承相同的父类。</p></li><li><p>特点：在编译器确定代理对象，在程序运行前，代理类的.class文件就已经存在了。</p></li><li><p>优点：可以做到不修改目标对象的前提下，对目标对象的方法进行扩展。</p></li><li><p>缺点：</p><ul><li><p>代理类需要和目标类实现相同的接口，同时要实现相同的方法，这样就出现了很多重复代码。</p></li><li><p>如果接口增加一个方法，代理类和目标类都需要实现这个方法，增加了代码维护的复杂度。</p></li></ul></li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><ol><li><p>定义：使用JDK官方的Proxy类创建代理对象。</p></li><li><p>特点：在程序运行过程中，动态生成代理类，代理类需要实现<strong>InvocationHandler</strong>，重写invoke方法。</p></li><li><p>优点：</p><ul><li>接口中声明的所有方法被迁移到代理类中的invoke方法进行实现，这样，如果接口方法很多的话，不需要为每一个方法进行中转，可以灵活处理。</li></ul></li></ol><h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><ol><li><p>使用：第三方CGLib的Enhancer类创建代理对象, 设置Superclass为目标类， 使用的是方法拦截器 <strong>MethodInterceptor</strong>，重写intercept方法。</p></li><li><p>特点：Cglib是通过生成子类来实现的，代理对象既可以赋值给实现类，又可以赋值给接口。</p></li><li><p>优点：Cglib速度比jdk动态代理更快，性能更好。</p></li></ol><h2 id="静态代理程序示例"><a href="#静态代理程序示例" class="headerlink" title="静态代理程序示例"></a>静态代理程序示例</h2><p>step1:定义委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Email</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlashEmail</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Email</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>            System.out.println(<span class="hljs-string">&quot;邮件发送中。。。。。&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>       System.out.println(<span class="hljs-string">&quot;邮件接受中..........&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>step2:定义代理类，与委托类有同样的接口</p><p> 不改变原接口实现类的情况下，就可以对接口的功能进行需求变更</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Email</span> </span>&#123;<br><br>Email email;<br>     <span class="hljs-comment">//传入委托类初始化代理类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmailProxy</span><span class="hljs-params">(Email email)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>.email=email;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;发送邮件前准备。。。&quot;</span>);<br>    email.send();<br>    System.out.println(<span class="hljs-string">&quot;发送后。。。。。。&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revieve</span><span class="hljs-params">()</span> </span>&#123;<br><br>System.out.println(<span class="hljs-string">&quot;接受邮件前准备。。。&quot;</span>); <br>email.receive();<br>System.out.println(<span class="hljs-string">&quot;接受邮件成功....&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>step3:测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//原始对象</span><br>   Email email=<span class="hljs-keyword">new</span> FlashEmail();<br>   <span class="hljs-comment">//接口的代理类</span><br>   EmailProxy ep=<span class="hljs-keyword">new</span> EmailProxy(email);<br>   ep.send();<br>   System.out.println(<span class="hljs-string">&quot;-----------------------------------------&quot;</span>);<br>   ep.receive();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>测试结果：</p><p>发送邮件前准备。。。<br> 邮件发送中。。。。。<br> 发送后。。。。。。<br> -—————————————-<br> 接受邮件前准备。。。<br> 邮件接受中……….<br> 接受邮件成功….</p><h3 id="2-JDK动态代理程序示例"><a href="#2-JDK动态代理程序示例" class="headerlink" title="2 JDK动态代理程序示例"></a>2 JDK动态代理程序示例</h3><p>Step1: 定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Email</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revieve</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>step1:定义委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlashEmail</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Email</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>            System.out.println(<span class="hljs-string">&quot;邮件发送中。。。。。&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>       System.out.println(<span class="hljs-string">&quot;邮件接受中..........&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>step2:在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，以完成代理要完成的具体操作，这个类被要求实现<strong>InvocationHandler</strong>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.proxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>Object obj;<span class="hljs-comment">//委托对象</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmailProxy</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.obj = obj;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;send&quot;</span>.equals(method.getName())) &#123;<br> System.out.println(<span class="hljs-string">&quot;发送邮件前准备。。。&quot;</span>);<br> method.invoke(obj);<span class="hljs-comment">//从委托对象中，调用该对象的指定方法，这里相当于send方法</span><br>     System.out.println(<span class="hljs-string">&quot;发送后。。。。。。&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;receive&quot;</span>.equals(method.getName())) &#123;<br>System.out.println(<span class="hljs-string">&quot;接受邮件前准备。。。&quot;</span>); <br>method.invoke(obj);<br>System.out.println(<span class="hljs-string">&quot;接受邮件成功....&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>step4:测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Email email=<span class="hljs-keyword">new</span> FlashEmail();<br>    Email emailProxy=(Email) Proxy.newProxyInstance(<br>      email.getClass().getClassLoader(),<br>      email.getClass().getInterfaces(),<br>      <span class="hljs-keyword">new</span> EmailProxy(email) );<br>    emailProxy.send();<br>    System.out.println(<span class="hljs-string">&quot;---------------------------------------------------&quot;</span>);<br>    emailProxy.receive();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>测试结果：</p><p>发送邮件前准备。。。<br> 邮件发送中。。。。。<br> 发送后。。。。。。<br> -—————————————-<br> 接受邮件前准备。。。<br> 邮件接受中……….<br> 接受邮件成功….</p><h3 id="CGLIB动态代理程序示例"><a href="#CGLIB动态代理程序示例" class="headerlink" title="CGLIB动态代理程序示例"></a>CGLIB动态代理程序示例</h3><p>Step1: 引入cglib依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;cglib&lt;/groupId&gt;<br>  &lt;artifactId&gt;cglib&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.5</span>&lt;/version&gt;<br>  &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>Step2: 定义委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlashEmail</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;邮件发送中。。。。。&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;邮件接受中..........&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Step3: 创建一个拦截器，实现接口net.sf.cglib.proxy.MethodInterceptor，用于方法的拦截回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    Object result = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;send&quot;</span>.equals(method.getName())) &#123;<br>      System.out.println(<span class="hljs-string">&quot;发送邮件前准备。。。&quot;</span>);<br>      result = methodProxy.invokeSuper(proxy,args);<br>      System.out.println(<span class="hljs-string">&quot;发送后。。。。。。&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;receive&quot;</span>.equals(method.getName())) &#123;<br>      System.out.println(<span class="hljs-string">&quot;接受邮件前准备。。。&quot;</span>);<br>      result = methodProxy.invokeSuper(proxy,args);<br>      System.out.println(<span class="hljs-string">&quot;接受邮件成功....&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Step4: 测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> proxy;<br><br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建Enhancer对象，类似于JDK动态代理的Proxy类</span><br>    Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>    enhancer.setSuperclass(FlashEmail.class);<br>    enhancer.setCallback(<span class="hljs-keyword">new</span> LogInterceptor());<br>    <span class="hljs-comment">// create方法正式创建代理类</span><br>    FlashEmail emailProxy = (FlashEmail)enhancer.create();<br>    emailProxy.send();<br>    emailProxy.receive();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><p>发送邮件前准备。。。<br> 邮件发送中。。。。。<br> 发送后。。。。。。<br> -—————————————-<br> 接受邮件前准备。。。<br> 邮件接受中……….<br> 接受邮件成功….</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring知识点整理</title>
    <link href="/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="Spring是什么？有什么优点"><a href="#Spring是什么？有什么优点" class="headerlink" title="Spring是什么？有什么优点"></a>Spring是什么？有什么优点</h4><ul><li>Spring是一个轻量级的java框架，Spring的核心是IOC和AOP。主要的优点包括：<ul><li>方便解耦，简化开发。通过Spring提供的IOC容器，我们可以将对象的依赖关系交给Spring进行控制，避免硬编码造成的耦合性高。简单来说，之前，如果我们controller 需要一个service，则需要new service，现在是Spring发现你的controller 需要service，就给你自动注入。</li><li>AOP编程的支持。Spring提供面向切面编程，方便的实现对程序进行拦截，运行监控等。主要通过BeanPostProcessor 的postProcessBeforeInitialization，postProcessAfterInitialization， + 动态代理实现。（有接口就用JDK的动态代理，否则CJLIB）</li><li>声明式事务的支持。只需要配置就可以实现对事务的管理，而无需手动编程。</li><li>对Junit支持，方便程序测试。<ul><li>集成了各种优秀框架，如mybatis, quartz。</li></ul></li></ul></li></ul><h3 id="在-Spring-中，Bean-是如何生成的？-x2F-bean-的生命周期"><a href="#在-Spring-中，Bean-是如何生成的？-x2F-bean-的生命周期" class="headerlink" title="在 Spring 中，Bean 是如何生成的？&#x2F; bean 的生命周期"></a>在 Spring 中，Bean 是如何生成的？&#x2F; bean 的生命周期</h3><ul><li>Spring扫描class 文件，得到BeanDefinition</li><li>根据BeanDefinition去生成bean<ul><li>根据class推断构造方法</li><li>根据构造方法，利用反射，生成对象（原始对象）。</li><li>填充对象中依赖的属性（依赖注入）</li><li>如果对象被AOP了，就需要根据原始对象生成一个代理对象。（beanPostProcessor）</li></ul></li><li>最终把生成的对象放进单例池（singleton objects），下次获取对象就直接从单例池中获取。</li></ul><h3 id="Spring的循环依赖"><a href="#Spring的循环依赖" class="headerlink" title="Spring的循环依赖"></a>Spring的循环依赖</h3><ul><li><p>循环依赖就在创建bean的过程中，A对象依赖了B对象，B对象依赖了A对象，导致A，B两个对象都创建不出来。</p><blockquote><p> ABean 创建–&gt;依赖了 B 属性–&gt;触发 BBean 创建—&gt;B 依赖了 A 属性—&gt;需要 ABean（但 ABean 还在创建过程中）</p></blockquote></li><li><p>在 Spring 中，通过<strong>三级缓存</strong>机制帮开发者解决了部分循环依赖的问题。</p><ul><li>一级缓存为：<strong>singletonObjects</strong>: 缓存已经经历了完整生命周期的 bean 对象。</li><li>二级缓存为：<strong>earlySingletonObjects</strong>: 缓存的是早期的 bean 对象。表示 Bean 的生命周期还没走完就把这个 Bean 放入了 earlySingletonObjects。</li><li>三级缓存为：<strong>singletonFactories</strong>: 缓存的是 ObjectFactory，对象工厂，用来创建早期 bean 对象的工厂。实际上是一个 Lambda 表达式， 执行lambda表达式，得到就是对应的代理对象。</li></ul></li></ul><h3 id="Spring前后置环绕异常通知"><a href="#Spring前后置环绕异常通知" class="headerlink" title="Spring前后置环绕异常通知"></a>Spring前后置环绕异常通知</h3><ul><li>before: 方法执行前执行，如果通知抛出异常，则方法无法执行。</li><li>after: 方法执行后执行，不论方法中是否抛出异常。主要用来清理现场。</li><li>around：环绕通知，方法执行前后分别执行，必须手动调用目标方法。</li><li>afterReturning: 方法执行后执行，可以获得方法的返回值，方法中抛出异常则无法执行。</li><li>afterThrowing: 方法抛出异常后执行。</li></ul><h3 id="Spring事务传播行为（多个事务存在是怎么处理的？）"><a href="#Spring事务传播行为（多个事务存在是怎么处理的？）" class="headerlink" title="Spring事务传播行为（多个事务存在是怎么处理的？）"></a>Spring事务传播行为（多个事务存在是怎么处理的？）</h3><ul><li><p>equired(需要)： 默认值。如果当前存在事务则加入这个事务，如果当前没有事务就新创建一个。</p></li><li><p>supports(支持)：如果当前存在事务，就加入这个事务，否则就以非事务的方式运行。</p></li><li><p>Mandatory(必须，强制)：如果当前存在事务，就加入这个事务，如果当前没有事务，就抛出异常。</p></li><li><p>Requires_new: 如果当前存在事务，就将该事务挂起。创建一个新的事务来运行。</p></li><li><p>Not_supported: 如果当前存在事务，就将该事务挂起。以非事务的方式运行。</p></li><li><p>never:  如果当前存在事务，就抛出异常，以非事务的方式运行。</p></li><li><p>nested(嵌套)：  如果当前存在事务，就创建一个事务当作当前事务的嵌套事务来运行，如果当前没有事务，就创建一个事务。</p><p>(加入<em>3+ 挂起</em> * 2+ 异常 * 1 + 嵌套事务 *1 s)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java知识点整理</title>
    <link href="/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><p>定义：死锁是两个或两个以上的线程互相都持有对方所需要的资源，导致这些线程都处于等待状态。</p></li><li><p>死锁产生的条件：</p><ul><li>互斥条件：一个资源只能被一个进程占用。</li><li>请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不变。</li><li>不剥夺条件：任何一个资源在没被该进程释放之前，其他线程都无法对他剥夺占用。</li><li>循环等待：当发生死锁时，所等待的线程会进入一个类似死循环，造成阻塞。</li></ul></li><li><p>如何避免</p><ul><li>设置加锁顺序。当多个线程需要一些相同的锁时，按照不同的加锁顺序去加锁。这种需要你事先知道所有的锁，但某些情况是未知的。</li><li>设置加锁时限。当一个线程在制定时限内没有获取到所需要的锁，则会释放已经获取到的锁，然后等待一段时间再重试。</li></ul></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO,BIO,AIO</title>
    <link href="/NIO-BIO-AIO/"/>
    <url>/NIO-BIO-AIO/</url>
    
    <content type="html"><![CDATA[<h3 id="1-BIO、NIO、AIO定义"><a href="#1-BIO、NIO、AIO定义" class="headerlink" title="1.BIO、NIO、AIO定义"></a>1.BIO、NIO、AIO定义</h3><p>Java共支持3种<a href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">网络编程</a>模型IO模式</p><ul><li><p><strong>BIO</strong>：(blocking io）同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器就要启动一个线程进行处理，如果这个链接不做任何事，就容易造成不必要的线程开销。当一个线程调用 <code>read()</code> 或 <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p></li><li><p><strong>NIO</strong>：(non blocking io 或 new io)异步非阻塞，NIO相对于BIO来说出现了几个核心的组件，分别是 Channle（通道） 和 Buffer（缓冲区）、Selector（选择器）  。NIO出现于JDK 1.4之后。</p><ul><li><p>Channel：NIO的所有IO操作都从Channl开始： </p><ul><li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li><li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li></ul></li><li><p>Buffer: 缓冲区的出现导致了NIO和BIO的不同：读数据时可以先读一部分到缓冲区中，然后处理其他事情；写数据时可以先写一部分到缓冲区中，然后处理其他事情。读和写操作可以不再持续，所以不会阻塞。当缓冲区满后才会将其放入真正地读&#x2F;写。</p></li></ul></li><li><p><strong>Selector</strong>：选择器可以让单个线程处理多个通道，达到复用的目的。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57mhubk5zj210y0u0acq.jpg" style="zoom:50%;" /></li><li><p><strong>AIO</strong>:异步非阻塞：AIO出现于JDK 1.7，是NIO的改进版。它的特点是由操作系统完成后，才通知服务器启动线程去处理。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识点整理</title>
    <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1-get和post的区别"><a href="#1-get和post的区别" class="headerlink" title="1. get和post的区别"></a>1. get和post的区别</h4><ul><li>表现形式<ul><li>get 请求的数据会附在url之后，以？形式分割URL和传输的数据，参数之间以&amp;连接。</li><li>post请求的数据是提交在HTTP的包体中。</li></ul></li><li>对数据长度的限制<ul><li>get是通过URl提交数据，所以他的长度受浏览器的限制</li><li>post是没有数据长度的限制的，起限制作用的是：服务器的处理能力。</li></ul></li><li>安全性<ul><li>与post相比，Get安全性较差。get提交数据的时候，用户名和密码都会明文的出现在URL上。因为登录页面有可能被浏览器缓存，所以其他人查看浏览器的记录，就可以拿到你的账户密码了。</li><li>post参数不会保留在浏览器历史中。</li></ul></li></ul><h4 id="2-http的常用方法"><a href="#2-http的常用方法" class="headerlink" title="2. http的常用方法"></a>2. http的常用方法</h4><ul><li>Get: 使用给定的URL请求资源</li><li>post：将数据发送到服务器，用来创建或者更新资源</li><li>head: 获取报文首部</li><li>Put: 传输数据，与post不同的是，他制定了资源的存放位置，post是由服务器自己决定。</li><li>Delete: 删除文件</li><li>trace: 追踪路径</li><li>permission：访问支持的方法。</li></ul><h4 id="3-TCP和UDP的区别与联系"><a href="#3-TCP和UDP的区别与联系" class="headerlink" title="3. TCP和UDP的区别与联系"></a>3. TCP和UDP的区别与联系</h4><ul><li><p>相同点：都是基于IP协议的传输协议。</p></li><li><p>不同点：</p><ul><li><p>TCP: 面向连接，传输速度慢，可靠性高（TCP在传输数据之前，都会通过三次握手来建立连接），保证数据的准确性，面向字节流</p></li><li><p>UDP: 面向无连接，传输速度快，可靠性低（尽最大可能交付，如果网络质量不好，就可能丢包），面向报文</p></li></ul></li><li><p>使用场景：</p><ul><li>TCP：对通信质量有要求的时候，比如：Http、https、FTP等传输文件的协议，SMTP等传输邮件的协议。kafka中服务端和客户端之间的通信。</li><li>UDP: 通信质量要求不高，但是要求网络通讯速度尽可能快，比如：QQ语音，QQ视频</li></ul></li><li><p>TCP存在拆包，粘包问题。因为他是面向字节流的，不向UDP那样首部有数据长度，而发送数据，是缓冲区满才会发送，容易造成粘包。接受数据，是缓冲区满了，才会接受，接受时也会造成粘包。</p><ul><li>解决拆包和粘包问题的方式：<ul><li>发送端给数据加首部</li><li>设置数据包为制定长度，不够用空格来补</li><li>给数据加分界标记</li></ul></li></ul></li></ul><h3 id="4-HTTP的长连接和短连接"><a href="#4-HTTP的长连接和短连接" class="headerlink" title="4. HTTP的长连接和短连接"></a>4. HTTP的长连接和短连接</h3><ul><li>http的长连接和短连接本质上就是：Tcp的长连接和短连接</li><li>在http1.0 中默认使用短连接，客户端和服务端每进行一次HTTP操作，就建立一次短连接，任务结束就中断。从HTTP1.0 起，默认使用长连接，当一个网页打开完成后，客户端和服务器之间用户传输HTTP数据的TCP连接就不会关闭，客户端再次访问这个服务器，会使用这一条已经建立的连接。可以设置这个保持时间。</li><li>通过心跳机制维护长连接，客户端发送一个心跳给服务器，服务器给客户一个心跳应答，这样双方就可以知道他们的连接没有断开。</li></ul><p><strong>应用场景：</strong></p><ul><li>长连接：多用于操作频繁，点对点的通讯。</li><li>短连接：web网站的Http服务一般都使用短连接，因为长连接比较耗费资源。</li></ul><h3 id="5-HTTP和HTTPs的区别"><a href="#5-HTTP和HTTPs的区别" class="headerlink" title="5. HTTP和HTTPs的区别"></a>5. HTTP和HTTPs的区别</h3><ul><li><p>Http明文传输，数据都是未加密的，安全性比较差，https（ssl+http）传输过程是加密的，安全性较好，采用混合加密算法。</p></li><li><p>Http使用80端口，https使用的是443端口</p></li><li><p>https协议需要到CA（Certificate Authority，数字证书认证机构）去申请证书，一般免费证书比较少，需要一定的费用。</p></li><li><p>https除了TCP连接响应外，还要进行SSL通信，所以通信速率较低且由于加密解密，也会消耗更多的服务器资源。</p><blockquote><ul><li><p>SSL是独立与TCP的协议，他也可用来对其他协议的加密</p></li><li><p>Https 其实就是在HTTP协议的基础上加了：通信加密，证书认证，报文完整性保护，他在所以HTTPS要比HTTP更加耗费资源。</p></li></ul></blockquote></li></ul><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><h4 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a>对称加密：</h4><ul><li>定义：服务器和客户端都拥有一把相同的钥匙，对报文的加密和解密都用的是这把钥匙。</li><li>流程：刚开始的时候B没有钥匙，A有，那A需要将钥匙发给B，在这个过程中一旦钥匙被攻击者X获取到，加密就失了意义。</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li>定义：一把共有密钥，一把私有密钥。公有密钥是公开的，任何人都可以获取，私有的不公开。发送方用公有密钥进行加密，接受方用私有密钥解密。</li><li>流程：刚开始的时候A拥有一把私有密钥和一把公有公钥，B没有公钥匙，A将公钥发给B，再将通过私有密钥加密后的内容发给B，即使攻击者窃取也只能拿到公钥和加密后的明文，所以比较安全，但是性能比较低。</li></ul><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><ul><li>http首先通过非对称加密来对对称密钥加密，当对称密钥安全传输后，双方则采取对称密钥的方式来进行传输。</li></ul><h3 id="cookie-和session-的区别和联系"><a href="#cookie-和session-的区别和联系" class="headerlink" title="cookie 和session 的区别和联系"></a>cookie 和session 的区别和联系</h3><ul><li>session是存储在服务器端的，cookie是存储在客户端的。</li><li>cookie不是很安全，因为别人可以分析你存放在本地的cookie进行cookie欺骗，考虑到安全应该放到session。</li><li>由于session存放在服务器上，所以当访问增多的时候，会比较占用服务器的性能，考虑到服务器性能，</li><li>session一般是通过cookie来实现会话跟踪的。第一次创建session的时候，服务器告诉客户端需要在cookie里记录一个session_id&#x3D;XX，之后客户端通过http请求来访问服务端的时候，都在请求里带上这个session_id，就可以告诉服务器我是谁了。如果客户端禁用cookie，就需要通过url重写的方式来记录，就是URL上附加一个sid&#x3D;XXX，这样服务器就知道你是谁了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手</title>
    <link href="/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <url>/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ol><li><p>定义：三次握手，顾名思义，就是客户端与服务端的三次通信</p></li><li><p>流程：</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57al19dnpj211a0u077e.jpg" style="zoom:50%;" /></li></ol><ul><li>第一次握手：建立连接。客户端发送请求连接报文段，然后客户端进入SYN_SEND（连接请求）状态，等待服务端的确认。</li><li>第二次握手：服务端收到客户端的SYN报文段，对这个报文段进行确认，同时，自己还要发送请求建立连接信息，服务端要将所有的信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务端进入SYN_RCVD（接受请求）状态。</li><li>第三次握手：客户端收到服务端的SYN+ACK报文段。向服务端发送ACK报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISH状态，完成TCP三次握手。</li></ul><ol start="3"><li>为什么要进行三次握手？</li></ol><p>三次握手的目的就是：建立可靠的通信渠道。确认双方的发送和接收都是正常的。</p><ul><li>第一次握手：客户端什么都不能确认，服务端能确认客户端发送数据是正常的，自己接受数据正常的。</li><li>第二次握手：客户端可以确认自己：接受和发送数据都是正常的， 服务端发送数据，接受数据是正常的。</li><li>第三次握手：服务端可以确认自己发送和接受正常，客户端发送和接受正常。</li></ul><p>假设不考虑三次握手，会出现的一种情况是：</p><p>已经实效的报文段突然传送到了主机B，因而产生错误。</p><p>考虑这样一种情况：当A发送连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次。第二个报文段到达了主机B，收到了确认，建立了连接。传输完毕后，就释放连接。       </p><p>   现假定出现另一种情况：A发送的第一个请求报文段并没有丢失，而是在某些网点滞留时间太长，以致延误到这次的连接释放后才到大主机B，本来这已经是一个已经失效的报文段，但主机B收到这个报文段，却误认为主机A又发送了一次新的请求，于是向A发送确认报文段，同意建立连接。</p><p>  主机A并没有要求建立连接，因此不会理睬主机B的确认，也不会向主机B发送数据，但主机B却以为连接已经建立，并且一直等待主机A发送数据，于是主机B的许多资源就这样被浪费了。</p><p>   而如果采用了三次连接就可以防止以上现象的发生。例如在刚才的情况下，主机A不会再向主机B的确认发送确认。主机B收不到确认，就建立不了连接。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四次挥手</title>
    <link href="/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><ol><li><p>定义：四次挥手就是客户端和服务端释放连接时的四个步骤。</p></li><li><p>产生原因：TCP连接是全双工的，因此每个方向都需要单独关闭，一方发送FIN只表示自己发完了要发送的数据。</p></li><li><p>流程：</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h578ibfbfnj20yk0qeq6p.jpg" style="zoom:50%;" /><ol><li><p>第一次挥手：当客户端不再向服务端发送数据了。客户端先向TCP发出连接释放请求，TCP通知服务端需要释放从客户端到服务端的这个连接，客户端进入FIN_WAIT-1 （终止等待状态）。</p></li><li><p>第二次挥手：服务端收到客户端的释放连接请求后，立即释放连接。这样客户端到服务端的连接就释放了，服务端进入CLOSE_WAIT（半关闭状态）。相当于客户端对服务端说：我已经发完了我要发的数据，但仍然可以接收你发的数据。</p></li><li><p>第三次挥手：当服务端不再向客户端发送数据了。服务端先向TCP发出连接释放请求，TCP通知客户端需要释放从服务端到客户端的这个连接，服务端进入LAST_WAIT（最后确认状态）。</p></li><li><p>第四次挥手：客户端收到服务端的释放请求后，进入2MSL（一个报文的来回时间）的TIME_WAIT（时间等待）状态，接着发送一个ACK给服务端，服务端进入CLOSE（关闭状态）整个连接全部释放。客户端在2MSL的TIME_WAIT后进入CLOSE状态。</p></li></ol></li></ol><p><strong>以上释放过程是4次联络，也可以看成2个2次联络。</strong></p><ol start="4"><li><p>TIME_WAIT的状态必须等待2MSL的原因？</p><ul><li><p>保证当客户端最后一个ACK丢失后，能收到服务端重传的FIN包。这个ACK报文段可能丢失，因而处于LAST_ACK状态的B可能收不到对已发送的FIN+ACK报文段的确认，服务端会超时重传这个报文段，则客户端就可以在2MSL这个时间内收到这个重传的FIN+ACK报文段。接着客户端会重传一次确认，然后启动2MSL计时器。</p></li><li><p>如果客户端在TIME_WAIT这个状态不等待一段时间，而是在发送ACK报文段后立即释放连接，那么就无法收到服务端重传的FIN+ACK报文段，因而也不会再发送一次确认报文段，B则无法按正常步骤进入CLOSED状态。（注：TIME_WAIT状态一般维持在1-4分钟）</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理的实现方式</title>
    <link href="/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>User_setting 的表结构(last_visted_project_id)+ 切面(el-&gt; app -&gt;) </p><p>动态代理： c g li b+ jdk</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">InvocationHandler</span> ： 该类必须有接口<br></code></pre></td></tr></table></figure><p> c g li b：Enhancer ：是基于<strong>父子类</strong>的，被代理类（UserService）是父类，代 </p><p>理类是子类，代理对象就是代理类的实例对象</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">invoke</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kafka设计原理</title>
    <link href="/kafka%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <url>/kafka%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka-设计原理"><a href="#Kafka-设计原理" class="headerlink" title="Kafka 设计原理"></a>Kafka 设计原理</h1><h2 id="消费者rebalance机制"><a href="#消费者rebalance机制" class="headerlink" title="消费者rebalance机制"></a>消费者rebalance机制</h2><h4 id="服务端怎么确认触发rebalance？"><a href="#服务端怎么确认触发rebalance？" class="headerlink" title="服务端怎么确认触发rebalance？"></a>服务端怎么确认触发rebalance？</h4><p>通过心跳，设置一个心跳时间，要是指定时间内没有响应，就通过心跳，下发rebalance命令到其他consumer，通知他们进行rebalance</p>]]></content>
    
    
    <categories>
      
      <category>kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka入门</title>
    <link href="/kafka%E5%85%A5%E9%97%A8/"/>
    <url>/kafka%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="kafka-是什么？"><a href="#kafka-是什么？" class="headerlink" title="kafka 是什么？"></a>kafka 是什么？</h2><p>Kafka 是一个分布式，支持分区（partition）, 多副本（replication）,基于zookeeper 的分布式消息系统。它最大的特性就是可以实时的处理大数据量。</p><p>Kafka的使用场景：</p><ul><li>日志的收集：记录各种服务的log。，通过kafka以统一接口服务的方式开放给各种 consumer，例如hadoop、Hbase、Solr等。</li><li>消息系统：解耦和生产者和消费者、缓存消息等。</li><li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和掘。</li><li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li></ul><h2 id="kafka-的整体设计"><a href="#kafka-的整体设计" class="headerlink" title="kafka 的整体设计"></a>kafka 的整体设计</h2><p>从一个较高的层面上来看，producer通过网络发送消息到Kafka集群，然后consumer来进行消费，如下图</p><blockquote><p>服务端(brokers)和客户端(producer、consumer)之间通信通过<strong>TCP协议</strong>来完成。 </p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h54w9l8j1hj21je0u0jy3.jpg"></p><p>还有几个概念：</p><ul><li><p>Producer: 消息生产者，向Broker发送消息的客户端 。</p></li><li><p>Broker: 消息中间件处理节点，一个Kafka实例就是一个broker，一个或者多个Broker可以组成一个Kafka集群。</p></li><li><p>Topic：Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic ，类似activeMq的queue</p></li><li><p>Partition: 一个topic可以分为多个partition，每个 partition内部消息是有序的.</p></li><li><p>ConsumerGroup:每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer Group消费，但是一个 </p><p>Consumer Group中只能有一个Consumer能够消费该消息</p></li><li><p>Consumer: 消息消费者，从Broker读取消息的客户端</p></li></ul><h2 id="Kafka-的基本使用"><a href="#Kafka-的基本使用" class="headerlink" title="Kafka 的基本使用"></a>Kafka 的基本使用</h2><ol><li><p>启动zookeeper <a href="https://panyurou.github.io/2021/09/22/zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/">zookeeper特性与节点介绍 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>下载并解压： <a href="https://kafka.apache.org/downloads">Apache Kafka</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cd kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure></li><li><p>修改配置文件config&#x2F;server.properties，根据需要修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">broker.id=<span class="hljs-number">0</span>     <span class="hljs-comment">//如果是单机安装则不用修改，如果是集群安装则要保证每个broker.id配置不同的值</span><br>log.dirs=/Tools/kafka_2<span class="hljs-number">.13</span>-<span class="hljs-number">2.4</span><span class="hljs-number">.1</span>/logs    <span class="hljs-comment">//日志位置，该文件夹必须存在，否则启动时会报错</span><br>zookeeper.connect=localhost:<span class="hljs-number">2181</span>     <span class="hljs-comment">//zookeeper的连接地址，多个地址用逗号分隔</span><br></code></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bin/kafka-server-start.sh -daemon  config/server.properties<br></code></pre></td></tr></table></figure><ul><li>server.properties的配置路径是一个强制的参数</li><li>­daemon表示以后台进程运行</li></ul><p><strong>我们进入zookeeper目录通过zookeeper客户端查看下zookeeper的目录树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">2</span>] ls /<br>[admin, brokers, cluster, config, consumers, controller, controller_epoch, feature, isr_change_notification, latest_producer_id_block, log_dir_event_notification, zookeeper]<br></code></pre></td></tr></table></figure><p><strong>查看kafka节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">3</span>]  ls /brokers/ids<br>[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li><li><p>停止服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bin/kafka‐server‐stop.sh<br></code></pre></td></tr></table></figure></li><li><p>创建主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --create --topic test --bootstrap-server localhost:<span class="hljs-number">9092</span><br>Created topic test.<br></code></pre></td></tr></table></figure></li><li><p>查看kafka中目前存在的topic </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span>  bin/kafka-topics.sh --list --bootstrap-server localhost:<span class="hljs-number">9092</span><br>test<br></code></pre></td></tr></table></figure></li><li><p>发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-console-producer.sh --topic test --bootstrap-server localhost:<span class="hljs-number">9092</span><br>&gt;my first event<br>&gt;my second event<br></code></pre></td></tr></table></figure></li><li><p>消费消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-console-consumer.sh --topic test --from-beginning --bootstrap-server localhost:<span class="hljs-number">9092</span><br><br>my first event<br>my second event<br></code></pre></td></tr></table></figure><blockquote><p>–from-beginning 可选，加上的话，就可以收到历史已经发送的数据。默认不加的话，是消费最新的消息</p></blockquote></li><li><p>单播消费</p><ul><li>一条消息只能被某一个消费者消费的模式。类似queue模式。</li><li>只需让所有消费者在同一个消费组里即可。</li></ul><p>分别在两个客户端执行如下消费命令，然后往主题里发送消息，结果只有一个客户端能收到消息 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-console-consumer.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --consumer-property group.id=group1 --topic test<br></code></pre></td></tr></table></figure></li><li><p>多播消费</p><ul><li>一条消息能被多个消费者消费的模式，类似publish-subscribe模式。</li><li>针对Kafka同一条消息只能被同一个消费组下的某一个消费者消费的特性，要实现多播只要保证这些消费者属于不同的消费组即可。</li><li>我们再增加一个消费者，该消费者属于group2消费组，结果两个客户端都能收到消息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java'">➜  kafka_2.12-3.2.1 bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --consumer-property group.id=group2 --topic test<br></code></pre></td></tr></table></figure></li><li><p>查看消费组名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-consumer-groups.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --list<br>testGroup1<br>group2<br>group1<br></code></pre></td></tr></table></figure></li><li><p>查看消费组的消费偏移量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-consumer-groups.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --describe --group group1<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h554bsqyijj222a066jsz.jpg" style="zoom: 100%;" /><ul><li>current-offset：当前消费组的已消费偏移量</li><li>log-end-offset：主题对应分区消息的结束偏移量(HW) </li><li>lag：当前消费组未消费的消息数</li></ul></li></ol><h2 id="Topic-和-partition-详解"><a href="#Topic-和-partition-详解" class="headerlink" title="Topic 和 partition 详解"></a>Topic 和 partition 详解</h2><ul><li><p>topic 是一个类别的名称，同类消息，发送到一个topic下，对于每一个topic可以有多个分区(partition)。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h55j4kirf2j215i0oi0v5.jpg" style="zoom:30%;" /></li><li><p>partition 是一个有序的message序列，这些message将按顺序添加到commitlog文件中。一个partition 对应一个commit log 文件，对应存放在配置的log文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> cd /tmp/kafka-logs<br>➜  kafka-logs cd test-<span class="hljs-number">0</span><br>➜  test-<span class="hljs-number">0</span> ls<br><span class="hljs-number">00000000000000000000.</span>index     <span class="hljs-number">00000000000000000000.</span>timeindex partition.metadata<br><span class="hljs-number">00000000000000000000.</span>log       leader-epoch-checkpoint<br>➜  test-<span class="hljs-number">0</span> cat <span class="hljs-number">00000000000000000000.</span>log<br>F_:�����<span class="hljs-number">6</span>����<span class="hljs-number">6</span>�(my first eventG�����������*my second event&gt;I=;���R����R�<br></code></pre></td></tr></table></figure></li><li><p>每个partion 中的消息都有一个唯一的编号，叫做offset，用来标识这条消息。</p></li><li><p>创建多个分区的主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --create --topic test2 --bootstrap-server localhost:<span class="hljs-number">9092</span> ‐‐replication‐factor <span class="hljs-number">1</span> ‐‐partitions <span class="hljs-number">2</span><br>Created topic test2.<br></code></pre></td></tr></table></figure></li><li><p>查看下topic的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --describe --topic test2<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h556vki097j21hy04q0tz.jpg" style="zoom:150%;" /><ul><li>leader节点负责给定partition的所有读写请求。</li><li>replicas 表示某个partition在哪几个broker上存在备份。不管这个几点是不是”leader“，甚至这个节点挂了，也会列出。</li><li>isr**(InSyncRepli)** ：leader副本保持一定同步程度的副本（包括leader）组成ISR。是replicas的一个子集。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka集群</title>
    <link href="/kafka%E9%9B%86%E7%BE%A4/"/>
    <url>/kafka%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="kafka-集群"><a href="#kafka-集群" class="headerlink" title="kafka 集群"></a>kafka 集群</h1><h2 id="集群配置流程"><a href="#集群配置流程" class="headerlink" title="集群配置流程"></a>集群配置流程</h2><ol><li><p>编写配置文件</p><ul><li><p><code>vim config/server.properties</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">broker</span>.id=<span class="hljs-number">0</span>     //如果是单机安装则不用修改，如果是集群安装则要保证每个broker.id配置不同的值<br><span class="hljs-attribute">listeners</span>=PLAINTEXT://localhost:<span class="hljs-number">9092</span> <br><span class="hljs-attribute">log</span>.dirs=/Tools/kafka_<span class="hljs-number">2</span>.<span class="hljs-number">13</span>-<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>/logs    //日志位置，该文件夹必须存在，否则启动时会报错<br><span class="hljs-attribute">zookeeper</span>.connect=localhost:<span class="hljs-number">2181</span>     //zookeeper的连接地址，多个地址用逗号分隔<br></code></pre></td></tr></table></figure></li></ul></li><li><p>建立好其他2个broker的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">cp config/server.properties config/server‐<span class="hljs-number">1.</span>properties<br>cp config/server.properties config/server‐<span class="hljs-number">2.</span>properties<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">broker</span>.id=<span class="hljs-number">1</span>     //如果是单机安装则不用修改，如果是集群安装则要保证每个broker.id配置不同的值<br><span class="hljs-attribute">listeners</span>=PLAINTEXT://localhost:<span class="hljs-number">9093</span> <br><span class="hljs-attribute">log</span>.dirs=/Tools/kafka_<span class="hljs-number">2</span>.<span class="hljs-number">13</span>-<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>/logs-<span class="hljs-number">1</span>    //日志位置，该文件夹必须存在，否则启动时会报错<br><span class="hljs-attribute">zookeeper</span>.connect=localhost:<span class="hljs-number">2181</span>     //zookeeper的连接地址，多个地址用逗号分隔<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">broker</span>.id=<span class="hljs-number">2</span>     //如果是单机安装则不用修改，如果是集群安装则要保证每个broker.id配置不同的值<br><span class="hljs-attribute">listeners</span>=PLAINTEXT://localhost:<span class="hljs-number">9094</span> <br><span class="hljs-attribute">log</span>.dirs=/Tools/kafka_<span class="hljs-number">2</span>.<span class="hljs-number">13</span>-<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>/logs-<span class="hljs-number">2</span>    //日志位置，该文件夹必须存在，否则启动时会报错<br><span class="hljs-attribute">zookeeper</span>.connect=localhost:<span class="hljs-number">2181</span>     //zookeeper的连接地址，多个地址用逗号分隔<br></code></pre></td></tr></table></figure></li><li><p>分别启动broker实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-server-start.sh -daemon config/server.properties<br>➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-server-start.sh -daemon config/server-<span class="hljs-number">1.</span>properties<br>➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-server-start.sh -daemon config/server-<span class="hljs-number">2.</span>properties<br></code></pre></td></tr></table></figure></li><li><p>查看zookeeper确认集群节点是否都注册成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">19</span>]  ls /brokers/ids<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure></li></ol><h2 id="集群使用"><a href="#集群使用" class="headerlink" title="集群使用"></a>集群使用</h2><ol><li><p>创建一个新的topic，副本数设置为3，分区数设置为2： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --create --replication-factor <span class="hljs-number">3</span> --partitions <span class="hljs-number">2</span> --topic test6<br></code></pre></td></tr></table></figure></li><li><p>查看下topic的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --describe --topic test6<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h55ml5a5aej21hg060myn.jpg"></p></li><li><p>向新建的 test6 中发送一些message，kafka集群可以加上所有kafka节点</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">➜  kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">3.2</span>.<span class="hljs-number">1</span>  bin/kafka-console-producer.<span class="hljs-keyword">sh</span> ‐‐broker‐<span class="hljs-keyword">list</span> localhos<span class="hljs-variable">t:9092</span>,localhos<span class="hljs-variable">t:9093</span>,localhos<span class="hljs-variable">t:9094</span> --topic test6  --bootstrap-server localhos<span class="hljs-variable">t:9092</span><br>&gt;my test msg <span class="hljs-number">1</span><br>&gt;my test msg <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>开始消费</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">➜  kafka_2.12-3.2.1 bin/kafka-console-consumer.<span class="hljs-keyword">sh</span> --topic test6 --from-beginning --<span class="hljs-keyword">bootstrap</span>-server localhost:9092,localhost:9093,localhost:9094<br>my <span class="hljs-keyword">test</span> msg 1<br>my <span class="hljs-keyword">test</span> msg 2<br></code></pre></td></tr></table></figure></li><li><p>测试容错性，目前broker2 是分区0的leader，现在将他kill</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> ps -ef|grep server‐<span class="hljs-number">2.</span>properties<br>➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> kill -<span class="hljs-number">9</span> <span class="hljs-number">80024</span><br></code></pre></td></tr></table></figure></li><li><p>再次查看topic的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  kafka_2<span class="hljs-number">.12</span>-<span class="hljs-number">3.2</span><span class="hljs-number">.1</span> bin/kafka-topics.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --describe --topic test6<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h56bu8415bj21h405sabk.jpg"></p><p>可以看到，此时分区0的leader变成了broker1，在isr中也已经没有了2号节点。</p></li></ol><p>  此时，依旧可以消费消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h56bycarv6j21gq09cjtm.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
      <tag>消息队列</tag>
      
      <tag>集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之Config+Bus</title>
    <link href="/springCloud%E4%B9%8BConfig-Bus/"/>
    <url>/springCloud%E4%B9%8BConfig-Bus/</url>
    
    <content type="html"><![CDATA[<h1 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h1><ul><li><p>在微服务架构的系统中，通常会使用<strong>轻量级的消息代理</strong>来构建一个公用的<strong>消息主题</strong>，并让系统中的所有实例都连接上来。由于该<strong>主题的消息会被所有实例监听和消费</strong>，所以称之为消息总线。</p></li><li><p>在总线上的各个实例，都可以方便的广播一些让其他连接在给主题实例上都知道的消息。</p></li></ul><h1 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h1><ul><li><p>Spring Cloud Bus 又被称为消息总线，它能够通过轻量级的消息代理（例如 RabbitMQ、Kafka 等）将微服务架构中的各个服务连接起来，实现广播状态更改、事件推送等功能，还可以实现微服务之间的通信功能。</p></li><li><p>目前 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka。</p></li></ul><h2 id="Spring-Cloud-Bus-的基本原理"><a href="#Spring-Cloud-Bus-的基本原理" class="headerlink" title="Spring Cloud Bus 的基本原理"></a>Spring Cloud Bus 的基本原理</h2><ul><li>Spring Cloud Bus 会使用一个轻量级的消息代理来构建一个公共的消息主题 Topic（默认为“springCloudBus”），<strong>这个 Topic 中的消息会被所有服务实例监听和消费</strong>。</li><li>当其中的一个服务刷新数据时，Spring Cloud Bus 会把信息保存到 Topic 中，这样监听这个 Topic 的服务就收到消息并自动消费。</li></ul><h2 id="Spring-Cloud-Bus-动态刷新配置的原理"><a href="#Spring-Cloud-Bus-动态刷新配置的原理" class="headerlink" title="Spring Cloud Bus 动态刷新配置的原理"></a>Spring Cloud Bus 动态刷新配置的原理</h2><ul><li><p>当 Git 仓库中的配置发生了改变，我们只需要向某一个服务（既可以是 Config 服务端，也可以是 Config 客户端）发送一个 POST 请求，Spring Cloud Bus 就可以通过消息代理通知其他服务重新拉取最新配置，以实现配置的动态刷新。</p></li><li><p>利用 Spring Cloud Bus 的特殊机制可以实现很多功能，其中配合 Spring Cloud Config 实现配置的动态刷新就是最典型的应用场景之一。</p></li></ul><h2 id="Spring-Cloud-Bus-整合Spring-Cloud-Config实现配置的动态刷新"><a href="#Spring-Cloud-Bus-整合Spring-Cloud-Config实现配置的动态刷新" class="headerlink" title="Spring Cloud Bus 整合Spring Cloud Config实现配置的动态刷新"></a>Spring Cloud Bus 整合Spring Cloud Config实现配置的动态刷新</h2><ol><li>当 Git 仓库中的配置发生改变后，运维人员向 Config 服务端发送一个 POST 请求，请求路径为“&#x2F;actuator&#x2F;refresh”。</li><li>Config 服务端接收到请求后，会将该请求转发给服务总线 Spring Cloud Bus。</li><li>Spring Cloud Bus 接到消息后，会通知给所有 Config 客户端。</li><li>Config 客户端接收到通知，请求 Config 服务端拉取最新配置。</li><li>所有 Config 客户端都获取到最新的配置。</li></ol>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud集成consul</title>
    <link href="/SpringCloud%E9%9B%86%E6%88%90consul/"/>
    <url>/SpringCloud%E9%9B%86%E6%88%90consul/</url>
    
    <content type="html"><![CDATA[<h1 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h1><ul><li><p>Consul 是一套开源的分布式服务发现和配置管理系统，由HashCorp公司用Go语言开发</p></li><li><p>它提供了几个关键功能：</p><ul><li>服务发现：Consul client 可以提供服务，例如api或mysql，也可以使用Consul client来发现指定服务的提供者。 使用DNS或HTTP，应用程序可以轻松找到他们所依赖的服务。</li><li>健康检查：Consul client 可以提供任何数量的健康检查，或者与给定的服务（“Web服务器是否返回200 OK”），或与本地节点（“内存利用率是否低于90％”）相关联。 可以使用此信息来监控集群运行状况，服务发现组件使用此信息将流量从有问题的主机中移除出去。</li><li>KV Store：应用程序可以使用Consul的分层键&#x2F;值存储，包括动态配置，功能标记，协调，leader选举等等。 简单的HTTP API使其易于使用。</li><li>多数据中心：Consul支持多个数据中心。 这意味着Consul的用户不必担心构建额外的抽象层以扩展到多个区域。</li></ul></li><li><p>使用场景</p><p>Consul的应用场景包括服务发现、服务隔离、服务配置：</p><ul><li><p>服务发现场景中consul作为注册中心，服务地址被注册到consul中以后，可以使用consul提供的dns、http接口查询，consul支持health check。</p></li><li><p>服务隔离场景中consul支持以服务为单位设置访问策略，能同时支持经典的平台和新兴的平台，支持tls证书分发，service-to-service加密。</p></li><li><p>服务配置场景中consul提供key-value数据存储功能，并且能将变动迅速地通知出去，通过工具consul-template可以更方便地实时渲染配置文件。</p></li></ul></li></ul><h1 id="SpringCloud集成consul"><a href="#SpringCloud集成consul" class="headerlink" title="SpringCloud集成consul"></a>SpringCloud集成consul</h1><p><a href="https://www.springcloud.cc/spring-cloud-consul.html">Spring Cloud Consul 中文文档 参考手册 中文版</a></p><h2 id="1-consul-安装和启动"><a href="#1-consul-安装和启动" class="headerlink" title="1. consul 安装和启动"></a>1. consul 安装和启动</h2><p>参考<a href="https://learn.hashicorp.com/tutorials/consul/get-started-install">Install Consul | Consul - HashiCorp Learn</a></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">➜  ~ consul agent -<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>访问<a href="http://localhost:8500/">http://localhost:8500/</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fjegc3rcj21xz0u0ad8.jpg"></p><h2 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2. 引入依赖"></a>2. 引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">plugins&#123;<br>id &#x27;org.springframework.boot&#x27; version &#x27;2.6.1&#x27;<br>id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.8.RELEASE&#x27;<br>id &#x27;java&#x27;<br>&#125;<br><br>ext &#123;<br>set(&#x27;springCloudVersion&#x27;, &quot;2021.0.0&quot;)<br>name = &#x27;Eureka Server&#x27;<br>description = &#x27;Eureka Server demo project&#x27;<br>version=&#x27;0.0.1-SNAPSHOT&#x27;<br>sourceEncoding=&#x27;UTF-8&#x27;<br>&#125;<br><br>repositories &#123;<br>mavenCentral()<br>maven &#123; url &#x27;https://repo.spring.io/release/&#x27; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-snapshot-local&quot; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-milestone-local&quot; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-release-local&quot; &#125;<br>maven &#123; url &quot;https://repo.springsource.org/plugins-release&quot; &#125;<br>&#125;<br><br>dependencyManagement &#123;<br>imports &#123;<br>mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;<br>&#125;<br>&#125;<br><br>dependencies &#123;<br>//consul 依赖<br>implementation &#x27;org.springframework.cloud:spring-cloud-starter-consul-discovery&#x27;<br>implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.  修改配置文件"></a>3.  修改配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=9091<br><br>spring.application.name= micro-weather-consul<br>spring.cloud.consul.host= localhost<br>spring.cloud.consul.port= 8500<br>spring.cloud.consul.discovery.service-name= $&#123;spring.application.name&#125;<br># 打开心跳机制<br>spring.cloud.consul.discovery.heartbeat.enabled= true<br></code></pre></td></tr></table></figure><h3 id="3-修改启动类"><a href="#3-修改启动类" class="headerlink" title="3. 修改启动类"></a>3. 修改启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>再次访问<a href="http://localhost:8500/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0micro-weather-consul%E6%9C%8D%E5%8A%A1%E5%B7%B2%E7%BB%8F%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F">http://localhost:8500/，可以看到micro-weather-consul服务已经注册成功</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fk8xt9m6j22190u0dj3.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>注册中心</tag>
      
      <tag>consul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud之gateway</title>
    <link href="/SpringCloud%E4%B9%8Bgateway/"/>
    <url>/SpringCloud%E4%B9%8Bgateway/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h1><ul><li>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，用来取代Zuul网关。</li><li>Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty。高并发和非阻塞通信就非常有优势</li><li>在Zulu2 中，zuul的技术方案一直在跳票，spring cloud 自己开发了一个网关替换zuu l</li><li>Spring Cloud Gateway目标提供统一的路由方式，且基于filter链提供了网关基本功能，例如安全，监控&#x2F;指标，限流</li></ul><h2 id="Spring-Cloud-Gateway-核心概念"><a href="#Spring-Cloud-Gateway-核心概念" class="headerlink" title="Spring Cloud Gateway 核心概念"></a>Spring Cloud Gateway 核心概念</h2><ul><li>Route（路由）： 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。</li><li>Predicate（断言）:路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，<strong>如果请求与断言匹配成功，则将请求转发到相应的服务。</strong></li><li>Filter（过滤器）:过滤器，使用过滤器，我们可以对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。</li></ul><p><strong>注意：其中 Route 和 Predicate 必须同时声明。</strong></p><p>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由 RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言 的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters 是各种过滤器，用来对请求做各种判断和修改。</p><h2 id="Spring-Cloud-Gateway-特性"><a href="#Spring-Cloud-Gateway-特性" class="headerlink" title="Spring Cloud Gateway 特性"></a>Spring Cloud Gateway 特性</h2><ul><li>基于 Spring Framework 5、Project Reactor 和 Spring Boot 2.0 构建。</li><li>能够在任意请求属性上匹配路由。</li><li>predicates（断言） 和 filters（过滤器）是特定于路由的。</li><li>集成了 Hystrix 熔断器。</li><li>集成了 Spring Cloud DiscoveryClient（服务发现客户端）。</li><li>易于编写断言和过滤器。</li><li>能够限制请求频率。</li><li>能够重写请求路径。</li></ul><h2 id="Gateway-的工作流程"><a href="#Gateway-的工作流程" class="headerlink" title="Gateway 的工作流程"></a>Gateway 的工作流程</h2><p><strong>核心逻辑：路由转发+执行过滤器</strong></p><ol><li><p>客户端将请求发送到 Spring Cloud Gateway 上。</p></li><li><p>Spring Cloud Gateway 通过 Gateway Handler Mapping 找到与请求相匹配的路由，将其发送给 Gateway Web Handler。</p></li><li><p>Gateway Web Handler 通过指定的过滤器链（Filter Chain），将请求转发到实际的服务节点中，执行业务逻辑返回响应结果。</p></li><li><p>过滤器之间用虚线分开是因为过滤器可能会在转发请求之前（pre）或之后（post）执行业务逻辑。</p></li><li><p>过滤器（Filter）可以在请求被转发到服务端前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等。</p></li><li><p>过滤器可以在响应返回客户端之前，对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等。</p></li><li><p>响应原路返回给客户端。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5gj9e5wjij20pq0qcgmo.jpg" style="zoom:50%;" /></li></ol><h2 id="Spring-Cloud-Gateway-动态路由"><a href="#Spring-Cloud-Gateway-动态路由" class="headerlink" title="Spring Cloud Gateway 动态路由"></a>Spring Cloud Gateway 动态路由</h2><p>默认情况下，Spring Cloud Gateway 会根据服务注册中心（例如 Eureka Server）中维护的服务列表，以服务名（spring.application.name）作为路径创建动态路由进行转发，从而实现动态路由功能。</p><p>我们可以在配置文件中，将 Route 的 uri 地址修改为以下形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">lb:<span class="hljs-comment">//service-name</span><br></code></pre></td></tr></table></figure><p>以上配置说明如下：</p><ul><li>lb：uri 的协议，表示开启 Spring Cloud Gateway 的负载均衡功能。</li><li>service-name：服务名，Spring Cloud Gateway 会根据它获取到具体的微服务地址。</li></ul><h1 id="SpringCloud-使用GateWay"><a href="#SpringCloud-使用GateWay" class="headerlink" title="SpringCloud 使用GateWay"></a>SpringCloud 使用GateWay</h1><ol><li><p>搭建Eureka Client : <a href="https://panyurou.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-gateway&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>修改application.yml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml">server:<br>  port: 9090<br>spring:<br>  application:<br>    name: micro-weather-eureka-client-gateway<br>  cloud:<br>    gateway: #网关路由配置<br>      routes:<br>        #将 micro-service-cloud-provider-dept-8001 提供的服务隐藏起来，不暴露给客户端，只给客户端暴露 API 网关的地址 9527<br>        - id: micro_weather_eureka_client_path #路由 id,没有固定规则，但唯一，建议与服务名对应<br>          uri: http://localhost:9091         #匹配后提供服务的路由地址<br>          predicates:<br>            #以下是断言条件，必选全部符合条件<br>            - Path=/test/**               #断言，路径匹配 注意：Path 中 P 为大写<br>            - Method=GET #只能时 GET 请求时，才能访问<br>eureka:<br>  client:<br>    fetch-registry: true<br>    register-with-eureka: true<br>    service-url:<br>      defaultZone: http://localhost:8761//eureka/<br></code></pre></td></tr></table></figure></li><li><p>修改启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>可以看到根据路由匹配，通过<a href="http://localhost:9090/%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BA%86http://localhost:9091/%E7%9A%84%E6%8E%A5%E5%8F%A3">http://localhost:9090/访问到了http://localhost:9091/的接口</a></p><p>访问<a href="http://localhost:9091/test/%E5%BC%A0%E4%B8%89">localhost:9091&#x2F;test&#x2F;张三</a></p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5gjhkg8tkj20ii05u74i.jpg" style="zoom:50%;" /><p>访问<a href="http://localhost:9090/test/%E5%BC%A0%E4%B8%89">localhost:9090&#x2F;test&#x2F;张三</a></p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5gjgixj2wj20iw066dg2.jpg" style="zoom:50%;" /></li></ol><p><strong>Spring Cloud Gateway 动态路由</strong></p><p>修改application.yml 的配置，使用注册中心中的微服务名创建动态路由进行转发</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5gjtqzp2gj21aj0u0wj8.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gateWay</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之Eureka集群搭建</title>
    <link href="/springCloud%E4%B9%8BEureka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/springCloud%E4%B9%8BEureka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="springCloud之Eureka集群搭建"><a href="#springCloud之Eureka集群搭建" class="headerlink" title="springCloud之Eureka集群搭建"></a>springCloud之Eureka集群搭建</h1><h2 id="1-搭建3个Eureka-server"><a href="#1-搭建3个Eureka-server" class="headerlink" title="1. 搭建3个Eureka server"></a>1. 搭建3个Eureka server</h2><ul><li><p>参考：<a href="https://panyurou.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>三个eureka-server的application.yml文件如下：</p><ul><li><p>eureka-server</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port: 8761<br><br>eureka.instance.hostname: localhost<br>#false表示不向注册中心注册自己。<br>eureka.client.registerWithEureka: false<br> #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务<br>eureka.client.fetchRegistry: false<br>#eureka.client.serviceUrl.defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/<br>eureka.client.serviceUrl.defaultZone: http://eureka8762.com:8762/eureka/,http://eureka8763.com:8763/eureka/<br></code></pre></td></tr></table></figure></li><li><p>eureka-server1</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port: 8762<br>spring.application.name = micro-weather-eureka-server2<br><br>eureka.instance.hostname: localhost<br>eureka.client.registerWithEureka: false<br>eureka.client.fetchRegistry: false<br>eureka.client.serviceUrl.defaultZone: http://eureka8761.com:8761/eureka/,http://eureka8763.com:8763/eureka/<br></code></pre></td></tr></table></figure></li><li><p>eureka-server2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port: 8763<br>spring.application.name = micro-weather-eureka-server1<br><br>eureka.instance.hostname: localhost<br>eureka.client.registerWithEureka: false<br>eureka.client.fetchRegistry: false<br>eureka.client.serviceUrl.defaultZone: http://eureka8761.com:8761/eureka/,http://eureka8762.com:8762/eureka/<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-配置三个hostname"><a href="#2-配置三个hostname" class="headerlink" title="2.配置三个hostname"></a>2.配置三个hostname</h2><p>sudo vim &#x2F;etc&#x2F;hosts</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">127.0.0.1       eureka8761.com<br>127.0.0.1       eureka8762.com<br>127.0.0.1       eureka8763.com<br></code></pre></td></tr></table></figure><h2 id="3-启动三个eureka-server，并访问"><a href="#3-启动三个eureka-server，并访问" class="headerlink" title="3. 启动三个eureka-server，并访问"></a>3. 启动三个eureka-server，并访问</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fas7jqlnj21vc0u0wjx.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fassbxfuj21uk0u00xx.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fat91b5gj21uu0u0wjo.jpg"></p><p>注意⚠️：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fauhebrjj228k09udgs.jpg"></p><ul><li><p>这里的意思就是这两个注册中心是当前注册中心的集群节点，当前注册中心会从这两个节点同步服务</p></li><li><p>这里是通过hostname辨别的，所以配置yml参数的时候需要配置不同的hostname。</p></li><li><p>这里有显示配置的集群节点，就证明集群配置成功了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>eureka</tag>
      
      <tag>集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成zookeeper</title>
    <link href="/springCloud%E4%B9%8B%E9%9B%86%E6%88%90zookeeper/"/>
    <url>/springCloud%E4%B9%8B%E9%9B%86%E6%88%90zookeeper/</url>
    
    <content type="html"><![CDATA[<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><ul><li>zookeeper基本概念：<a href="https://panyurou.github.io/2021/09/22/zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/">zookeeper特性与节点介绍 - 楼上有只喵 (panyurou.github.io)</a></li><li>zookeeper 是一个分布式协调服务，可以用来实现注册中心功能，类似eureka</li><li>服务节点是临时结点</li></ul><h1 id="springCloud之集成zookeeper"><a href="#springCloud之集成zookeeper" class="headerlink" title="springCloud之集成zookeeper"></a>springCloud之集成zookeeper</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>启动zookeeper</p><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml">plugins&#123;<br>id &#x27;org.springframework.boot&#x27; version &#x27;2.6.1&#x27;<br>id &#x27;io.spring.dependency-management&#x27; version &#x27;1.0.8.RELEASE&#x27;<br>id &#x27;java&#x27;<br>&#125;<br><br>ext &#123;<br>set(&#x27;springCloudVersion&#x27;, &quot;2021.0.0&quot;)<br>name = &#x27;Eureka Server&#x27;<br>description = &#x27;Eureka Server demo project&#x27;<br>version=&#x27;0.0.1-SNAPSHOT&#x27;<br>sourceEncoding=&#x27;UTF-8&#x27;<br>&#125;<br><br>repositories &#123;<br>mavenCentral()<br>maven &#123; url &#x27;https://repo.spring.io/release/&#x27; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-snapshot-local&quot; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-milestone-local&quot; &#125;<br>maven &#123; url &quot;https://repo.spring.io/libs-release-local&quot; &#125;<br>maven &#123; url &quot;https://repo.springsource.org/plugins-release&quot; &#125;<br>&#125;<br><br>dependencyManagement &#123;<br>imports &#123;<br>mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;<br>&#125;<br>&#125;<br><br>dependencies &#123;<br>implementation &#x27;org.springframework.cloud:spring-cloud-starter-zookeeper-discovery&#x27;<br>implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27;<br>&#125;<br><br>test&#123;<br>useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h2><ul><li>配置服务的名称和zookeeper的地址</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=9091<br><br>spring.application.name: micro-weather-zookeeper<br>spring.cloud.zookeeper.connect-string: localhost:2181<br></code></pre></td></tr></table></figure><h2 id="3-修改启动类"><a href="#3-修改启动类" class="headerlink" title="3. 修改启动类"></a>3. 修改启动类</h2><ul><li>加上@EnableDiscoveryClient注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-进入zookeeper客户端，查看已经注册的服务"><a href="#4-进入zookeeper客户端，查看已经注册的服务" class="headerlink" title="4.进入zookeeper客户端，查看已经注册的服务"></a>4.进入zookeeper客户端，查看已经注册的服务</h2><p>可以看到 micro-weather-zookeeper服务已经存在，SpringCloud以[Zookeeper]为注册中心整合成功</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fhw2g43sj21ew0dk0wm.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>注册中心</tag>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud集成Ribbon</title>
    <link href="/SpringCloud%E9%9B%86%E6%88%90Ribbon/"/>
    <url>/SpringCloud%E9%9B%86%E6%88%90Ribbon/</url>
    
    <content type="html"><![CDATA[<h1 id="负载均衡（load-balance）"><a href="#负载均衡（load-balance）" class="headerlink" title="负载均衡（load balance）"></a>负载均衡（load balance）</h1><ul><li>简单来说负载均衡就是将客户的请求平摊到多个服务上，从而达到系统的高可用，常用的负载均衡方式有Nginx，F5</li><li>常见的负载均衡方式有两种：<ul><li>服务端负载均衡</li><li>客户端负载均衡</li></ul></li></ul><h2 id="服务端负载均衡"><a href="#服务端负载均衡" class="headerlink" title="服务端负载均衡"></a>服务端负载均衡</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>服务端负载均衡是最常见的负载均衡方式，其工作原理如下图。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5gfl3w6dij21c80esgmc.jpg"></p><ul><li>在客户端和服务端之间建立一个独立的负载均衡服务器，该服务器既可以是硬件设备（例如 F5），也可以是软件（例如 Nginx）</li><li>这个负载均衡服务器维护了一份可用服务端清单，然后通过心跳机制来删除故障的服务端节点，以保证清单中的所有服务节点都是可以正常访问的。</li><li>当客户端发送请求时，该请求不会直接发送到服务端进行处理，而是全部交给负载均衡服务器，由负载均衡服务器按照某种算法（例如轮询、随机等），从其维护的可用服务清单中选择一个服务端，然后进行转发。</li></ul><h3 id="服务端负载均衡的特点"><a href="#服务端负载均衡的特点" class="headerlink" title="服务端负载均衡的特点"></a>服务端负载均衡的特点</h3><p>服务端负载均衡具有以下特点：</p><ul><li>需要建立一个独立的负载均衡服务器。</li><li>负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。</li><li>可用服务端清单存储在负载均衡服务器上。</li></ul><h2 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h2><p>相较于服务端负载均衡，客户端服务是将负载均衡逻辑以代码的形式封装到客户端上</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>客户端负载均衡的工作原理如下图。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5gfnxge7ij21cu0iy0ub.jpg"></p><ul><li>客户端通过服务注册中心（例如 Eureka Server）获取到一份服务端提供的可用服务清单。</li><li>有了服务清单后，负载均衡器会在客户端发送请求前通过负载均衡算法（如简单轮训，随机连接等）选择一个服务端实例再进行访问</li><li>客户端负载均衡也需要心跳机制去维护服务端清单的有效性，这个过程需要配合服务注册中心一起完成。</li></ul><h3 id="客户端负载均衡的特点："><a href="#客户端负载均衡的特点：" class="headerlink" title="客户端负载均衡的特点："></a>客户端负载均衡的特点：</h3><ul><li><p>负载均衡器位于客户端，不需要单独搭建一个负载均衡服务器。</p></li><li><p>负载均衡是在客户端发送请求前进行的，因此客户端清楚地知道是哪个服务端提供的服务。</p></li><li><p>客户端都维护了一份可用服务清单，而这份清单都是从服务注册中心获取的。</p></li></ul><h2 id="Ribbon和Nginx实现负载均衡的区别"><a href="#Ribbon和Nginx实现负载均衡的区别" class="headerlink" title="Ribbon和Nginx实现负载均衡的区别"></a>Ribbon和Nginx实现负载均衡的区别</h2><ul><li>Ribbon 就是一个基于 HTTP 和 TCP 的客户端负载均衡器，当我们将 Ribbon 和 Eureka 一起使用时，Ribbon 会从 Eureka Server（服务注册中心）中获取服务端列表，然后通过负载均衡策略（如简单轮训，随机连接等），从服务端列表选择一个服务实例进行访问，从而达到负载均衡的目的。</li><li>而Nginx是服务端负载均衡，客户端的所有请求会交给Nginx，然后Nginx实现转发请求</li></ul><h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><ul><li>ribbon是Netflix开发的一款负载均衡的服务调用组件，具有多种负载均衡调用策略； </li><li>Ribbon 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Ribbon 的二次封装。通过它，我们可以将面向服务的 RestTemplate请求转换为客户端负载均衡的服务调用。</li><li>简单来说，rubbon &#x3D; 负载均衡+ restTemplate</li></ul><h1 id="Ribbon-实现服务调用"><a href="#Ribbon-实现服务调用" class="headerlink" title="Ribbon 实现服务调用"></a>Ribbon 实现服务调用</h1><ol><li><p>搭建Eureka Client : <a href="https://panyurou.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;org.springframework.cloud:spring-cloud-starter-netflix-ribbon&#x27;<br></code></pre></td></tr></table></figure></li><li><p>修改application.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=8085<br>spring.application.name: micro-weather-eureka-client-ribbon<br>eureka.client.serviceUrl.defaultZone: http://localhost:8761//eureka/<br></code></pre></td></tr></table></figure></li><li><p>修改启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建一个名为 RestConfiguration 的配置类，将 RestTemplate 注入到容器中，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.config;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.client.RestTemplateBuilder;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfiguration</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RestTemplateBuilder restTemplateBuilder;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@LoadBalanced</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> restTemplateBuilder.build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建一个CityController来实现通过restTemplate对服务的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityController</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>  <span class="hljs-comment">//面向微服务编程，即通过微服务的名称来获取调用地址</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REST_URL_PREFIX = <span class="hljs-string">&quot;http://micro-weather-city-eureka&quot;</span>;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="hljs-string">&quot;/cities&quot;</span>, String.class);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>访问[localhost:8085&#x2F;cities，可以获取到指定服务接口的返回</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fwyit95lj21pw0rq19k.jpg"></p></li></ol><h1 id="Ribbon-实现负载均衡"><a href="#Ribbon-实现负载均衡" class="headerlink" title="Ribbon 实现负载均衡"></a>Ribbon 实现负载均衡</h1><p>java -jar msa-weather-city-eureka-0.0.1-SNAPSHOT.jar –server.port&#x3D;8084</p><p>java -jar msa-weather-city-eureka-0.0.1-SNAPSHOT.jar –server.port&#x3D;8083</p><p>java -jar msa-weather-city-eureka-0.0.1-SNAPSHOT.jar –server.port&#x3D;8086</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fx0ogvwhj21we0u0wl7.jpg"></p><p>再次访问<a href="http://localhost:8085/cities">localhost:8085&#x2F;cities</a></p>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>负载均衡</tag>
      
      <tag>Ribbon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAP原则以及eureka和zookeeper的对比</title>
    <link href="/CAP%E5%8E%9F%E5%88%99%E4%BB%A5%E5%8F%8Aeureka%E5%92%8Czookeeper%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/CAP%E5%8E%9F%E5%88%99%E4%BB%A5%E5%8F%8Aeureka%E5%92%8Czookeeper%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="CAP理论是什么？"><a href="#CAP理论是什么？" class="headerlink" title="CAP理论是什么？"></a>CAP理论是什么？</h1><p>CAP即：</p><ul><li>Consistency（一致性）：对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败，返回一个错误或超时，其强调的是数据正确。</li><li>Availability（可用性）：任何客户端的请求都能得到响应数据，不会出现响应错误，但不保证数据最新，强调的是不出错。比如我们购买商品时，他的点赞数就与购买商品无关，我们可以允许他不是最新的。</li><li>Partition tolerance（分区容忍性）：由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。</li></ul><p>这三个性质对应了分布式系统的三个指标。而CAP理论说的就是：一个分布式系统，不可能同时做到这三点。分布式系统必须满足分区容错性，所以要么是AP,要么是CP。</p><h1 id="分布式CAP定理，为什么不能同时满足三个特性"><a href="#分布式CAP定理，为什么不能同时满足三个特性" class="headerlink" title="分布式CAP定理，为什么不能同时满足三个特性"></a>分布式CAP定理，为什么不能同时满足三个特性</h1><p>假设有两台服务器，一台放着应用A和数据库V，一台放着应用B和数据库V，他们之间的网络可以互通，也就相当于分布式系统的两个部分。</p><p>在满足一致性的时候，两台服务器(假设为N1,N2)的数据是一样的，DB0&#x3D;DB0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</p><p>用户通过N1中的A应用请求数据更新到服务器DB0，这时N1中的服务器DB0变为DB1，通过分布式系统的数据同步更新操作，N2服务器中的数据库V0也更新为了DB1（图2），这时，用户通过B向数据库发起请求得到的数据就是即时更新后的数据DB1。</p><p>上面是正常运作的情况，但分布式系统中，最大的问题就是网络，现在假设一种极端情况，N1和N2之间的网络断开了，但我们仍要支持这种网络异常，也就是满足分区容错性，那么这样能不能同时满足一致性和可用性呢？</p><p>假设N1和N2之间通信的时候网络突然出现故障，有用户向N1发送数据更新请求，那N1中的数据DB0将被更新为DB1，由于网络是断开的，N2中的数据库仍旧是DB0；</p><p>如果这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据DB1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据DB0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作完成之后，再给用户响应最新的数据DB1。</p><h1 id="作为服务中心，eureka和zookeeper的对比"><a href="#作为服务中心，eureka和zookeeper的对比" class="headerlink" title="作为服务中心，eureka和zookeeper的对比"></a>作为服务中心，eureka和zookeeper的对比</h1><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fjrq1o9mj20y00b2q49.jpg" style="zoom:50%;" /><p>Zookeeper集群和Eureka集群有一个最大的区别，zookeeper集群是存在leader和follower关系的，也就是一主多从。</p><p>而eureka集群却不是这样，eureka集群中的各个节点是平等的地位，peer to peer对等通信。这是一种<strong>去中心化</strong>的架构，在这种架构风格中，节点通过彼此互相注册来提高可用性，每个节点都可被视为其他节点的副本</p><p><strong>Zookeeper保证 CP</strong></p><ul><li>Apache Zookeeper 在设计时就紧遵CP原则，即任何时候对 Zookeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是 Zookeeper 不能保证每次服务请求都是可达的。</li><li>一致性体现在两个方面。<ul><li>当往zookeeper的leader节点写数据时，leader会对剩下的follower节点进行主从数据同步，它必须得同步超过半数的follower节点才给客户端返回写成功的信号。所以从这点上它是保证了数据一致性，但是却不是强一致性。</li><li>在使用 Zookeeper 获取服务列表时，如果此时的 Zookeeper 集群中的 Leader 宕机了，该集群就要进行 Leader 的选举，选举是需要时间的，在这一段时间内，将无法处理请求。所以说，Zookeeper 不能保证服务可用性。</li></ul></li></ul><p><strong>eureka保证 AP</strong></p><ul><li>eureka优先保证可用性。在Eureka平台中，如果某台服务器宕机，Eureka不会有类似于ZooKeeper的选举leader的过程；客户端请求会自动切换到新的Eureka节点，只要有一台Eureka还在，就能保证注册服务可用，只不过查到的信息可能不是最新的。</li><li>当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。</li><li>Eureka还有之中自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：<ul><li>Eureka不在从注册列表中移除因为长时间没收到心跳而应该过期的服务</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用)</li><li>当网络稳定时，当前实例新的注册信息会被同步到其他节点中</li></ul></li></ul><p><strong>consul保证 CP</strong></p><p>Consul的使用依靠简单的http请求就能满足服务发现的所有逻辑。服务每次都从consul agent获取其他服务的存活状态，相比于zookeeper的watcher机制，实时性稍差一点。</p><p><strong>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪</strong>，<strong>所以，理论上来说，Eureka作为系统服务的注册中心是最适合的。</strong></p>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>CAP原则</tag>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之自动扩展</title>
    <link href="/springCloud%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95/"/>
    <url>/springCloud%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是自动扩展？"><a href="#什么是自动扩展？" class="headerlink" title="什么是自动扩展？"></a>什么是自动扩展？</h1><p>自动扩展分为水平扩展和垂直扩展</p><ul><li>水平扩展就是一台机子不够了，就再搞几台</li><li>垂直扩展是硬件层面的，比如双核不够了，就4核</li></ul><h1 id="自动扩展的意义"><a href="#自动扩展的意义" class="headerlink" title="自动扩展的意义"></a>自动扩展的意义</h1><ul><li>提高了高可用性和容错能力。比如某个服务不可用了，自动扩展可以再增加一个新服务来替换他。</li><li>增加了可伸缩性。允许访问流量可以自动选择水平扩展的规模。</li><li>具有最佳使用率，并节约成本。按需使用，需要几台就部署几台</li><li>优先考虑某些服务或服务组。低优先级服务中实例移除，添加到高优先级的服务实例中。</li></ul><h1 id="自动扩展的常用方法"><a href="#自动扩展的常用方法" class="headerlink" title="自动扩展的常用方法"></a>自动扩展的常用方法</h1><ul><li>资源限制。比如Cpu使用率&gt;60%</li><li>特定时间段。指定时间去扩展</li><li>消息长度。消息队列的长度&gt; 设置的长度（此时队列里堆积的消息太多了）就去扩展</li><li>业务事件。比如新产生了10笔订单，就增加一个实例</li><li>根据预测<ul><li>历史信息</li><li>当前趋势</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>自动扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成Hystrix</title>
    <link href="/springCloud%E4%B9%8B%E9%9B%86%E6%88%90Hystrix/"/>
    <url>/springCloud%E4%B9%8B%E9%9B%86%E6%88%90Hystrix/</url>
    
    <content type="html"><![CDATA[<h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><h2 id="什么是服务熔断？"><a href="#什么是服务熔断？" class="headerlink" title="什么是服务熔断？"></a>什么是服务熔断？</h2><ul><li><p>服务熔断就是对服务的调用执行熔断，对于后续的请求，不再调用目标服务，而是直接返回一个合理的信息，比如说请求量太大，返回一个”此时服务过载”，从而可以快速释放资源</p></li><li><p>保护系统</p></li></ul><h2 id="为什么会有这种熔断机制的出现"><a href="#为什么会有这种熔断机制的出现" class="headerlink" title="为什么会有这种熔断机制的出现?"></a>为什么会有这种熔断机制的出现?</h2><p>在微服务相互调用的时候可能会出现服务调用发生异常或调用超时,多此请求造成服务积压导致服务无法使用后接着级联导致调用此服务的消费者也出现异常或调用超时,最后导致整个系统的全部崩溃.这就是雪崩效应.</p><blockquote><p><a href="https://so.csdn.net/so/search?q=%E7%BA%A7%E8%81%94&spm=1001.2101.3001.7020">级联</a>(失败)雪崩：一个服务失败，导致整条链路的服务都失败的情形。</p></blockquote><h2 id="熔断的意义？"><a href="#熔断的意义？" class="headerlink" title="熔断的意义？"></a>熔断的意义？</h2><ul><li>让系统更加稳定</li><li>减少性能损耗<ul><li>响应很简单，所以产生的性能很小。</li><li>用户知道服务有问题了，就不再调用，避免一直重试，也可以减少性能损耗。</li></ul></li><li>及时响应。不需要其他计算，直接就可以返回一个简单的响应。</li><li>阀值可定制，比如请求到达10000，就开启熔断器</li></ul><h2 id="熔断器的功能"><a href="#熔断器的功能" class="headerlink" title="熔断器的功能"></a>熔断器的功能</h2><ul><li>异常处理。需要可以根据异常的类型，去处理异常</li><li>日志记录。记录失败的数目，才可以开启熔断</li><li>测试失败的操作。周期性的检查来测试服务是否健康。</li><li>手动复位。管理员可以强行关闭断路器，重置故障的计数器</li><li>并发。断路器可以支持大并发量</li><li>加速断路：检测出问题的速度要快，及时响应</li><li>重试失败请求：在服务可用时，可以安排重试</li></ul><h2 id="熔断和降级的区别"><a href="#熔断和降级的区别" class="headerlink" title="熔断和降级的区别"></a>熔断和降级的区别</h2><p>相同点：</p><ul><li>目的一致。通过技术手段来保护系统</li><li>表现类似：让用户体验到某些服务暂时不可用</li><li>粒度相同：都是基于服务的</li></ul><p>不同点</p><ul><li>触发条件不同<ul><li>服务熔断：服务熔断由链路上某个服务故障引起的</li><li>服务降级，整体负荷来考虑。比如：原本有一个系统可以承载100个请求，但是后面由于请求数降低，相应的服务数量也需要降低</li></ul></li><li>管理目标层级不同<ul><li>服务熔断：服务熔断是一个框架层次的处理，</li><li>服务降级：服务降级是业务层次的处理。降级一般是从外围服务开始</li></ul></li></ul><h1 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h1><h2 id="hystrix是什么？"><a href="#hystrix是什么？" class="headerlink" title="hystrix是什么？"></a>hystrix是什么？</h2><ul><li>Feign是Netflix开发的一款服务容错和保护组件</li></ul><h2 id="SpringCloud-集成hystrix"><a href="#SpringCloud-集成hystrix" class="headerlink" title="SpringCloud 集成hystrix"></a>SpringCloud 集成hystrix</h2><ol><li><p>搭建Eureka Client并集成Feign ：<a href="https://panyurou.github.io/2022/08/18/springCloud%E4%B9%8BFeign%E6%90%AD%E5%BB%BA/">springCloud之Feign搭建 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>导入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-hystrix&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>启动类加上@EnableCircuitBreaker注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@EnableCircuitBreaker</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>properties修改配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=8085<br>spring.application.name: micro-weather-eureka-client-feign-hystrix<br>eureka.client.serviceUrl.defaultZone: http://localhost:8761//eureka/<br>feign.client.config.feignName.connectTimeout: 5000<br>feign.client.config.feignName.readTimeout: 5000<br><br># 开启feign.hystrix<br>feign.hystrix.enabled=true<br></code></pre></td></tr></table></figure></li><li><p>修改CityClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;micro-weather-city-eureka&quot;, fallback = CityClientFallBack.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CityClient</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function">String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义CityClientFallBack实现CityClient</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.service;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityClientFallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CityClient</span></span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;City is empty!&quot;</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="7"><li><p>访问<a href="http://localhost:8085/cities">localhost:8085&#x2F;cities</a></p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5dkaubuqbj20iw07yjro.jpg" style="zoom:50%;" /></li></ol><p><strong>另一种实现方式</strong></p><ol><li><p>修改业务类，使用@HystrixCommand(fallbackMethod&#x3D;XXX)，指明熔断时调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;<br><span class="hljs-keyword">import</span> com.pyr.spring.cloud.weather.service.CityClient;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityController</span> </span>&#123;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> CityClient cityClient;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-meta">@HystrixCommand(fallbackMethod=&quot;defaultCities&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> cityClient.listCity();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">defaultCities</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Micro weather city eureka is down!&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li><p>CityClient不需要修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.service;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-meta">@FeignClient(name=&quot;micro-weather-city-eureka&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CityClient</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function">String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>停止micro-weather-city-eureka服务，访问<a href="http://localhost:8085/cities">localhost:8085&#x2F;cities</a></p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5dbm2suxzj20lm08c74q.jpg" style="zoom:50%;" /></li></ol><p>注：这种方式不需要添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">feign.hystrix.enabled=<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>服务熔断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成Zuul</title>
    <link href="/springCloud%E4%B9%8BZuul%E6%90%AD%E5%BB%BA/"/>
    <url>/springCloud%E4%B9%8BZuul%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h1><h2 id="API-网关产生的原因？"><a href="#API-网关产生的原因？" class="headerlink" title="API 网关产生的原因？"></a>API 网关产生的原因？</h2><p>在微服务架构中，一个系统往往由多个微服务组成，而这些服务可能部署在不同机房、不同地区、不同域名下。这种情况下，客户端想要直接请求这些服务，就需要知道它们具体的地址信息，例如 IP 地址、端口号等。</p><p>这种客户端直接请求服务的方式存在以下问题：</p><ul><li>当服务数量众多时，客户端需要维护大量的服务地址，这对于客户端来说，是非常繁琐复杂的。</li><li>在某些场景下可能会存在跨域请求的问题。</li><li>身份认证的难度大，每个微服务需要独立认证。</li></ul><h2 id="API网关是什么？"><a href="#API网关是什么？" class="headerlink" title="API网关是什么？"></a>API网关是什么？</h2><ul><li><p>API 网关是一个搭建在客户端和微服务之间的服务，我们可以在 API 网关中处理一些非业务功能的逻辑，例如权限验证、监控、缓存、请求路由等。</p></li><li><p>API 网关就像整个微服务系统的门面一样，是系统对外的唯一入口。有了它，客户端会先将请求发送到 API 网关，然后由 API 网关根据请求的标识信息将请求转发到微服务实例。</p></li><li><p>在微服务架构中，每个微服务通常会以RESTFUL API的形式对外提供服务，API网关就是集合多个API，统一API入口。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5gipv0ig0j21i40n8abz.jpg"></p></li></ul><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>集合多个API</li><li>统一API入口，客户端通过 API 网关与微服务交互时，客户端只需要知道 API 网关地址即可，而不需要维护大量的服务地址，简化了客户端的开发。</li><li>客户端直接与 API 网关通信，能够减少客户端与各个服务的交互次数。</li><li>API 网关还提供了安全、流控、过滤、缓存、计费以及监控等 API 管理功能。</li></ul><h4 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h4><ul><li>在架构上需要考虑更多的管理，比如哪些API放在哪个网关上</li><li>路由上需要进行统一的配置</li><li>可能引发单点故障，API是一个独立的入口，很容易出现高并发，设计不好，如果API网管不可用，整个系统不可用</li></ul><h2 id="API网关的实现"><a href="#API网关的实现" class="headerlink" title="API网关的实现"></a>API网关的实现</h2><ul><li>Spring Cloud Gateway</li><li>pring Cloud Netflix Zuul</li><li>Nginx</li><li>Traefik</li><li>Kong: 底层也是基于ngin x</li></ul><h1 id="Zuul-是什么？"><a href="#Zuul-是什么？" class="headerlink" title="Zuul 是什么？"></a>Zuul 是什么？</h1><ul><li>Zuul 是Netflix开发的一款API网关组件，对请求提供路由及过滤功能。</li></ul><h2 id="SpringCloud-集成Zuul"><a href="#SpringCloud-集成Zuul" class="headerlink" title="SpringCloud 集成Zuul"></a>SpringCloud 集成Zuul</h2><ol><li><p>搭建Eureka Client : <a href="https://panyurou.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>引入依赖</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-zuul&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注：springCloud 版本过高，会存在zuul无法引入的问题，所以本地，将SpringCloud版本降低了，相应的SpringBoot版本也降低了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">plugins&#123;<br>id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.2.0.RELEASE&#x27;</span><br>&#125;<br>ext &#123;<br>set(<span class="hljs-string">&#x27;springCloudVersion&#x27;</span>, <span class="hljs-string">&quot;Hoxton.SR12&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>properties修改配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=9090<br>spring.application.name: micro-weather-eureka-client-zuul<br>eureka.client.serviceUrl.defaultZone: http://localhost:8761//eureka/<br><br># 可配置多对路由<br>zuul.routes.demo.path: /demo/**<br>zuul.routes.demo.serviceId: micro-weather-eureka-client<br><br>#zuul.routes.city.path: /city/**<br>#zuul.routes.city.serviceId: msa-weather-city-eureka<br><br>#zuul.routes.data.path: /data/**<br>#zuul.routes.data.serviceId: msa-weather-data-eureka<br></code></pre></td></tr></table></figure><ol start="4"><li>启动类加入注解@EnableZuulProxy</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableZuulProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>访问<a href="http://localhost:9090/demo/hello">localhost:9090&#x2F;demo&#x2F;hello</a>，得到micro-weather-eureka-client 服务的数据</li></ol><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5azw9rud2j20l208o3yu.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成Feign</title>
    <link href="/springCloud%E4%B9%8BFeign%E6%90%AD%E5%BB%BA/"/>
    <url>/springCloud%E4%B9%8BFeign%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Feign是什么？"><a href="#Feign是什么？" class="headerlink" title="Feign是什么？"></a>Feign是什么？</h1><ul><li>Feign是Netflix开发的一款声明式服务调用组件</li><li>Feign可以帮助我们更快捷、优雅地调用HTTP API。</li><li>Feign 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Feign 的二次封装，主要负责 Spring Cloud 的服务调用功能。</li></ul><h1 id="SpringCloud-集成Feign"><a href="#SpringCloud-集成Feign" class="headerlink" title="SpringCloud 集成Feign"></a>SpringCloud 集成Feign</h1><ol><li><p>搭建Eureka Client : <a href="https://panyurou.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-openfeign&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>修改application.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port=8085<br>spring.application.name: micro-weather-eureka-client-feign<br>eureka.client.serviceUrl.defaultZone: http://localhost:8761//eureka/<br># 连接的超时时间<br>feign.client.config.feignName.connectTimeout: 5000<br># 读数据的超时时间<br>feign.client.config.feignName.readTimeout: 5000<br></code></pre></td></tr></table></figure></li><li><p>创建一个接口，用FeignClient注解，指明需要调用的服务名和rest接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;micro-weather-city-eureka&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CityClient</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>  <span class="hljs-function">String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br>   <br>   <span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br>   <span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br>   <span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br>   <span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<br>   <br>   <span class="hljs-meta">@SpringBootApplication</span><br>   <span class="hljs-meta">@EnableDiscoveryClient</span><br>   <span class="hljs-meta">@EnableFeignClients</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>   <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       SpringApplication.run(Application.class, args);<br>     &#125;<br>   &#125;<br>   <br><br><span class="hljs-number">6.</span> 创建一个RestClientController来实现对Feign客户端的调用<br><br>   ```java<br>   <span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br>   <br>   <span class="hljs-keyword">import</span> com.pyr.spring.cloud.weather.service.CityClient;<br>   <span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br>   <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br>   <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br>   <br>   <span class="hljs-meta">@RestController</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityController</span> </span>&#123;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> CityClient cityClient;<br>   <br>     <span class="hljs-meta">@RequestMapping(&quot;/cities&quot;)</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">listCity</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> cityClient.listCity();<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>查看euraka服务端，可以看到该客户端注册成功，访问[localhost:8085&#x2F;cities，可以获取到指定服务接口的返回</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5ap6lysrwj21ek0u00xb.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5ap87sv66j228m0k4zw9.jpg"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之集成SpringCloud Config</title>
    <link href="/springCloud%E4%B9%8B%E9%9B%86%E6%88%90SpringCloud-Config/"/>
    <url>/springCloud%E4%B9%8B%E9%9B%86%E6%88%90SpringCloud-Config/</url>
    
    <content type="html"><![CDATA[<h1 id="集中化配置"><a href="#集中化配置" class="headerlink" title="集中化配置"></a>集中化配置</h1><h2 id="为什么要集中化配置？"><a href="#为什么要集中化配置？" class="headerlink" title="为什么要集中化配置？"></a>为什么要集中化配置？</h2><ul><li>微服务数量多，配置多</li><li>手工管理配置繁琐</li></ul><h2 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h2><ul><li>按照来源，分为：源代码，文件，数据库连接，服务调用等</li><li>按照配置环境，分为开发环境，测试环境，生产环境</li><li>集成阶段，编译，打包，运行</li></ul><h2 id="配置中心的要求"><a href="#配置中心的要求" class="headerlink" title="配置中心的要求"></a>配置中心的要求</h2><ul><li>面向可配置的编码：避免硬编码，设置常量，运行时可读取</li><li>个理性：生产环境的配置和测试环境配置不一样</li><li>一致性：相同部署环境下，应该配置相同</li><li>集中化配置：分布式环境下，应用的配置应该具备可以管理性，提供远程管理的能力。</li></ul><h1 id="SpringCloud-Config"><a href="#SpringCloud-Config" class="headerlink" title="SpringCloud Config"></a>SpringCloud Config</h1><h2 id="springCloud-config-是什么？"><a href="#springCloud-config-是什么？" class="headerlink" title="springCloud config 是什么？"></a>springCloud config 是什么？</h2><ul><li>Spring Cloud Config 是由 Spring Cloud 团队开发的项目，它可以为微服务架构中各个微服务提供集中化的外部配置支持。</li><li>Spring Cloud Config 可以将各个微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git 、SVN 等）中，对配置的统一管理，以支持各个微服务的运行。</li><li>Spring Cloud Config 包含以下两个部分：<ul><li>Config Server：也被称为分布式配置中心，它是一个独立运行的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密信息和解密信息的访问接口。</li><li>Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并从 Config Sever 中获取和加载配置信息。</li></ul></li></ul><h2 id="搭建-Config-服务端"><a href="#搭建-Config-服务端" class="headerlink" title="搭建 Config 服务端"></a>搭建 Config 服务端</h2><ol><li><p>搭建Eureka Client : <a href="https://panyurou.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>github或者码云上创建一个仓库存储配置信息，github国内不是很稳定，我用了码云</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5d7fi607gj21ja0u0q8a.jpg"></p></li><li><p>在config-repo路径下，编写配置文件config-dev.yml</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5d7h5hk5oj21h10u0n1z.jpg"></p></li><li><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-config-server&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>properties修改配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">server.port=<span class="hljs-number">8888</span><br>spring.application.name: micro-weather-eureka-server-config<br>eureka.client.serviceUrl.defaultZone: http:<span class="hljs-comment">//localhost:8761//eureka/</span><br><br># git 地址，用来存储配置文件<br>spring.cloud.config.server.git.uri=https:<span class="hljs-comment">//gitee.com/panyuro/spring-cloud-microservice-config.git</span><br><br>#存储配置文件的目录<br>spring.cloud.config.server.git.searchPaths=config-repo<br></code></pre></td></tr></table></figure></li><li><p>启动类加入注解@EnableConfigServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动项目，访问<a href="http://localhost:8888/config-dev.yml">localhost:8888&#x2F;config-dev.yml</a>，我们可以看到8888微服务可以成功的读取到远端的配置文件。如下图：</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5d7ik0y9ij20qy0ag74v.jpg" style="zoom:50%;" /></li></ol><p>访问<a href="http://localhost:8888/config/dev/master">localhost:8888&#x2F;config&#x2F;dev&#x2F;master</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5d7jb4rhyj225k09m0vc.jpg"></p><h2 id="搭建-Config客户端"><a href="#搭建-Config客户端" class="headerlink" title="搭建 Config客户端"></a>搭建 Config客户端</h2><ol><li><p>搭建Eureka Client : <a href="https://panyurou.github.io/2022/08/17/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/">springCloud之Eureka搭建 - 楼上有只喵 (panyurou.github.io)</a></p></li><li><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-config-client&#x27;</span><br></code></pre></td></tr></table></figure><p>springcloud 版本较高，无法成功启动项目的时候，需要再引入starter-bootstrap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>properties修改配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">server.port=<span class="hljs-number">9091</span><br>spring.application.name: micro-weather-config-client<br>eureka.client.serviceUrl.defaultZone: http:<span class="hljs-comment">//localhost:8761//eureka/</span><br><br>spring.cloud.config.profile=dev<br>spring.cloud.config.uri=http:<span class="hljs-comment">//localhost:8888/</span><br>spring.cloud.config.name=config<br></code></pre></td></tr></table></figure></li><li><p>编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigController</span> </span>&#123;<br><br>  <span class="hljs-meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> String info;<br><br>  <span class="hljs-meta">@Value(&quot;$&#123;config.version&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> String version;<br><br>  <span class="hljs-meta">@GetMapping(&quot;/config&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">config</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;info: &quot;</span>+info+<span class="hljs-string">&quot; version: &quot;</span>+version;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试，访问<a href="http://localhost:9091/config">localhost:9091&#x2F;config</a>，可以查询到正确的配置</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5d7p3re81j20na08sgm3.jpg" style="zoom:50%;" /></li></ol><h1 id="Config客户端之动态刷新"><a href="#Config客户端之动态刷新" class="headerlink" title="Config客户端之动态刷新"></a>Config客户端之动态刷新</h1><p>避免每次修改githib上的配置都需要重启客户端</p><h2 id="手动版"><a href="#手动版" class="headerlink" title="手动版"></a>手动版</h2><p>优点：解决了重启 Config 客户端才能获取最新配置的问题，</p><p>缺点：只要配置仓库中的配置发生改变，就需要我们挨个向 Config 客户端手动发送 POST 请求，通知它们重新拉取配置。</p><p>那么有没有“一次通知，处处生效”的方式呢？答案是肯定的。Spring Cloud Config 配合 Bus 就可以实现配置的动态刷新。</p>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>集中化配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud之Eureka搭建</title>
    <link href="/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/"/>
    <url>/springCloud%E4%B9%8BEureka%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Eureka是什么？"><a href="#Eureka是什么？" class="headerlink" title="Eureka是什么？"></a>Eureka是什么？</h1><ul><li>Eureka是 Netflix 公司开发的一款开源的服务注册与发现组件。</li><li>Spring Cloud 将 Eureka 与 Netflix 中的其他开源服务组件（例如 Ribbon、Feign 以及 Hystrix 等）一起整合进 Spring Cloud Netflix 模块中，整合后的组件全称为 Spring Cloud Netflix Eureka。</li><li>Eureka 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Eureka 的二次封装，主要负责 Spring Cloud 的服务注册与发现功能。</li></ul><h1 id="Eureka-两大组件"><a href="#Eureka-两大组件" class="headerlink" title="Eureka 两大组件"></a>Eureka 两大组件</h1><p>Eureka 采用 CS（Client&#x2F;Server，客户端&#x2F;服务器） 架构，它包括以下两大组件：</p><ul><li><p><strong>Eureka Server</strong>：Eureka 服务注册中心，主要用于提供服务注册功能。当微服务启动时，会将自己的服务注册到 Eureka Server。Eureka Server 维护了一个可用服务列表，存储了所有注册到 Eureka Server 的可用服务的信息，这些可用服务可以在 Eureka Server 的管理界面中直观看到。</p></li><li><p><strong>Eureka Client</strong>：Eureka 客户端，通常指的是微服务系统中各个微服务，主要用于和 Eureka Server 进行交互。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳（默认周期为 30 秒）。若 Eureka Server 在多个心跳周期内没有接收到某个 Eureka Client 的心跳，Eureka Server 将它从可用服务列表中移除（默认 90 秒</p></li></ul><h1 id="Eureka-自我保护机制"><a href="#Eureka-自我保护机制" class="headerlink" title="Eureka 自我保护机制"></a>Eureka 自我保护机制</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>默认情况下,EurekaClient会定时向EurekaServer端发送心跳，如果EurekaServer在一定时间内没有收到EurekaClient发送的心跳，便会把该实例从注册服务列表中剔除（默认是90秒)</li><li>但是在短时间内丢失大量的实例心跳，这时候EurekaServer会开启自我保护机制，<a href="https://so.csdn.net/so/search?q=Eureka&spm=1001.2101.3001.7020">Eureka</a>不会踢出该服务，而是会对该服务的信息进行保存。</li></ul><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>为了防止EurekaClient正常运行，但是与EurekaServer网络不通（延迟、拥堵、卡顿）的情况下，EurekaServer不会对EurekaClient服务进行剔除，因为微服务本身是建康的，此时不应该注销这个微服务。</p><h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>本地环境建议禁止自我保护，生产环境建议开启自我保护。</p><h2 id="eureka停止更新了"><a href="#eureka停止更新了" class="headerlink" title="eureka停止更新了"></a>eureka停止更新了</h2><p><a href="https://github.com/Netflix/eureka/wiki">Home · Netflix&#x2F;eureka Wiki (github.com)</a></p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5fdi19u9dj215a0u0q7v.jpg" style="zoom:100%;" /><h1 id="Eureka-Server搭建"><a href="#Eureka-Server搭建" class="headerlink" title="Eureka Server搭建"></a>Eureka Server搭建</h1><p>参考<a href="https://github.com/spring-cloud-samples/eureka">GitHub - spring-cloud-samples&#x2F;eureka</a></p><ul><li><p>Step1: 新建一个springBoot项目</p></li><li><p>Step2: 修改依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">plugins&#123;<br>id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.6.1&#x27;</span><br>id <span class="hljs-string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="hljs-string">&#x27;1.0.8.RELEASE&#x27;</span><br>id <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br><br>ext &#123;<br>set(<span class="hljs-string">&#x27;springCloudVersion&#x27;</span>, <span class="hljs-string">&quot;2021.0.0&quot;</span>)<br>name = <span class="hljs-string">&#x27;Eureka Server&#x27;</span><br>description = <span class="hljs-string">&#x27;Eureka Server demo project&#x27;</span><br>version=<span class="hljs-string">&#x27;0.0.1-SNAPSHOT&#x27;</span><br>sourceEncoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span><br>&#125;<br><br>repositories &#123;<br>mavenCentral()<br>maven &#123; url <span class="hljs-string">&#x27;https://repo.spring.io/release/&#x27;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-snapshot-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-milestone-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-release-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.springsource.org/plugins-release&quot;</span> &#125;<br>&#125;<br><br>dependencyManagement &#123;<br>imports &#123;<br>mavenBom <span class="hljs-string">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>&#125;<br>&#125;<br><br>dependencies &#123;<br>implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-server&#x27;</span><br>testImplementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Step3: application配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">server.port: 8761<br><br>eureka.instance.hostname: localhost<br>#eureka可以同时作为服务端和客户端，这里禁用掉他客户端的能力<br>eureka.client.registerWithEureka: false<br>eureka.client.fetchRegistry: false<br>eureka.client.serviceUrl.defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/<br><br>#关闭自我保护机制，以确保注册中心将不可用的实例及时正确剔除<br>eureka.server.enable-self-preservation=false<br></code></pre></td></tr></table></figure></li><li><p>step4.启动类加上@EnableEurekaServer注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>启动成功后，访问<a href="http://localhost:8761/">Eureka</a>可以看到如下页面，可以看出此时还没有实例注册到该服务上。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5ap4xbr46j21ex0u0jvx.jpg"></p></li></ul><h1 id="Eureka-Client搭建"><a href="#Eureka-Client搭建" class="headerlink" title="Eureka Client搭建"></a>Eureka Client搭建</h1><ul><li><p>Step1: 新建一个springBoot项目</p></li><li><p>Step2: 修改依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">plugins&#123;<br>id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.6.1&#x27;</span><br>id <span class="hljs-string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="hljs-string">&#x27;1.0.8.RELEASE&#x27;</span><br>id <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br><br>ext &#123;<br>set(<span class="hljs-string">&#x27;springCloudVersion&#x27;</span>, <span class="hljs-string">&quot;2021.0.0&quot;</span>)<br>name = <span class="hljs-string">&#x27;Eureka Server&#x27;</span><br>description = <span class="hljs-string">&#x27;Eureka Server demo project&#x27;</span><br>version=<span class="hljs-string">&#x27;0.0.1-SNAPSHOT&#x27;</span><br>    <br>sourceEncoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span><br>&#125;<br><br>repositories &#123;<br>mavenCentral()<br>maven &#123; url <span class="hljs-string">&#x27;https://repo.spring.io/release/&#x27;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-snapshot-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-milestone-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.spring.io/libs-release-local&quot;</span> &#125;<br>maven &#123; url <span class="hljs-string">&quot;https://repo.springsource.org/plugins-release&quot;</span> &#125;<br>&#125;<br><br>dependencyManagement &#123;<br>imports &#123;<br>mavenBom <span class="hljs-string">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>&#125;<br>&#125;<br><br>dependencies &#123;<br>implementation <span class="hljs-string">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br><br>testImplementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Step3: application配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.application.name: micro-weather-eureka-client<br>eureka.client.serviceUrl.defaultZone: http:<span class="hljs-comment">//localhost:8761//eureka/</span><br></code></pre></td></tr></table></figure></li><li><p>step4.启动类加上@EnableDiscoveryClient注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>刷新</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5aordxc7lj21dz0u0434.jpg"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 反射</title>
    <link href="/java-%E5%8F%8D%E5%B0%84/"/>
    <url>/java-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h1><ul><li><p>反射就是指在运行状态中，对于任何一个类，能够知道这个类的所有属性和方法。</p></li><li><p>对于任何一个对象，都能调用它的任意属性和方法，并且可以改变他的属性。</p></li><li><p>反射是java被市委准动态语言的关键，反射机制允许程序在执行期间借助反射Api来获取任何类的内部信息，并能够直接操作任意对象的内部属性及方法。</p></li><li><p>加载完类后，在堆内存的方法区就产生了一个Class类型的对象，对应这个类。这个对象就包含了这个类的完整结构信息，我们可以通过这个对象看到类的结构。这个对象就像一面镜子，通过这面镜子我们可以看到类的结构，所以我们称之为：反射。</p></li></ul><h1 id="反射可以做什么"><a href="#反射可以做什么" class="headerlink" title="反射可以做什么"></a>反射可以做什么</h1><p>反射允许我们在程序运行时，取得任何一个已知class的内部信息，包括其属性，方法等，并可以在运行时改变他们呢。</p><p>获取class对象的五种方式：<a href="https://panyurou.github.io/2022/07/13/Java%E8%8E%B7%E5%8F%96class%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/">Java获取class的五种方式 - 楼上有只喵 (panyurou.github.io)</a></p><h1 id="反射的具体实现"><a href="#反射的具体实现" class="headerlink" title="反射的具体实现"></a>反射的具体实现</h1><p>查阅 API 可以看到 Class 有很多方法：</p><ul><li><p>getName()：获得类的完整名字。</p></li><li><p>getFields()：获得类的public类型的属性。</p><ul><li>getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类</li><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象</li></ul></li></ul><p><strong>代码测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.reflection;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>  <span class="hljs-keyword">public</span> String fatherId;<br>  <span class="hljs-keyword">private</span> String fatherName;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFatherHobbies</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;eat&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFatherWork</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;computer&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>  <span class="hljs-keyword">public</span> String sonId;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> Integer age;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSonHobbies</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;study&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSonWork</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;<br>    <span class="hljs-keyword">final</span> Class&lt;Son&gt; clazz = Son.class;<br>    System.out.println(<span class="hljs-string">&quot;获得类的完整名字-------------------&quot;</span>);<br>    System.out.println(clazz.getName());<br><br>    System.out.println(<span class="hljs-string">&quot;获得类的public类型的属性-------------------&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Field field : clazz.getFields()) &#123;<br>      <span class="hljs-comment">// 由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的</span><br>      field.setAccessible(<span class="hljs-keyword">true</span>);<br>      System.out.println(field.getName());<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;获得类的所有属性。包括private的---------------&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;<br>      System.out.println(field.getName());<br>    &#125;<br><br><br>    System.out.println(<span class="hljs-string">&quot;获得类的public类型的方法,包括Object的-------------------&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Method method : clazz.getMethods()) &#123;<br>      System.out.println(method.getName());<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;获得类的所有方法。-------------------&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Method method : clazz.getDeclaredMethods()) &#123;<br>      System.out.println(method.getName());<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;获得指定的public属性。-------------------&quot;</span>);<br>    Field sonId = clazz.getField(<span class="hljs-string">&quot;sonId&quot;</span>);<br>    System.out.println(sonId);<br><br>    System.out.println(<span class="hljs-string">&quot;获得指定的private属性。-------------------&quot;</span>);<br>    Field age = clazz.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>    age.setAccessible(<span class="hljs-keyword">true</span>);<br>    System.out.println(age);<br><br>    System.out.println(<span class="hljs-string">&quot;创建这个类的一个对象-------------------&quot;</span>);<br>    <span class="hljs-keyword">final</span> Son son = clazz.getDeclaredConstructor().newInstance();<br>    System.out.println(son);<br><br>    System.out.println(<span class="hljs-string">&quot;将son对象的age属性赋值为19------------&quot;</span>);<br>    age.set(son, <span class="hljs-number">19</span>);<br>    System.out.println(age.get(son));<br><br>    System.out.println(<span class="hljs-string">&quot;获取构造方法-------------&quot;</span>);<br>    <span class="hljs-keyword">final</span> Constructor&lt;?&gt;[] constructors = clazz.getConstructors();<br>    <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;<br>      System.out.println(constructor.toString());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Console:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs stylus">获得类的完整名字-------------------<br>com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.Son</span><br>获得类的public类型的属性-------------------<br>sonId<br>fatherId<br>获得类的所有属性。包括private的---------------<br>sonId<br>name<br>age<br>获得类的public类型的方法,包括Object的-------------------<br>getSonHobbies<br>getFatherHobbies<br>wait<br>wait<br>wait<br>equals<br>toString<br>hashCode<br>getClass<br>notify<br>notifyAll<br>获得类的所有方法。-------------------<br>getSonWork<br>getSonHobbies<br>getFatherHobbies<br>获得指定的public属性。-------------------<br>public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.Son</span><span class="hljs-selector-class">.sonId</span><br>获得指定的private属性。-------------------<br>private java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Integer</span> com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.Son</span><span class="hljs-selector-class">.age</span><br>创建这个类的一个对象-------------------<br>com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span>.Son@<span class="hljs-number">1</span>cd072a9<br>将son对象的age属性赋值为<span class="hljs-number">19</span>------------<br><span class="hljs-number">19</span><br>获取构造方法-------------<br>public com<span class="hljs-selector-class">.my</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.Son</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>isAssignableFrom()</title>
    <link href="/isAssignableFrom-%E5%92%8Cinstanceof/"/>
    <url>/isAssignableFrom-%E5%92%8Cinstanceof/</url>
    
    <content type="html"><![CDATA[<h1 id="isAssignableFrom"><a href="#isAssignableFrom" class="headerlink" title="isAssignableFrom()"></a>isAssignableFrom()</h1><p>A.isAssignableFrom(B)方法可用来判断B是否可以由A转换（赋值得来），即</p><p>1.当A是类时，表示：类A是否为B类的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.isAggsignableFrom;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brother</span> </span>&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println(Parent.class.isAssignableFrom(Son1.class));   =&gt; <span class="hljs-keyword">true</span><br>    System.out.println(Parent.class.isAssignableFrom(Brother.class));  =&gt; <span class="hljs-keyword">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.当A是接口时，表示：接口A是否被类B实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.my.test.isAggsignableFrom;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span></span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span></span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span></span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println(A.class.isAssignableFrom(A1.class));  =&gt; <span class="hljs-keyword">true</span><br>    System.out.println(A.class.isAssignableFrom(B1.class));  =&gt; <span class="hljs-keyword">false</span><br>  &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java获取class的五种方式</title>
    <link href="/Java%E8%8E%B7%E5%8F%96class%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/Java%E8%8E%B7%E5%8F%96class%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="获取Class-类实例的五种方式"><a href="#获取Class-类实例的五种方式" class="headerlink" title="获取Class 类实例的五种方式"></a>获取Class 类实例的五种方式</h1><h2 id="1-已知具体的类，直接取该类的class属性-最安全，最可靠"><a href="#1-已知具体的类，直接取该类的class属性-最安全，最可靠" class="headerlink" title="1.已知具体的类，直接取该类的class属性(最安全，最可靠)"></a>1.已知具体的类，直接取该类的class属性(最安全，最可靠)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz01 = Person.class;<br></code></pre></td></tr></table></figure><h2 id="2-已知某个类的示例，调用该示例的getClass"><a href="#2-已知某个类的示例，调用该示例的getClass" class="headerlink" title="2.已知某个类的示例，调用该示例的getClass()"></a>2.已知某个类的示例，调用该示例的getClass()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz02 = <span class="hljs-keyword">new</span> Person().getClass();<br></code></pre></td></tr></table></figure><h2 id="3-已知该类的全路径，通过Class-forName-获得"><a href="#3-已知该类的全路径，通过Class-forName-获得" class="headerlink" title="3.已知该类的全路径，通过Class.forName() 获得"></a>3.已知该类的全路径，通过Class.forName() 获得</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class class03 = Class.forName(<span class="hljs-string">&quot;com.getClass.pojo.Person&quot;</span>);<br></code></pre></td></tr></table></figure><p>该方式可能会抛出：ClassNotFoundException</p><h2 id="4-已知该类的全路径，通过ClassLoader-loadClass-获得"><a href="#4-已知该类的全路径，通过ClassLoader-loadClass-获得" class="headerlink" title="4.已知该类的全路径，通过ClassLoader.loadClass() 获得"></a>4.已知该类的全路径，通过ClassLoader.loadClass() 获得</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader classLoader = MySpringApplicationContext.class.getClassLoader();<br><span class="hljs-keyword">final</span> Class clazz05 = classLoader.loadClass(<span class="hljs-string">&quot;com.getClass.pojo.Person&quot;</span>);<br></code></pre></td></tr></table></figure><p>该方式可能会抛出：ClassNotFoundException</p><h2 id="5-基本了类型的包装类，直接调用-type"><a href="#5-基本了类型的包装类，直接调用-type" class="headerlink" title="5. 基本了类型的包装类，直接调用.type"></a>5. 基本了类型的包装类，直接调用.type</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz04 = Integer.TYPE;<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring事务失效</title>
    <link href="/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/"/>
    <url>/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p>~&#x2F;IdeaProjects&#x2F;hexo_blog&#x2F;source&#x2F;_posts&#x2F;spring事务失效.md</p><p>![image-20220626230019084](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220626230019084.png)</p><p>![image-20220626230308183](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220626230308183.png)</p><p>![image-20220626231230229](&#x2F;Users&#x2F;panyurou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220626231230229.png)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql事务隔离级别</title>
    <link href="/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-事务"><a href="#mysql-事务" class="headerlink" title="mysql 事务"></a>mysql 事务</h1><h2 id="1-事务定义"><a href="#1-事务定义" class="headerlink" title="1.事务定义"></a>1.事务定义</h2><p>事务是一个操作集合，这些操作要么都执行，要么都不执行，他是一个不可分割的工作单位。</p><h2 id="2-事务的四大特性"><a href="#2-事务的四大特性" class="headerlink" title="2.事务的四大特性"></a>2.事务的四大特性</h2><ul><li>原子性：事务是一个原子操作单元，它对数据的修改，要么都执行，要么都不执行。</li><li>一致性：一个事务执行前和执行后，数据必须保持一致，如：转账前用户AB的钱加在一起时500，转账后也应该是500</li><li>隔离型：事务外的实体不可以知道事务过程中的中间状态</li><li>持久性：对数据库的操作是永久性的，即使系统故障也能保持</li></ul><h2 id="3-不考虑事务的隔离性会产生并发问题"><a href="#3-不考虑事务的隔离性会产生并发问题" class="headerlink" title="3.不考虑事务的隔离性会产生并发问题"></a>3.不考虑事务的隔离性会产生并发问题</h2><ul><li>更新丢失：当两个或者多个事务同时对一行数据进行更新，会发生数据的覆盖，最后的更新覆盖了其他事务的更新。</li><li>脏读：读到了没有提交的数据，一个事务正在写操作，另一个事务进行了读操作，读到了脏数据。如果此时事务回滚，读取到的数据就是无效的。</li><li>不可重复读：读到了已经提交的数据，事务A多次读取同一数据，但在这个过程中，事务B对数据进行了修改并提交，会导致事务A多次读取数据结果不一致。</li><li>幻读：事务A读取到了事务B提交的新增数据。查询某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</li></ul><h1 id="mysql-事务隔离级别"><a href="#mysql-事务隔离级别" class="headerlink" title="mysql 事务隔离级别"></a>mysql 事务隔离级别</h1><ul><li><p>脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p></li><li><p>mysql隔离级别越高，性能越差。因为事务的本质就是串行化，这显然与并发是矛盾的。</p></li><li><p><code>RR</code> 级别作为 <code>mysql</code> 事务默认隔离级别，是事务安全与性能的折中。</p></li><li><p>查看当前事务的隔离级别 <code>select @@transaction_isolation;</code></p></li><li><p>设置事务隔离级别</p><ul><li>当前会话： <code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></li><li>全局：<code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></li></ul></li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>可能</td><td>可能</td><td align="center">可能</td></tr><tr><td>读已提交</td><td>不可能</td><td>可能</td><td align="center">可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td align="center">可能</td></tr><tr><td>串行化</td><td>不可能</td><td>不可能</td><td align="center">不可能</td></tr></tbody></table><h2 id="1-读未提交"><a href="#1-读未提交" class="headerlink" title="1.读未提交"></a>1.读未提交</h2><ul><li><p>打开两个客户端：客户端A设置当前事务模式为read uncommitted，查询employees 表的初始值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> READ<span class="hljs-operator">-</span>UNCOMMITTED        <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure></li><li><p>客户端B开启事务，并执行更新操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据，一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是<strong>脏数据</strong>： </p></li><li><pre><code class="sql">mysql&gt;  select * from employees;+----+-----------+-----+----------+---------------------+| id | name      | age | position | hire_time           |+----+-----------+-----+----------+---------------------+|  4 | newLiLei  |  22 | mana ger | 2021-12-06 21:36:50 ||  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 ||  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |+----+-----------+-----+----------+---------------------+3 rows in set (0.00 sec)<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br>## 读已提交<br><br><span class="hljs-bullet">- </span>打开两个客户端：客户端A设置当前事务模式为read committed，查询employees 表的初始值<br><br><span class="hljs-code">```sql</span><br><span class="hljs-code">mysql&gt; select @@transaction_isolation;</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">| @@transaction_isolation |</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">| READ-COMMITTED          |</span><br><span class="hljs-code">+-------------------------+</span><br><span class="hljs-code">1 row in set (0.00 sec)</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; select * from employees;</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br><span class="hljs-section">| id | name      | age | position | hire_time           |</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br>|  4 | LiLei     |  22 | mana ger | 2021-12-06 21:36:50 |<br>|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |<br><span class="hljs-section">|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |</span><br><span class="hljs-section">+----+-----------+-----+----------+---------------------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure></code></pre></li><li><p>客户端B开启事务，并执行更新操作</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端B的事务提交</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">commit</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端A再次查询，结果 与上一步不一致，即产生了不可重复读的问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> newLiLei  <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br></code></pre></td></tr></table></figure><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><ul><li>打开两个客户端：客户端A设置当前事务模式为REPEATABLE-READ，查询employees 表的初始值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ         <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li>客户端B开启事务，并执行更新操作, 并提交。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span>  update employees <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> &quot;newLiLei&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-keyword">Rows</span> matched: <span class="hljs-number">1</span>  Changed: <span class="hljs-number">1</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>在客户端A查询表account的所有记录，与上一次查询结果一致，没出现有出现不可重复读的问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> LiLei     <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy      <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><blockquote><p>Mysql默认级别是repeatable-read，有办法解决幻读问题吗？ </p><p><strong>间隙锁在某些情况下可以解决幻读问题</strong> </p><p>要避免幻读可以用间隙锁在Session_1下面执行update account set name &#x3D; ‘zhuge’ where id &gt; 10 and id &lt;&#x3D;20;，则其他Session没法在这个范围所包含的间隙里插入或修改任何数据</p></blockquote><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><ul><li>打开两个客户端：客户端A设置当前事务模式为SERIALIZABLE，查询employees 表的初始值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@transaction</span>_isolation <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-operator">|</span> SERIALIZABLE            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec) <br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name      <span class="hljs-operator">|</span> age <span class="hljs-operator">|</span> position <span class="hljs-operator">|</span> hire_time           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> newLiLei  <span class="hljs-operator">|</span>  <span class="hljs-number">22</span> <span class="hljs-operator">|</span> mana ger <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> HanMeimei <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Lucy123   <span class="hljs-operator">|</span>  <span class="hljs-number">23</span> <span class="hljs-operator">|</span> dev      <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">50</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7</span> <span class="hljs-operator">|</span> wangwu123 <span class="hljs-operator">|</span>  <span class="hljs-number">18</span> <span class="hljs-operator">|</span> super    <span class="hljs-operator">|</span> <span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span>:<span class="hljs-number">53</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------+-----+----------+---------------------+</span><br></code></pre></td></tr></table></figure><ul><li>打开一个客户端B，并设置当前事务模式为serializable，插入一条记录报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，开发中很少会用到。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employees <span class="hljs-keyword">values</span>(<span class="hljs-number">12</span>,&quot;lili2&quot;,<span class="hljs-number">11</span>,&quot;manager&quot;,&quot;2021-12-06 21:36:55&quot;);<br>ERROR <span class="hljs-number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction<br></code></pre></td></tr></table></figure><h1 id="InnoDB与MYISAM的最大不同有两点："><a href="#InnoDB与MYISAM的最大不同有两点：" class="headerlink" title="InnoDB与MYISAM的最大不同有两点："></a>InnoDB与MYISAM的最大不同有两点：</h1><ol><li>支持事务</li><li>支持行锁</li></ol><h1 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h1><ul><li><p>尽可能低级别事务隔离</p></li><li><p>尽可能减少检索条件范围，避免间隙锁 </p></li><li><p>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行 </p></li><li><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 </p><blockquote><p>无索引行锁会升级为表锁：锁主要是加在索引上，如果对非索引字段更新, 行锁可能会变表锁</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql事务隔离性的实现</title>
    <link href="/mvcc%E4%BB%8B%E7%BB%8D/"/>
    <url>/mvcc%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql事务隔离性的实现"><a href="#mysql事务隔离性的实现" class="headerlink" title="mysql事务隔离性的实现"></a>mysql事务隔离性的实现</h1><h2 id="MVCC机制（多版本并发控制）"><a href="#MVCC机制（多版本并发控制）" class="headerlink" title="MVCC机制（多版本并发控制）"></a>MVCC机制（多版本并发控制）</h2><ul><li>Mysql在读已提交和可重复读隔离级别下都实现了MVCC机制。 </li><li>主要是保存数据在某个时间点的快照实现的。</li><li>mysql在每行记录后面，保存了两个隐藏列，分别为：创建事务id和删除事务id</li><li>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。</li></ul><ul><li><p>当执行select操作的时候，mysql底层会带上过滤条件：</p><ul><li><p>创建事务id &lt;&#x3D; max(当前事务id, 已提交的最大事务id)，保证该事务读到的数据，要么是开始前就已经存在的，要么是自身插入或修改后的。</p></li><li><p>删除事务id  &gt;  max (当前事务id, 已提交的最大事务id) 或  删除事务id未定义。保证事务读到的行，在事务开始前没有被删除</p></li></ul></li></ul><h2 id="undo日志版本链"><a href="#undo日志版本链" class="headerlink" title="undo日志版本链"></a><strong>undo日志版本链</strong></h2><p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链。</p><ul><li>roll_pointer： 可以根据roll_pointer找到之前的老数据，如果事务失败，就可以找到之前的老数据</li><li>每次修改，就是写进新的事务id,以及把回滚指针指向上一条数据的位置</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h385eu22j0j218m0u042n.jpg"></p><h2 id="read-view机制详解"><a href="#read-view机制详解" class="headerlink" title="read view机制详解"></a><strong>read view机制详解</strong></h2><ul><li><p>在<strong>可重复读隔离级别</strong>，当事务开启，执行任何查询sql时会生成当前事务的<strong>一致性视图read-view，</strong>该视图在事务结束 之前都不会变化(<strong>如果是读已提交隔离级别在每次执行查询sql时都会重新生成</strong>)。</p></li><li><p>这个视图由执行查询时所有未提交事务id<strong>数组</strong>（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h385hvu2m4j210w0c2myc.jpg" style="zoom:50%;" /></h2><p>Eg:</p><p>假设当前新开启了一个事务A，事务id为300，在该事务之前有两个事务B和C，均id分别为100和200。</p><p>当事务A执行第一个select的时候，事务B已经提交了，而事务C还没有提交，那么此时的read-view为【200】，300</p><p><strong>版本链比对规则：</strong> </p><ol><li><p>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的； </p></li><li><p>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若</p></li></ol><p>row 的 trx_id 就是当前自己的事务是可见的）；</p><ol start="3"><li>如果 row 的 trx_id 落在黄色部分(min_id &lt;&#x3D;trx_id&lt;&#x3D; max_id)，那就包括两种情况</li></ol><p>​a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的事务是可见的)； </p><p>​b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</p><p><strong>删除的情况</strong>：</p><p>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的 trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据。</p><p><strong>注意：</strong></p><p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表的语句， </p><p>事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。 </p><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>串行化隔离级别为了保证较高的隔离性是通过将所有操 作加锁互斥来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postgresql索引基础</title>
    <link href="/postgresql%E5%9F%BA%E7%A1%80/"/>
    <url>/postgresql%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL索引类型"><a href="#PostgreSQL索引类型" class="headerlink" title="PostgreSQL索引类型"></a>PostgreSQL索引类型</h1><ul><li>PostgreSQL提供了多种索引类型： B-tree、Hash、GiST、SP-GiST 、GIN 和 BRIN。</li><li>每一种索引类型使用了 一种不同的算法来适应不同类型的查询。</li><li>默认情况下，CREATE INDEX命令创建适合于大部分情况的B-tree 索引。</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>flex 布局</title>
    <link href="/flex-%E5%B8%83%E5%B1%80/"/>
    <url>/flex-%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><h2 id="开启flex-布局"><a href="#开启flex-布局" class="headerlink" title="开启flex 布局"></a>开启flex 布局</h2><ul><li>开启flex布局，只需要在最外层容器设置<code> display: flex</code>即可</li><li>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</li><li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<ul><li>主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；</li><li>交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code></li></ul></li><li>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</li></ul><p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529192600.png"></p><p><strong>示例</strong>：</p><p>开启flex布局，默认沿主轴排列</p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529194352.png" style="zoom:33%;" /><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: bisque;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">  &#125;</span><br><span class="css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span>;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>以下6个属性设置在容器上。</p><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><p>主轴的方向,（即项目的排列方向）。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li></ul></blockquote><blockquote><ul><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529194849.png" style="zoom:33%;" /><blockquote><ul><li><code>column</code>：主轴为垂直方向，起点在上沿。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529194940.png" style="zoom:33%;" /><blockquote><ul><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195014.png" style="zoom:33%;" /><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><blockquote><ul><li><code>nowrap</code>（默认）：不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul></blockquote><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>定义了项目在主轴上的对齐方式。</p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li></ul></blockquote><blockquote><ul><li><code>flex-end</code>：右对齐</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195131.png" style="zoom:33%;" /><blockquote><ul><li><code>center</code>： 居中</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195153.png" style="zoom:33%;" /><blockquote><ul><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195227.png" style="zoom:33%;" /><blockquote><ul><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195340.png" style="zoom:33%;" /><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>定义项目在交叉轴上如何对齐</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195559.png" style="zoom:33%;" /><blockquote><ul><li><code>flex-end</code>：交叉轴的终点对齐。</li></ul></blockquote><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529195624.png" style="zoom:33%;" /><blockquote><ul><li><code>center</code>：交叉轴的中点对齐。</li></ul></blockquote><img src="/Users/yuroupan/Library/Application Support/typora-user-images/image-20220529195658432.png" alt="image-20220529195658432" style="zoom:33%;" /><p><strong>当把<code>justify-content</code>和<code>align-items</code> 都设置为<code>center</code>, 项目将会水平垂直居中</strong></p><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529200655.png" style="zoom:33%;" /><blockquote><ul><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><p>该属性可能取6个值。</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h2 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><ul><li><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li></ul><img src="https://panyuro.oss-cn-beijing.aliyuncs.com/20220529201004.png" style="zoom:33%;" /><ul><li><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><blockquote><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p></blockquote></li></ul><img src="/Users/yuroupan/Library/Application Support/typora-user-images/image-20220529200011630.png" alt="image-20220529200011630" style="zoom:33%;" /><ul><li><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><blockquote><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p></blockquote></li></ul><p>当把width改成了100，默认项目都会等比例缩小：</p><img src="/Users/yuroupan/Library/Application Support/typora-user-images/image-20220529200129156.png" alt="image-20220529200129156" style="zoom:73%;" /><ul><li><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><blockquote><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库三大范式</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="第一范式-确保每列保持原子性"><a href="#第一范式-确保每列保持原子性" class="headerlink" title="第一范式(确保每列保持原子性)"></a>第一范式(确保每列保持原子性)</h2><p>数据库表中的所有字段值都是不可分解的原子值。</p><ul><li>比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。</li><li>但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</li></ul><h2 id="第二范式-确保表中的每列都和主键相关"><a href="#第二范式-确保表中的每列都和主键相关" class="headerlink" title="第二范式(确保表中的每列都和主键相关)"></a>第二范式(确保表中的每列都和主键相关)</h2><p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。比如：</p><ul><li>订单信息表：订单编号，商品编号，商品名称，商品数量，商品单位，商品价格。联合主键为（订单编号，商品编号）</li><li>存在问题：<br>在该表中，商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。就需要单独存在另一张表里。而不应该在订单信息表里。</li><li>修正：<br>订单：订单编号，商品编号<br>商品：商品名称，商品数量，商品单位，商品价格</li></ul><h2 id="第三范式-确保每列都和主键列直接相关-而不是间接相关"><a href="#第三范式-确保每列都和主键列直接相关-而不是间接相关" class="headerlink" title="第三范式(确保每列都和主键列直接相关,而不是间接相关)"></a>第三范式(确保每列都和主键列直接相关,而不是间接相关)</h2><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。比如：</p><ul><li>学生信息表：学号，姓名，年龄，所在学院，学院联系方式，学院地点。主键：学号</li><li>存在问题：<br>存在依赖传递：学号 → 学院 → (学院地点，学院联系方式)</li><li>修正：<br>学生信息表：学号，姓名，年龄，所在学院<br>学院信息表：学院，学院联系方式，学院地点<br><img src="/assets/16542362929459.jpg"></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hooks的使用</title>
    <link href="/hooks%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/hooks%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p>案例效果：</p><ul><li>点击按钮，文本title修改</li><li>点击按钮，input聚焦<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useRef, PureComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>UseRefDemo<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UseRefDemo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> titleRef = useRef()<br>  <span class="hljs-keyword">const</span> inputRef = useRef()<br>  <span class="hljs-keyword">const</span> testChild = useRef()<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>UseRefDemo<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>= <span class="hljs-string">&#123;titleRef&#125;</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;inputRef&#125;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> changeDom()&#125;&gt;按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">TestChild</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;testChild&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TestChild</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeDom</span>(<span class="hljs-params"></span>)</span>&#123;<br>    titleRef.current.innerHTML = <span class="hljs-string">&quot;改变后的title&quot;</span><br>    inputRef.current.focus()<br>    <span class="hljs-built_in">console</span>.log(testChild)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h261x90pltj20kc0cqmxn.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git修改指定的提交</title>
    <link href="/git%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E7%9A%84%E6%8F%90%E4%BA%A4/"/>
    <url>/git%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E7%9A%84%E6%8F%90%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><code>git rebase --interactive &#39;cffa46f19811496d9165cf2c32250943f94f0099^&#39;</code></li><li>修改</li><li><code>git add .</code></li><li><code>git commit --amend</code></li><li><code>git rebase --continue</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react初体验</title>
    <link href="/react%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/react%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="React是什么？"><a href="#React是什么？" class="headerlink" title="React是什么？"></a>React是什么？</h1><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。</p><blockquote><p>使用最原生的HTML、CSS、JavaScript可以构建完整的用户界面吗？当然可以，但是会存在很多问题</p><ul><li>操作DOM兼容性的问题；</li><li>过多兼容性代码的冗余问题；</li><li>代码组织和规范的问题；</li></ul></blockquote><h1 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h1><h2 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h2><ul><li>声明式编程是目前整个大前端开发的模式：Vue、React、Flutter、SwiftUI</li><li>它允许我们只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界面；</li></ul><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><ul><li>组件化开发页面目前前端的流行趋势</li></ul><h2 id="多平台适配"><a href="#多平台适配" class="headerlink" title="多平台适配"></a>多平台适配</h2><ul><li>2013年，React发布之初主要是开发Web页面</li><li>2015年，Facebook推出了ReactNative，用于开发移动端跨平台（虽然目前Flutter非常火爆，但是还是有很多公司在使用ReactNative）</li><li>2017年，Facebook推出ReactVR，用于开发虚拟现实Web应用程序</li></ul><h2 id="react-开发依赖"><a href="#react-开发依赖" class="headerlink" title="react 开发依赖"></a>react 开发依赖</h2><h3 id="开发React必须依赖三个库："><a href="#开发React必须依赖三个库：" class="headerlink" title="开发React必须依赖三个库："></a>开发React必须依赖三个库：</h3><ul><li>react：包含react所必须的核心代码</li><li>react-dom：react渲染在不同平台所需要的核心代码</li><li>babel：将jsx转换成React代码的工具</li></ul><h2 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入"></a>如何引入</h2><ul><li>cdn引入</li><li>下载后，添加本地依赖</li><li>npm依赖（脚手架使用）</li></ul><h2 id="认识Babel"><a href="#认识Babel" class="headerlink" title="认识Babel"></a>认识Babel</h2><ul><li>babel是目前前端使用非常广泛的编辑器、转移器。</li><li>比如当下很多浏览器并不支持ES6的语法，但是确实ES6的语法非常的简洁和方便，我们开发时希望使用它。</li><li>那么编写源码时我们就可以使用ES6来编写，之后通过Babel工具，将ES6转成大多数浏览器都支持的ES5的语法。</li></ul><blockquote><p>React和Babel的关系：</p><ul><li>默认情况下开发React其实可以不使用babel。</li><li>但是前提是我们自己使用React.createElement来编写源代码，它编写的代码非常的繁琐和可读性差。</li><li>那么我们就可以直接编写jsx（JavaScriptXML）的语法，并且让babel帮助我们转换成React.createElement。</li></ul></blockquote><h1 id="Hello-world案例"><a href="#Hello-world案例" class="headerlink" title="Hello world案例"></a>Hello world案例</h1><ul><li>这里我们编写React的script代码中，必须添加type&#x3D;”text&#x2F;babel”，作用是可以让babel解析jsx的语法</li><li>ReactDOM.render函数：<ul><li>参数一：传递要渲染的内容，这个内容可以是HTML元素，也可以是React的组件</li><li>参数二：将渲染的内容，挂载到哪一个HTML元素上</li></ul></li><li>通过{}语法来引入外部的变量或者表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  &lt;!--添加react 依赖--&gt;<br>  &lt;!-- <span class="hljs-comment">// crossorigin 将远程js的一些错误，显示到本地 --&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>【内容会被覆盖】<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">// render（渲染的内容，挂载的位置）</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">// ReactDOM.render(&lt;h2&gt;hello World&lt;/h2&gt;,document.getElementById(&quot;app&quot;))</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;hello world&quot;</span></span></span><br><span class="javascript"><span class="xml">  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>))</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ps9n22m7j20b204gmx2.jpg" style="zoom:50%;" /><h1 id="HelloReact–-组件化开发"><a href="#HelloReact–-组件化开发" class="headerlink" title="HelloReact– 组件化开发"></a>HelloReact– 组件化开发</h1><ul><li>这里我们暂时使用类的方式封装组件：<ul><li>1.定义一个类（类名大写，组件的名称是必须大写的，小写会被认为是HTML元素），继承自React.Component</li><li>2.实现当前组件的render函数。render当中返回的jsx内容，就是之后React会帮助我们渲染的内容</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>     )<br>   &#125;<br> &#125;<br> ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="组件化-数据依赖"><a href="#组件化-数据依赖" class="headerlink" title="组件化 - 数据依赖"></a>组件化 - 数据依赖</h2><ul><li>组件中的数据，我们可以分成两类：<ul><li>参与界面更新的数据：当数据变量时，需要更新组件渲染的内容</li><li>不参与界面更新的数据：当数据变量时，不需要更新将组建渲染的内容</li></ul></li><li>参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中<ul><li>我们可以通过在构造函数中this.state&#x3D;{定义的数据}</li><li>当我们的数据发生变化时，我们可以调用this.setState来更新数据，并且通知React进行update操作。</li><li>在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs react">class App extends React.Component &#123;<br>  constructor()&#123;<br>    super()<br>    this.state = &#123;<br>     message: &quot;hello world&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组件化-–-事件绑定"><a href="#组件化-–-事件绑定" class="headerlink" title="组件化 – 事件绑定"></a>组件化 – 事件绑定</h2><ul><li><p>在类中直接定义一个函数，并且将这个函数绑定到html原生的onClick事件上，当前这个函数的this指向默认情况下是undefined</p><ul><li>因为在正常的DOM操作中，监听点击，监听函数中的this其实是节点对象（比如说是button对象）；</li><li>React并不是直接渲染成真实的DOM，我们所编写的button只是一个语法糖，它的本质React的Element对象；</li></ul></li><li><p>我们在绑定的函数中，可能想要使用当前对象，比如执行this.setState函数，就必须拿到当前对象的this</p><ul><li><p>我们就需要在传入函数时，给这个函数直接绑定this</p></li><li><p>类似于下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;button onClick=&#123;this.btnClick.bind(this)&#125;&gt;改变文本&lt;/button&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="电影列表案例"><a href="#电影列表案例" class="headerlink" title="电影列表案例"></a>电影列表案例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">super</span>()<br>     <span class="hljs-built_in">this</span>.state = &#123;<br>      <span class="hljs-attr">movies</span>: [<span class="hljs-string">&quot;大话西游&quot;</span>, <span class="hljs-string">&quot;开心农场&quot;</span>]<br>     &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-keyword">return</span> (<br>       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>电影列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">          &#123;</span><br><span class="xml">            this.state.movies.map((item, index)=&gt;&#123;</span><br><span class="xml">            return (<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)</span><br><span class="xml">            &#125;)</span><br><span class="xml">          &#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>     )<br>   &#125;<br> &#125;<br> ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1pub9n1n9j209o07ut8s.jpg" style="zoom:50%;" /><h1 id="计数器案例"><a href="#计数器案例" class="headerlink" title="计数器案例"></a>计数器案例</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">super</span>()<br>     <span class="hljs-built_in">this</span>.state = &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>     &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-keyword">return</span> (<br>       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前计数:&#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;this.incr.bind(this)&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;this.decr.bind(this)&#125;</span>&gt;</span>-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>     )<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-title">incr</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.setState(&#123;<br>       <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br>     &#125;)<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-title">decr</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.setState(&#123;<br>       <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count - <span class="hljs-number">1</span><br>     &#125;)<br>   &#125;<br><br> &#125;<br> ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1puc680j4j20bk090dfu.jpg" style="zoom:50%;" /><p>2ED3-DF39</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构-改善代码已有的设计</title>
    <link href="/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E5%B7%B2%E6%9C%89%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E5%B7%B2%E6%9C%89%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h3><h3 id="replace-temp-with-query-以查询取代临时变量"><a href="#replace-temp-with-query-以查询取代临时变量" class="headerlink" title="replace temp with query(以查询取代临时变量)"></a>replace temp with query(以查询取代临时变量)</h3><ul><li><p>临时变量的问题在于：它们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见，所以它们会驱使你写出更长的函数，因为只有这样你才能访问到需要的临时变量。</p></li><li><p>如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这份信息。这将带给你极大帮助，使你能够为这个类编写更清晰的代码。</p></li></ul><h3 id="6-5-Introduce-Explaining-Variable（引入解释性变量）"><a href="#6-5-Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="6.5 Introduce Explaining Variable（引入解释性变量）"></a><strong>6.5 Introduce Explaining Variable</strong>（引入解释性变量）</h3><ul><li>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</li><li>表达式有可能非常复杂而难以阅读。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。</li></ul><h3 id="6-7-Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#6-7-Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="6.7 Remove Assignments to Parameters（移除对参数的赋值）"></a><strong>6.7 Remove Assignments to Parameters</strong>（移除对参数的赋值）</h3><ul><li><p>参数肤质，降低了代码的清晰度，而且混用了按值传递和按引用传递这两种 参数传递方式。</p></li><li><p>做法建立一个临时变量，把待处理的参数值赋予它。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>重构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react基础</title>
    <link href="/react%E5%9F%BA%E7%A1%80/"/>
    <url>/react%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="react组件基础"><a href="#react组件基础" class="headerlink" title="react组件基础"></a>react组件基础</h1><h2 id="组件概念"><a href="#组件概念" class="headerlink" title="组件概念"></a>组件概念</h2><ul><li>使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。</li><li>所谓组件，即封装起来的具有独立功能的UI部件。组件就是页面上的一部分，大大小小的各种组件拼在一起就变成了一个完整的页面，就像我们玩的拼图，需要一块一块的拼接在一起才能变成一副完整的拼图。</li></ul><h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>使用 JS 的函数（或箭头函数）创建的组件，就叫做<code>函数组件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">function HelloComponent()&#123;<br>  return (<br>    &lt;div&gt;hello Componnet&lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>组件的名称<strong>必须首字母大写</strong>，react内部会根据这个来判断是组件还是普通的HTML标签</p></li><li><p>函数组件<strong>必须有返回值</strong>，表示该组件的 UI 结构；如果不需要渲染任何内容，则返回 null</p></li><li><p>组件就像 HTML 标签一样可以被渲染到页面中。组件表示的是一段结构内容，对于函数组件来说，渲染的内容是函数的<strong>返回值</strong>就是对应的内容</p></li><li><p>使用函数名称作为组件标签名称，可以成对出现也可以自闭合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs react">function App() &#123;<br>  return (<br>    &lt;div&gt;<br>    &lt;HelloComponent/&gt;<br>    &lt;HelloComponent&gt;&lt;/HelloComponent&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><p>使用 ES6 的 class 创建的组件，叫做类（class）组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">class HelloComponent2 extends React.Component&#123;<br>  //必须有一个render方法<br>  //在这个方法里有return UI 结构<br>  render()&#123;<br>    return (<br>      &lt;div&gt;hello Componnet2&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>类名称也必须以大写字母开头</strong></li><li>类组件应该继承 React.Component 父类，从而使用父类中提供的方法或属性</li><li>类组件必须提供 render 方法<strong>render 方法必须有返回值，表示该组件的 UI 结构</strong></li></ul><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>react事件采用驼峰命名法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs react">// 事件触发函数组件<br>function EventDemoClass1()&#123;<br>  function handle()&#123;<br>    console.log(&quot;事件触发了EventDemoClass1&quot;)<br>  &#125;<br>  return (<br>    &lt;button onClick=&#123;handle&#125;&gt;事件触发函数组件&lt;/button&gt;<br>  )<br>&#125;<br><br><br>//事件触发类组件<br>class EventDemoClass2 extends React.Component&#123;<br>  clickHandler = () =&gt; &#123;<br>    console.log(&quot;事件触发了EventDemoClass2&quot;)<br>  &#125;<br>  render()&#123;<br>    return (<br>      &lt;div&gt;<br>        &lt;button onClick=&#123;this.clickHandler&#125;&gt;事件触发类组件&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br>// 根组件<br>function App() &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;EventDemoClass1&gt;&lt;/EventDemoClass1&gt;<br>     &lt;EventDemoClass2&gt;&lt;/EventDemoClass2&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖混乱</title>
    <link href="/%E4%BE%9D%E8%B5%96%E6%B7%B7%E4%B9%B1/"/>
    <url>/%E4%BE%9D%E8%B5%96%E6%B7%B7%E4%B9%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖混乱"><a href="#依赖混乱" class="headerlink" title="依赖混乱"></a>依赖混乱</h1>]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量的初始化</title>
    <link href="/%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h1><blockquote><ul><li><p><strong>重构手法</strong></p><ul><li><p>变量初始化最好一次完成</p></li><li><blockquote><p>能用final的地方建议都用final，包括变量声明，参数声明，类声明，方法声明</p></blockquote></li></ul></li></ul></blockquote><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">EpubStatus status = <span class="hljs-keyword">null</span>;<br>CreateEpubResponse response = createEpub(request);<br><span class="hljs-keyword">if</span> (response.getCode() == <span class="hljs-number">201</span>) &#123;<br>  status = EpubStatus.CREATED;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  status = EpubStatus.TO_CREATE;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题：第一行的初始化没有意义，他真正有值是在第4行或者第6行。也就是说声明变量后很久才赋值。变量初始化和业务混在了一起，我们只有在一大堆逻辑中抽丝剥茧，才可以知道变量是如何初始化的。</li><li>修正：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> CreateEpubResponse response = createEpub(request);<br><span class="hljs-keyword">final</span> EpubStatus status = toEpubStatus(response);<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> EpubStatus <span class="hljs-title">toEpubStatus</span><span class="hljs-params">(<span class="hljs-keyword">final</span> CreateEpubResponse response)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (response.getCode() == <span class="hljs-number">201</span>) &#123;<br>    <span class="hljs-keyword">return</span> EpubStatus.CREATED;<br>  &#125;<br>  <span class="hljs-keyword">return</span> EpubStatus.TO_CREATE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例2（异常处理）"><a href="#案例2（异常处理）" class="headerlink" title="案例2（异常处理）"></a>案例2（异常处理）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream is = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>  is = <span class="hljs-keyword">new</span> FileInputStream(...);<br>  ...<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>  ...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br>    is.close(); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里把is单独声明，是为了在finally里面可以访问到，在早期的版本只能写成这样，java7之后的版本，可以采用<code>try-with-resource</code></p><p>的写法，代码更加简洁。</p><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (InputStream is = <span class="hljs-keyword">new</span> FileInputStream(...)) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例3-集合初始化"><a href="#案例3-集合初始化" class="headerlink" title="案例3 集合初始化"></a>案例3 集合初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Locale, String&gt; CODE_MAPPING = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>...<br><br><br><span class="hljs-keyword">static</span> &#123;<br>  CODE_MAPPING.put(LOCALE.ENGLISH, <span class="hljs-string">&quot;EN&quot;</span>);<br>  CODE_MAPPING.put(LOCALE.CHINESE, <span class="hljs-string">&quot;CH&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>问题： 隔了很久后才向这个集合中添加元素，如果我们可以使用一次性声明的方式，这个static块是不需要的</p><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Locale, String&gt; CODE_MAPPING = ImmutableMap.of(<br>  LOCALE.ENGLISH, <span class="hljs-string">&quot;EN&quot;</span>,<br>  LOCALE.CHINESE, <span class="hljs-string">&quot;CH&quot;</span><br>);<br></code></pre></td></tr></table></figure><blockquote><p>前者是命令式的代码，告诉你“怎么做”，比如先创建一个集合，集合中添加一个元素，再添加一个元素。</p><p>后者是声明式代码，告诉你“做什么”，比如我要一个包含了这两个元素的集合。</p></blockquote><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0xl4gnkf5j20u011vn0m.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫天飞的setter</title>
    <link href="/%E6%BC%AB%E5%A4%A9%E9%A3%9E%E7%9A%84setter/"/>
    <url>/%E6%BC%AB%E5%A4%A9%E9%A3%9E%E7%9A%84setter/</url>
    
    <content type="html"><![CDATA[<h1 id="漫天飞的setter"><a href="#漫天飞的setter" class="headerlink" title="漫天飞的setter"></a>漫天飞的setter</h1><blockquote><ul><li><strong>重构手法</strong>：<ul><li>方法封装在对应的模型中  </li><li>使用构造函数，移除设值函数。</li><li>编写不变类</li></ul></li></ul></blockquote><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">approve</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> bookId)</span> </span>&#123;<br>  ...<br>  book.setReviewStatus(ReviewStatus.APPROVED);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题：使用到了setter, setter往往是缺乏封装的一种做法。你不知道数据会在何时被哪里修改，造成结果是别人的改动可能会使你的代码崩溃，同时会有并发问题</li><li>修正：使用函数封装了setter方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">approve</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> bookId)</span> </span>&#123;<br>  ...<br>  book.approve();<br>  ...<br>&#125; <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">approve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.reviewStatus = ReviewStatus.APPROVED;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进一步重构</strong></p><blockquote><p>重构手法：编写不变类</p></blockquote><p>改造之前的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">approve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Book(..., ReviewStatus.APPROVED, ...);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Book book = <span class="hljs-keyword">new</span> Book();<br>book.setBookId(bookId);<br>book.setTitle(title);<br>book.setIntroduction(introduction);<br></code></pre></td></tr></table></figure><ul><li><p>问题：这种初始化的代码，压根没必要以setter的方式存在</p></li><li><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Book book = <span class="hljs-keyword">new</span> Book(bookId, title, introduction);<br></code></pre></td></tr></table></figure></li></ul><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0um32zjp7j20u01560x5.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过长的消息链和基本类型的偏执</title>
    <link href="/%E8%BF%87%E9%95%BF%E7%9A%84%E6%B6%88%E6%81%AF%E9%93%BE%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%81%8F%E6%89%A7/"/>
    <url>/%E8%BF%87%E9%95%BF%E7%9A%84%E6%B6%88%E6%81%AF%E9%93%BE%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%81%8F%E6%89%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="过长的消息链"><a href="#过长的消息链" class="headerlink" title="过长的消息链"></a>过长的消息链</h1><blockquote><p>想要摆脱初级程序员的水平，首先需要减少暴露细节</p></blockquote><blockquote><p>迪米特法则</p><ul><li>每个单元只能对与他有紧密关系的单元，拥有有限的知识</li><li>每个单元只能和朋友交谈，不与陌生人交谈</li><li>每个单元只能和自己最直接的朋友交谈</li></ul></blockquote><h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String name = book.getAuthor().getName();<br></code></pre></td></tr></table></figure><p>修正方式：隐藏委托关系，即把调用封装起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthorName</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.author.getName();<br>  &#125;<br>  ...<br>&#125;<br><br><br>String name = book.getAuthorName();<br></code></pre></td></tr></table></figure><h1 id="基本类型偏执"><a href="#基本类型偏执" class="headerlink" title="基本类型偏执"></a>基本类型偏执</h1><blockquote><p> <strong>重构手法：以对象取代基本类型</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> highQuality, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> chapterSequence)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：虽然价格是用浮点数在存储，但是价格和浮点数本身并不是同一个概念。</p><p><strong>需求1</strong>: </p><p>价格大于0，如果使用了double来存储，你会怎么限制呢？通常会这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (price &lt;= <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Price should be positive&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种校验会是很多场景都需要的，因此类似的逻辑需要大量去重复的写。</p><p>假设这里引入了price模型会是怎样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Price</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> price;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Price</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> price)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (price &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Price should be positive&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">this</span>.price = price;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样校验就可以放在初始化的时候进行了。</p><blockquote><p>这种手法叫做对象取代基本模型。</p></blockquote><p><strong>需求2:</strong></p><p>假设我们希望价格对外只呈现2位。</p><p>没有price这个模型的话 ，依旧会是散布在代码的各个地方，一旦有了这个模型，代码就简单多了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getDisplayPrice</span><span class="hljs-params">()</span> </span>&#123;<br>  BigDecimal decimal = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-keyword">this</span>.price)；<br>  <span class="hljs-keyword">return</span> decimal.setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP).doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ulmqnc59j20u014cq73.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滥用控制语句</title>
    <link href="/%E6%BB%A5%E7%94%A8%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <url>/%E6%BB%A5%E7%94%A8%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="避免滥用控制语句"><a href="#避免滥用控制语句" class="headerlink" title="避免滥用控制语句"></a>避免滥用控制语句</h1><blockquote><p><strong>函数至多有一行锁进</strong></p></blockquote><blockquote><p>不要用else关键字</p></blockquote><h2 id="代码多层嵌套"><a href="#代码多层嵌套" class="headerlink" title="代码多层嵌套"></a>代码多层嵌套</h2><h3 id="if和else"><a href="#if和else" class="headerlink" title="if和else"></a>if和else</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> highQuality, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> chapterSequence)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> price = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (highQuality &amp;&amp; chapterSequence &gt; START_CHARGING_SEQUENCE) &#123;<br>    price = <span class="hljs-number">4.99</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &gt; START_CHARGING_SEQUENCE<br>        &amp;&amp; sequenceNumber &lt;= FURTHER_CHARGING_SEQUENCE) &#123;<br>    price = <span class="hljs-number">1.99</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &gt; FURTHER_CHARGING_SEQUENCE) &#123;<br>    price = <span class="hljs-number">2.99</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    price = <span class="hljs-number">0.99</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> price;<br>&#125;<br></code></pre></td></tr></table></figure><p>修正：消除else，一个简单的做法就是让逻辑提前返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> highQuality, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> chapterSequence)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (highQuality &amp;&amp; chapterSequence &gt; START_CHARGING_SEQUENCE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4.99</span>;<br>  &#125; <br>  <br>  <span class="hljs-keyword">if</span> (sequenceNumber &gt; START_CHARGING_SEQUENCE<br>        &amp;&amp; sequenceNumber &lt;= FURTHER_CHARGING_SEQUENCE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.99</span>;<br>  &#125; <br><br><br>  <span class="hljs-keyword">if</span> (sequenceNumber &gt; FURTHER_CHARGING_SEQUENCE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2.99</span>;<br>  &#125; <br><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0.99</span>;<br></code></pre></td></tr></table></figure><h2 id="重复的switch"><a href="#重复的switch" class="headerlink" title="重复的switch"></a>重复的switch</h2><p>之所以出现重复的switch，通常是缺少了模型，重构的方式是：<strong>以多态取代表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user, <span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> price = book.getPrice();<br>  <span class="hljs-keyword">switch</span> (user.getLevel()) &#123;<br>    <span class="hljs-keyword">case</span> UserLevel.SILVER:<br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.9</span>;<br>    <span class="hljs-keyword">case</span> UserLevel.GOLD: <br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.8</span>;<br>    <span class="hljs-keyword">case</span> UserLevel.PLATINUM:<br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.75</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> price;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user, <span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> price = epub.getPrice();<br>  <span class="hljs-keyword">switch</span> (user.getLevel()) &#123;<br>    <span class="hljs-keyword">case</span> UserLevel.SILVER:<br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.95</span>;<br>    <span class="hljs-keyword">case</span> UserLevel.GOLD: <br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.85</span>;<br>    <span class="hljs-keyword">case</span> UserLevel.PLATINUM:<br>      <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.8</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> price;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(Book book)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(Epub epub)</span></span>;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegularUserLevel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> book.getPrice();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> epub.getPrice();<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoldUserLevel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> book.getPrice() * <span class="hljs-number">0.8</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> epub.getPrice() * <span class="hljs-number">0.85</span>;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SilverUserLevel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> book.getPrice() * <span class="hljs-number">0.9</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> epub.getPrice() * <span class="hljs-number">0.85</span>;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlatinumUserLevel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserLevel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> book.getPrice() * <span class="hljs-number">0.75</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> epub.getPrice() * <span class="hljs-number">0.8</span>; <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBookPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user, <span class="hljs-keyword">final</span> Book book)</span> </span>&#123;<br>  UserLevel level = user.getUserLevel()<br>  <span class="hljs-keyword">return</span> level.getBookPrice(book);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEpubPrice</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user, <span class="hljs-keyword">final</span> Epub epub)</span> </span>&#123;<br>  UserLevel level = user.getUserLevel()<br>  <span class="hljs-keyword">return</span> level.getEpubPrice(epub);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0tg6oeum7j20u012242l.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长参数列表</title>
    <link href="/%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/"/>
    <url>/%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="消除长参数列表"><a href="#消除长参数列表" class="headerlink" title="消除长参数列表"></a>消除长参数列表</h1><ul><li><blockquote><p><strong>我们应该编写“短小”的代码</strong></p></blockquote></li><li><blockquote><p> <strong>参数列表越少，越好</strong></p></blockquote></li><li><blockquote><p>**一个方法的第一选择是没有参数，第二个选择是只有一个参数，稍次是两个参数。三个以上的参数简直无法忍受。 **– 代码整洁之道</p></blockquote></li></ul><h2 id="将参数列表封装成对象"><a href="#将参数列表封装成对象" class="headerlink" title="将参数列表封装成对象"></a>将参数列表封装成对象</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBook</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String title, </span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> String introduction,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> URL coverUrl,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> BookType type,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> BookChannel channel,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> String protagonists,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> String tags,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> completed)</span> </span>&#123;<br>  ...<br>  Book book = Book.builder<br>    .title(title) <br>    .introduction(introduction)<br>    .coverUrl(coverUrl)<br>    .type(type)<br>    .channel(channel)<br>    .protagonists(protagonists)<br>    .tags(tags)<br>    .completed(completed)<br>    .build();<br>    <br>  <span class="hljs-keyword">this</span>.repository.save(book);<br>&#125;<br></code></pre></td></tr></table></figure><p>修正：</p><ul><li>增加一个封装类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewBookParamters</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String title;<br>  <span class="hljs-keyword">private</span> String introduction;<br>  <span class="hljs-keyword">private</span> URL coverUrl;<br>  <span class="hljs-keyword">private</span> BookType type;<br>  <span class="hljs-keyword">private</span> BookChannel channel;<br>  <span class="hljs-keyword">private</span> String protagonists;<br>  <span class="hljs-keyword">private</span> String tags;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> completed;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBook</span><span class="hljs-params">(<span class="hljs-keyword">final</span> NewBookParamters parameters)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移除标记参数"><a href="#移除标记参数" class="headerlink" title="移除标记参数"></a>移除标记参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">editChapter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> chapterId, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> String title, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> String content, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> apporved)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：前几个参数都是章节的必要信息，后面apporved是标记是否审核通过，这个参数其实是一个标记，标记后面的流程可能不同。</p><p>修正：这里我们可以将参数列表代表的不同路径拆分出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 普通的编辑，需要审核</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">editChapter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> chapterId, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> String title, </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> String content)</span> </span>&#123;<br>  ...<br>&#125;<br><br><br><span class="hljs-comment">// 直接审核通过的编辑</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">editChapterWithApproval</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> chapterId,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">final</span> String title,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">final</span> String content)</span> </span>&#123;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0tf9jp9lvj20u014kq7o.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>避免写出难以理解的大类</title>
    <link href="/%E9%81%BF%E5%85%8D%E5%86%99%E5%87%BA%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84%E5%A4%A7%E7%B1%BB%20/"/>
    <url>/%E9%81%BF%E5%85%8D%E5%86%99%E5%87%BA%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84%E5%A4%A7%E7%B1%BB%20/</url>
    
    <content type="html"><![CDATA[<h2 id="避免写出难以理解的大类"><a href="#避免写出难以理解的大类" class="headerlink" title="避免写出难以理解的大类"></a>避免写出难以理解的大类</h2><ul><li>原因：一个人理解的东西是有限的，没人能面对所有的细节</li><li>大类的产生：<ul><li>职责不单一 </li><li>字段未分组</li></ul></li><li>操作要点：<strong>把类写小，越小越好</strong></li></ul><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1:"></a>案例1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String nickname;<br>  <span class="hljs-keyword">private</span> String email;<br>  <span class="hljs-keyword">private</span> String phoneNumber;<br>  <span class="hljs-keyword">private</span> AuthorType authorType;<br>  <span class="hljs-keyword">private</span> ReviewStatus authorReviewStatus;<br>  <span class="hljs-keyword">private</span> EditorType editorType;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：userId,name这些是和用户关联的，后面的AuthorType，ReviewStatus，EditorType和用户信息无关</p><p>修正：AuthorType，ReviewStatus，EditorType和用户信息无关 拆成单独的类，通过userId去关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> AuthorType authorType;<br>  <span class="hljs-keyword">private</span> ReviewStatus authorReviewStatus;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Editor</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> EditorType editorType;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String nickname;<br>  <span class="hljs-keyword">private</span> String email;<br>  <span class="hljs-keyword">private</span> String phoneNumber;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：这个类中userId，name，nickname是属于用户的基本信息，而email，phoneNumber其实是属于用户的联系方式</p><p>修正：对字段进行分组，把email，phoneNumber放在单独的contact类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String nickname;<br>  <span class="hljs-keyword">private</span> Contact contact;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contact</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String email;<br>  <span class="hljs-keyword">private</span> String phoneNumber;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0tekaz2v6j20u0144gow.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何精准命名</title>
    <link href="/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="如何精准命名"><a href="#如何精准命名" class="headerlink" title="如何精准命名"></a>如何精准命名</h1><h2 id="避免命名过于宽泛"><a href="#避免命名过于宽泛" class="headerlink" title="避免命名过于宽泛"></a>避免命名过于宽泛</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processChapter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> chapterId)</span> </span>&#123;<br>  Chapter chapter = <span class="hljs-keyword">this</span>.repository.findByChapterId(chapterId);<br>  <span class="hljs-keyword">if</span> (chapter == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unknown chapter [&quot;</span> + chapterId + <span class="hljs-string">&quot;]&quot;</span>);  <br>  &#125;<br>  <br>  chapter.setTranslationState(TranslationState.TRANSLATING);<br>  <span class="hljs-keyword">this</span>.repository.save(chapter);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>问题：命名过于宽泛，不能精准描述，只有阅读这段代码，才可以知道这段代码做了什么。</p></li><li><p>修正：具体到这里的业务，其实是把翻译状态改为了翻译中，是因为我们在这里开启了一个翻译过程，所以这段代码应该命名为satrtTranslation</p></li></ul><blockquote><p> 类似的：data,info,handle,build,maintain,modify等等，都是过于宽泛的名词</p></blockquote><blockquote><p>一个好的名字，应该描述意图，而不是细节。</p></blockquote><h2 id="避免使用技术术语命名"><a href="#避免使用技术术语命名" class="headerlink" title="避免使用技术术语命名"></a>避免使用技术术语命名</h2><h3 id="案例1-1"><a href="#案例1-1" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Book&gt; bookList = service.getBooks();<br></code></pre></td></tr></table></figure><ul><li>问题：这是一种基于实现的命名，编程的一个重要原则是面向接口编程。即接口是稳定的，实现是易变的。假设这里我现在需要的是一个不重复的作品集合，也就是说这里需要把List改成Set，变量类型一定会改，但是你不一定会记得改变量名，一旦遗忘，就会出现一个bookList变量，它的类型是set,就会产生混淆。</li><li>修正：这里要表达的是拿到一堆书，所以这个命名改为books。</li></ul><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getByIsbn</span><span class="hljs-params">(String isbn)</span> </span>&#123;<br>  Book cachedBook = redisBookStore.get(isbn);<br>  <span class="hljs-keyword">if</span> (cachedBook != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> cachedBook;<br>  &#125;<br>  <br>  Book book = doGetByIsbn(isbn);<br>  redisBookStore.put(isbn, book);<br>  <span class="hljs-keyword">return</span> book;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题：这段代码里直接出现了redis，通常来说这里真正需要的只是一个缓存，redi s只是一种实现</li></ul><blockquote><p>缓存只是一种技术术语，不应该出现在业务代码中</p></blockquote><blockquote><p>程序猿之所以喜欢用技术语言去命名，是因为程序员写代码很大程度上会参考别人写的代码，而行业里比较优秀的一些代码，往往是一些开源的技术项目。</p></blockquote><blockquote><p>在一个技术类项目里，这些技术术语其实就是他们的业务语言，但是在业务项目里，这个说法就要另当别论了。</p></blockquote><h2 id="避免违反语法规则的命名"><a href="#避免违反语法规则的命名" class="headerlink" title="避免违反语法规则的命名"></a>避免违反语法规则的命名</h2><h3 id="案例1-2"><a href="#案例1-2" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completedTranslate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> List&lt;ChapterId&gt; chapterIds)</span> </span>&#123;<br>  List&lt;Chapter&gt; chapters = repository.findByChapterIdIn(chapterIds);<br>  chapters.forEach(Chapter::completedTranslate);<br>  repository.saveAll(chapters); <br>&#125;<br></code></pre></td></tr></table></figure><p>问题：completedTranslate不是一个正常的英语函数名</p><p>修正: completeTranslation</p><blockquote><p>常见的命名规则是：类是一个名词，表示一个对象。方法名是一个动词或者是动宾短语，表示一个动作。</p></blockquote><p>另外还有两个常见的坏味道这里就不举例了。</p><ul><li>不准确的英语词汇（对于业务上会用到的一些名词，可以整个团队一起，建立一个业务词汇表，用集体的智慧）</li><li>单词拼写错误</li></ul><h2 id="用业务语言写代码"><a href="#用业务语言写代码" class="headerlink" title="用业务语言写代码"></a>用业务语言写代码</h2><h3 id="案例1-3"><a href="#案例1-3" class="headerlink" title="案例1"></a>案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">approveChapter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> chapterId, <span class="hljs-keyword">long</span> userId)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：这个函数的意图是确认章节通过，chapterId是章节id，但是userId是什么？了解了背景才知道这里是需要记录下审核人的信息，这个userId就是审核人的userId，</p><p>修正：因为用户在这个场景下的身份是审核人，所以修改userId为reviewerUserId</p><blockquote><p>好的命名，是体现业务含义的命名。</p></blockquote><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oruapf6nj20u012ggpo.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>代码之丑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码坏味道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excel读取操作</title>
    <link href="/excel%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C/"/>
    <url>/excel%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="excel-读取"><a href="#excel-读取" class="headerlink" title="excel 读取"></a>excel 读取</h1><h2 id="HSSF-03"><a href="#HSSF-03" class="headerlink" title="HSSF(03)"></a>HSSF(03)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRead03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(PATH+<span class="hljs-string">&quot;/excel写入.xls&quot;</span>);<br>  <span class="hljs-keyword">final</span> HSSFWorkbook workbook = <span class="hljs-keyword">new</span> HSSFWorkbook(inputStream);<br>  <span class="hljs-keyword">final</span> HSSFSheet sheet = workbook.getSheetAt(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> HSSFRow row = sheet.getRow(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> HSSFCell cell = row.getCell(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 读取值的时候，一定要注意类型！！</span><br>  <span class="hljs-keyword">final</span> String cellValue = cell.getStringCellValue();<br>  System.out.println(cellValue);<br>  inputStream.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="XSSF-07"><a href="#XSSF-07" class="headerlink" title="XSSF(07)"></a>XSSF(07)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRead07</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(PATH+<span class="hljs-string">&quot;/excel写入.xlsx&quot;</span>);<br>  <span class="hljs-keyword">final</span> XSSFWorkbook workbook = <span class="hljs-keyword">new</span> XSSFWorkbook(inputStream);<br>  <span class="hljs-keyword">final</span> XSSFSheet sheet = workbook.getSheetAt(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> XSSFRow row = sheet.getRow(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> XSSFCell cell = row.getCell(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">final</span> String cellValue = cell.getStringCellValue();<br>  System.out.println(cellValue);<br>  inputStream.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读取不同类型的数据"><a href="#读取不同类型的数据" class="headerlink" title="读取不同类型的数据"></a>读取不同类型的数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCellType</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/Users/panyurou/IdeaProjects/exceldemo/src/test/resources/明细表.xlsx&quot;</span>);<br>    <span class="hljs-keyword">final</span> XSSFWorkbook workbook = <span class="hljs-keyword">new</span> XSSFWorkbook(inputStream);<br>    <span class="hljs-comment">// 读取标题行</span><br>    <span class="hljs-keyword">final</span> XSSFSheet sheet = workbook.getSheetAt(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">final</span> XSSFRow headerRow = sheet.getRow(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> colCount = headerRow.getPhysicalNumberOfCells();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; colCount; i++) &#123;<br>      <span class="hljs-keyword">final</span> XSSFCell cell = headerRow.getCell(i);<br>      <span class="hljs-keyword">if</span>(cell != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">final</span> String cellValue = cell.getStringCellValue();<br>        System.out.print(cellValue + <span class="hljs-string">&quot;|&quot;</span>);<br>      &#125;<br>    &#125;<br>    System.out.println();<br>    <span class="hljs-comment">// 读取内容</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rowsCount = sheet.getPhysicalNumberOfRows();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rowsCount; i++) &#123;<br>      <span class="hljs-keyword">final</span> XSSFRow row = sheet.getRow(i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; colCount; j++) &#123;<br>        <span class="hljs-keyword">final</span> XSSFCell cell = row.getCell(j);<br>        <span class="hljs-keyword">if</span>(cell != <span class="hljs-keyword">null</span>)&#123;<br>          <span class="hljs-keyword">final</span> CellType cellType = cell.getCellType();<br>          String cellValue = getCellValue(cell, cellType);<br>          System.out.print(cellValue + <span class="hljs-string">&quot;|&quot;</span>);<br>        &#125;<br>      &#125;<br>      System.out.println();<br>    &#125;<br>    inputStream.close();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getCellValue</span><span class="hljs-params">(XSSFCell cell, CellType cellType)</span> </span>&#123;<br>    String cellValue = <span class="hljs-string">&quot;&quot;</span>;<br>     <span class="hljs-keyword">switch</span> (cellType)&#123;<br>      <span class="hljs-keyword">case</span> STRING:<br>        cellValue = cell.getStringCellValue();<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> NUMERIC:<br>         <span class="hljs-keyword">if</span>(DateUtil.isCellDateFormatted(cell))&#123;<br>           <span class="hljs-keyword">final</span> Date date = cell.getDateCellValue();<br>           cellValue = <span class="hljs-keyword">new</span> DateTime(date).toString(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>           cellValue = String.valueOf(cell.getNumericCellValue());<br>         &#125;<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> FORMULA:<br>        cellValue = cell.getCellFormula();<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> BOOLEAN:<br>        cellValue = String.valueOf(cell.getBooleanCellValue());<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> ERROR:<br>         System.out.println(<span class="hljs-string">&quot;类型错误&quot;</span>);<br>         <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cellValue;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>excel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>poi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excel大数据量的写入</title>
    <link href="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%86%99%E5%85%A5/"/>
    <url>/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%86%99%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="大数据量的写入"><a href="#大数据量的写入" class="headerlink" title="大数据量的写入"></a>大数据量的写入</h1><h2 id="HSSF-03版"><a href="#HSSF-03版" class="headerlink" title="HSSF(03版)"></a>HSSF(03版)</h2><ul><li><p>优点：过程中数据全部写入缓存，不操作磁盘，最后一次写入缓存，速度快</p></li><li><p>缺点：最多只能处理65536行，否则会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Invalid row <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">65536</span>)</span> outside allowable <span class="hljs-title">range</span> <span class="hljs-params">(<span class="hljs-number">0.</span><span class="hljs-number">.65535</span>)</span></span><br><span class="hljs-function">java.lang.IllegalArgumentException: Invalid row <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">65536</span>)</span> outside allowable <span class="hljs-title">range</span> <span class="hljs-params">(<span class="hljs-number">0.</span><span class="hljs-number">.65535</span>)</span></span><br></code></pre></td></tr></table></figure></li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p><strong>抛出异常测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelBigData</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String PATH = <span class="hljs-string">&quot;/Users/panyurou/IdeaProjects/exceldemo&quot;</span>;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excelWrite03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Workbook workbook = <span class="hljs-keyword">new</span> HSSFWorkbook();<br>    <span class="hljs-keyword">final</span> Sheet sheet = workbook.createSheet(<span class="hljs-string">&quot;测试大数据量&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">65537</span>; i++) &#123;<br>      <span class="hljs-keyword">final</span> Row row = sheet.createRow(i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>        <span class="hljs-keyword">final</span> Cell cell = row.createCell(j);<br>        cell.setCellValue(<span class="hljs-string">&quot;$&#123;i,j&#125;&quot;</span>);<br>      &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;over!&quot;</span>);<br>    FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(PATH + <span class="hljs-string">&quot;/excel大数据写入01.xls&quot;</span>);<br>    workbook.write(outputStream);<br>    outputStream.close();<br>    System.out.println(<span class="hljs-string">&quot;excel 写入完毕！&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;写入时间：&quot;</span>+(<span class="hljs-keyword">double</span>) ((end - begin) / <span class="hljs-number">1000</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gq3hs5kyj22520hq44v.jpg"></p><p>将上面的65537改成65536，输出写入时长，可看出花费了1秒</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gq6x1kfuj21720a6dgq.jpg"></p><h2 id="SXSSFWorkbook"><a href="#SXSSFWorkbook" class="headerlink" title="SXSSFWorkbook"></a>SXSSFWorkbook</h2><ul><li>优点：可以写非常大的数据量，写速度更快，占用更少的内存</li><li>注意：<ul><li>过程中会产生临时文件，需要清理临时文件</li><li>默认100条数据会被保留在内存中，如果超过这数量，则数据会被写入临时文件<ul><li>如果想自定义内存中的数量，可以使用<code>new SXSSFWorkbook(数量);</code></li></ul></li></ul></li></ul><h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excelWriteSXSSF</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SXSSFWorkbook workbook = <span class="hljs-keyword">new</span> SXSSFWorkbook();<br>    <span class="hljs-keyword">final</span> Sheet sheet = workbook.createSheet(<span class="hljs-string">&quot;测试大数据量&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">65537</span>; i++) &#123;<br>      <span class="hljs-keyword">final</span> Row row = sheet.createRow(i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">120</span>; j++) &#123;<br>        <span class="hljs-keyword">final</span> Cell cell = row.createCell(j);<br>        cell.setCellValue(<span class="hljs-string">&quot;$&#123;i,j&#125;&quot;</span>);<br>      &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;over!&quot;</span>);<br>    FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(PATH + <span class="hljs-string">&quot;/excel大数据写入09s.xlsx&quot;</span>);<br>    workbook.write(outputStream);<br>    outputStream.close();<br>    <span class="hljs-comment">// 清除临时文件！！！</span><br>    workbook.dispose();<br>    System.out.println(<span class="hljs-string">&quot;excel 写入完毕！&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;写入时间：&quot;</span>+(<span class="hljs-keyword">double</span>) ((end - begin) / <span class="hljs-number">1000</span>));<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看出即使现在有120列，也只需要10秒，速度很快。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nlyeermoj211409wgme.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>excel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>poi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excel基本写操作</title>
    <link href="/excel%E6%93%8D%E4%BD%9C/"/>
    <url>/excel%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Excel基本写操作"><a href="#Excel基本写操作" class="headerlink" title="Excel基本写操作"></a>Excel基本写操作</h1><ul><li>引入依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;org.apache.poi:poi:5.2.0&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelWrite</span> </span>&#123;<br>  <span class="hljs-comment">// 项目目录</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String PATH = <span class="hljs-string">&quot;/Users/panyurou/IdeaProjects/exceldemo&quot;</span>;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excelWrite</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//1.创建一个工作簿</span><br>    Workbook workbook = <span class="hljs-keyword">new</span> HSSFWorkbook();<br>    <span class="hljs-comment">//2.创建一个工作表</span><br>    Sheet sheet = workbook.createSheet(<span class="hljs-string">&quot;测试excel写入&quot;</span>);<br>    <span class="hljs-comment">//3.创建一行,第0行</span><br>    Row row1 = sheet.createRow(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//4.创建一个单元格</span><br>    Cell cell11 = row1.createCell(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//5.给单元格写入值</span><br>    cell11.setCellValue(<span class="hljs-string">&quot;我是单元格（1，1）&quot;</span>);<br><br>    <span class="hljs-comment">//6.创建新的一行,第1行</span><br>    Row row2 = sheet.createRow(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//7.创建一个单元格</span><br>    Cell cell21 = row2.createCell(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//8.给单元格写入值</span><br>    String time = <span class="hljs-keyword">new</span> DateTime().toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    cell21.setCellValue(time);<br><br>    <span class="hljs-comment">//9.将创建好的工作簿写出</span><br>    FileOutputStream outputStream = <span class="hljs-keyword">new</span> FileOutputStream(PATH + <span class="hljs-string">&quot;/excel写入.xlsx&quot;</span>);<br>    workbook.write(outputStream);<br>    outputStream.close();<br>    System.out.println(<span class="hljs-string">&quot;excel 写入完毕！&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gpje9k7lj20os0r6jt6.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>excel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>poi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch乐观并发控制</title>
    <link href="/ElasticSearch%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/ElasticSearch%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch乐观并发控制"><a href="#Elasticsearch乐观并发控制" class="headerlink" title="Elasticsearch乐观并发控制"></a>Elasticsearch乐观并发控制</h1><p>Elasticsearch 中使用的这种乐观的方式假定冲突是不可能发生的，并且不会阻塞正在 尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。 </p><blockquote><p>在数据库领域中，有两种方法来确保并发更新，不会丢失数据： 分别为乐观和悲观</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以创建一个文档为例 </p><p>step1: 创建文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /test1/_doc/<span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三丰&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;_index&quot;</span> : <span class="hljs-string">&quot;test1&quot;</span>,<br>  <span class="hljs-string">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>  <span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-string">&quot;_version&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;result&quot;</span> : <span class="hljs-string">&quot;created&quot;</span>,<br>  <span class="hljs-string">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;total&quot;</span> : <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;successful&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;failed&quot;</span> : <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-string">&quot;_seq_no&quot;</span> : <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;_primary_term&quot;</span> : <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用if_seq_no&#x3D;版本值 &amp;if_primary_term&#x3D;文档位置进行并发版本控制</strong></p><ul><li><p>_seq_no：文档版本号，<strong>version属于当个文档，而seq_no属于整个index</strong></p></li><li><p>_primary_term：_primary_term也和_seq_no一样都是整数，每当Primary Shard发生重新分配时，比如重启，Primary选举等，_primary_term会递增1</p></li></ul><p>step2: 更新文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /test1/_update/<span class="hljs-number">1</span>/?if_seq_no=<span class="hljs-number">0</span>&amp;if_primary_term=<span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;doc&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三丰666&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;_index&quot;</span> : <span class="hljs-string">&quot;test1&quot;</span>,<br>  <span class="hljs-string">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>  <span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-string">&quot;_version&quot;</span> : <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;result&quot;</span> : <span class="hljs-string">&quot;updated&quot;</span>,<br>  <span class="hljs-string">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;total&quot;</span> : <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;successful&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;failed&quot;</span> : <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-string">&quot;_seq_no&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;_primary_term&quot;</span> : <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch文档映射</title>
    <link href="/ElasticSearch%E6%96%87%E6%A1%A3%E6%98%A0%E5%B0%84/"/>
    <url>/ElasticSearch%E6%96%87%E6%A1%A3%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="文档映射"><a href="#文档映射" class="headerlink" title="文档映射"></a>文档映射</h1><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>ES中映射可以分为动态映射和静态映射 </p><h3 id="动态映射："><a href="#动态映射：" class="headerlink" title="动态映射："></a>动态映射：</h3><p>在关系数据库中，需要事先创建数据库，然后在该数据库下创建数据表，并创建 表字段、类型、长度、主键等，最后才能基于表插入数据。而Elasticsearch中不需要定义Mapping映射（即关系型数据库的表、字段等），在文档写入Elasticsearch时，会根据文档字段自动识别类型，这种机制称之为动态映射。 </p><p>动态映射规则如下： </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h00k181remj21fm0jqgn5.jpg"></p><p><strong>操作示例</strong></p><ul><li>创建文档(ES根据数据类型, 会自动创建映射)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db1/_doc/<span class="hljs-number">32</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王武&quot;</span>,<br>  <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">28</span>,<br>  <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;remark&quot;</span>: <span class="hljs-string">&quot;java developer&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取文档映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GET /es_db1/_mapping<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;es_db1&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;mappings&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;properties&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;address&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;fields&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;keyword&quot;</span> : &#123;<br>              <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span>,<br>              <span class="hljs-string">&quot;ignore_above&quot;</span> : <span class="hljs-number">256</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;age&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;long&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;name&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;fields&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;keyword&quot;</span> : &#123;<br>              <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span>,<br>              <span class="hljs-string">&quot;ignore_above&quot;</span> : <span class="hljs-number">256</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;remark&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;fields&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;keyword&quot;</span> : &#123;<br>              <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span>,<br>              <span class="hljs-string">&quot;ignore_above&quot;</span> : <span class="hljs-number">256</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;sex&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;long&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态映射："><a href="#静态映射：" class="headerlink" title="静态映射："></a>静态映射：</h3><p>静态映射是在Elasticsearch中也可以事先定义好映射，包含文档的各字段类型、分词器等，这种方式称之为静态映射。 </p><p><strong>操作示例</strong></p><ul><li>创建索引和设置文档映射 <ul><li>index: 是否分词存储</li><li>store: 是否存储在库里</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">PUT /es_db4<br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;sex&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;age&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;book&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;address&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-keyword">true</span>,<br>        <span class="hljs-string">&quot;store&quot;</span>: <span class="hljs-keyword">true</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;es_db4&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;mappings&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;properties&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;address&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;age&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;integer&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;book&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;name&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;sex&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : <span class="hljs-string">&quot;integer&quot;</span>,<br>          <span class="hljs-string">&quot;store&quot;</span> : <span class="hljs-keyword">true</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据静态映射创建文档</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">PUT /es_db/_doc/<span class="hljs-number">4</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jack&quot;</span>,<br>  <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-string">&quot;book&quot;</span>: <span class="hljs-string">&quot;elasticSearch入门至精通&quot;</span>,<br>  <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;广州车陂&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取文档映射</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET <span class="hljs-regexp">/es_db4/</span>_mapping<br></code></pre></td></tr></table></figure><h2 id="文档核心类型（Core-datatype）"><a href="#文档核心类型（Core-datatype）" class="headerlink" title="文档核心类型（Core datatype）"></a>文档核心类型（Core datatype）</h2><h3 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h3><ul><li>字符串：string，string类型包含 text 和 keyword。 </li><li>text：该类型被用来索引长文本，在创建索引前会将这些文本进行分词，转化为词的组合，建立索引；允许es来检索这些词，text类型不能用来排序和聚合。</li><li>keyword：该类型不能分词，可以被用来检索过滤、排序和聚合，keyword类型不可用text进行分词模糊检索。</li><li>数值型：long、integer、short、byte、double、float </li><li>日期型：date </li><li>布尔型：boolean</li></ul><p><strong>通过term 和 match查询数据时细节点以及数据类型keyword与text区别</strong></p><ul><li><strong>term查询</strong><ul><li>term查询keyword字段: term不会分词。而keyword字段也不分词。需要完全匹配才可</li><li>term查询text字段: 因为text字段会分词，而term不分词，所以term查询的条件必须是text字段分词后的某一个</li></ul></li><li><strong>match查询</strong><ul><li>match会被分词，而keyword不会被分词，match的需要跟keyword的完全匹配可以。</li><li>match分词，text也分词，只要match的分词结果和text的分词结果有相同的就匹配</li></ul></li></ul><h2 id="对已存在的mapping映射进行修改"><a href="#对已存在的mapping映射进行修改" class="headerlink" title="对已存在的mapping映射进行修改"></a>对已存在的mapping映射进行修改</h2><ul><li>重新建立一个静态索引 ,把之前索引里的数据导入到新的索引里</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">POST _reindex<br>&#123;<br>  <span class="hljs-string">&quot;source&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;es_db&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dest&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;es_db_2&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：_reindex 会同时把之前索引里的数据导入到新的索引里 </p></blockquote><ul><li>删除原创建的索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hava">DELETE /es_db<br></code></pre></td></tr></table></figure><ul><li>为新索引起个别名, 为原索引名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PUT /es_db_2/_alias/es_db<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch-DSL语言高级查询</title>
    <link href="/ElasticSearch-DSL%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/"/>
    <url>/ElasticSearch-DSL%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="DSL语言高级查询"><a href="#DSL语言高级查询" class="headerlink" title="DSL语言高级查询"></a>DSL语言高级查询</h1><ul><li>Elasticsearch提供了基于JSON的DSL来定义查询。 </li><li>DSL由叶子查询子句和复合查询子句两种子句组成</li></ul><blockquote><p>DSL(Domain Specific Language)领域专用语言 </p></blockquote><h2 id="无查询条件"><a href="#无查询条件" class="headerlink" title="无查询条件"></a>无查询条件</h2><p>无查询条件是查询所有，默认是查询所有的，或者使用match_all表示所有 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">GET /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有查询条件"><a href="#有查询条件" class="headerlink" title="有查询条件"></a>有查询条件</h2><h3 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h3><ul><li><p>模糊匹配主要是针对文本类型的字段</p></li><li><p>文本类型的字段会对内容进行分词，对查询时，也会对搜索条件进行分词，然后通过倒排索引查找到匹配的数据</p></li><li><p>模糊匹配主要通过match等参数来实现 </p><ul><li>match : 通过match关键词模糊匹配条件内容,match会根据该字段的分词器，进行分词查询</li><li>prefix : 前缀匹配</li><li>regexp : 通过正则表达式来匹配数据</li></ul></li></ul><p> <strong>举例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;广州&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SQL: select * from user where address like ‘%广州%’ limit 0, 2 </p></blockquote><ul><li>多字段模糊匹配查询 multi_match</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;广州公园&quot;</span>,<br>      <span class="hljs-string">&quot;fields&quot;</span>: [<br>        <span class="hljs-string">&quot;address&quot;</span>,<br>        <span class="hljs-string">&quot;name&quot;</span><br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SQL: select * from student where name like ‘%广州公园%’ or address like ‘%广州公园%’ </p></blockquote><ul><li>未指定字段条件查询 query_string , 含 AND 与 OR 条件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search<br>&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;query_string&quot;: &#123;<br>      &quot;query&quot;: &quot;(广州) OR 长沙&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>指定字段条件查询 query_string , 含 AND 与 OR 条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;query_string&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;(广州) OR 长沙&quot;</span>,<br>      <span class="hljs-string">&quot;fields&quot;</span>:[<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>范围查询<ul><li>range：范围关键字 </li><li>gte 大于等于</li><li>lte 小于等于 </li><li>gt 大于 </li><li>lt 小于</li><li>now 当前时间</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;range&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;age&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;gte&quot;</span>:<span class="hljs-number">25</span>,<br>        <span class="hljs-string">&quot;lte&quot;</span>:<span class="hljs-number">28</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SQL: select * from user where age between 25 and 28 </p></blockquote><ul><li>分页、输出字段、排序综合查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;range&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;age&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;gte&quot;</span>:<span class="hljs-number">25</span>,<br>        <span class="hljs-string">&quot;lte&quot;</span>:<span class="hljs-number">28</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;_source&quot;</span>: [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;book&quot;</span>],<br>  <span class="hljs-string">&quot;sort&quot;</span>: &#123;<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-string">&quot;desc&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Filter过滤器方式查询"><a href="#Filter过滤器方式查询" class="headerlink" title="Filter过滤器方式查询"></a>Filter过滤器方式查询</h2><p>它的查询不会计算相关性分值，也不会对结果进行排序, 因此效率会高一点，查询的结果可以被缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /es_db/_doc/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;term&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>match: 模糊匹配，需要指定字段名，但是输入会进行分词，比如”hello world”会进行拆分为hello和world，然后匹配，如果字段中包含hello或者 world，或者都包含的结果都会被查询出来，也就是说match是一个部分匹配的模糊查询。查询条件相对来说比较宽松。 </p></li><li><p>term：这种查询和match在有些时候是等价的，比如我们查询单个的词hello，那么会和match查询结果一样，但是如果查询”hello world”，结果就相差很大，因为这个输入不会进行分词，就是说查询的时候，是查询字段分词结果中是否有”hello world”的字样，而不是查询字段中包含”hello world”的字样。当保存 </p><p>数据”hello world”时，elasticsearch会对字段内容进行分词，”hello world”会被分成hello和world，不存在”hello world”，因此这里的查询结果会为空。这也是term查询和match的区别。</p></li><li><p>query_string：和match类似，但是match需要指定字段名，query_string是在所 </p><p>有字段中搜索，范围更广泛。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch文档批量操作</title>
    <link href="/ElasticSearch%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/"/>
    <url>/ElasticSearch%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="文档批量操作"><a href="#文档批量操作" class="headerlink" title="文档批量操作"></a><strong>文档批量操作</strong></h1><h2 id="批量获取文档数据"><a href="#批量获取文档数据" class="headerlink" title="批量获取文档数据"></a>批量获取文档数据</h2><blockquote><p>批量获取文档数据是通过_mget的API来实现的 </p></blockquote><h3 id="在URL中不指定index和type"><a href="#在URL中不指定index和type" class="headerlink" title="在URL中不指定index和type"></a>在URL中不指定index和type</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> _mget<br>&#123;<br>  &quot;docs&quot;: [<br>    &#123;<br>      &quot;_index&quot;: &quot;es_db&quot;,<br>      &quot;_type&quot;: &quot;_doc&quot;,<br>      &quot;_id&quot;: <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      &quot;_index&quot;: &quot;es_db&quot;,<br>      &quot;_type&quot;: &quot;_doc&quot;,<br>      &quot;_id&quot;: <span class="hljs-number">2</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在URL中指定index"><a href="#在URL中指定index" class="headerlink" title="在URL中指定index"></a>在URL中指定index</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_mget<br>&#123;<br>  &quot;docs&quot;: [<br>    &#123;<br>      &quot;_type&quot;: &quot;_doc&quot;,<br>      &quot;_id&quot;: <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      &quot;_type&quot;: &quot;_doc&quot;,<br>      &quot;_id&quot;: <span class="hljs-number">2</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在URL中指定index和type"><a href="#在URL中指定index和type" class="headerlink" title="在URL中指定index和type"></a>在URL中指定index和type</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_mget<br>&#123;<br>  &quot;docs&quot;: [<br>    &#123;<br>      &quot;_id&quot;: <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      &quot;_id&quot;: <span class="hljs-number">2</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="批量操作文档数据"><a href="#批量操作文档数据" class="headerlink" title="批量操作文档数据"></a>批量操作文档数据</h2><ul><li><p>批量对文档进行写操作是通过_bulk的API来实现的 </p></li><li><p>通过_bulk操作文档，一般至少有两行参数(或偶数行参数) </p><ul><li>第一行参数为指定操作的类型及操作的对象 (index,type和id) </li><li>第二行参数才是操作的数据</li></ul><p>参数类似于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-string">&quot;actionName&quot;</span>:&#123;<span class="hljs-string">&quot;_index&quot;</span>:<span class="hljs-string">&quot;indexName&quot;</span>, <span class="hljs-string">&quot;_type&quot;</span>:<span class="hljs-string">&quot;typeName&quot;</span>,<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;id&quot;</span>&#125;&#125;<br>&#123;<span class="hljs-string">&quot;field1&quot;</span>:<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;field2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="批量创建文档create"><a href="#批量创建文档create" class="headerlink" title="批量创建文档create"></a>批量创建文档create</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _bulk<br>&#123;<br>  &quot;create&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;id&quot;: <span class="hljs-number">3</span>,<br>  &quot;title&quot;: &quot;文章1&quot;,<br>  &quot;content&quot;: &quot;内容1&quot;,<br>  &quot;tags&quot;: [<br>    &quot;tag1&quot;,<br>    &quot;tag2&quot;<br>  ],<br>  &quot;create_time&quot;: <span class="hljs-number">1554015482530</span><br>&#125;<br>&#123;<br>  &quot;create&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">4</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;id&quot;: <span class="hljs-number">4</span>,<br>  &quot;title&quot;: &quot;文章2&quot;,<br>  &quot;content&quot;: &quot;内容2&quot;,<br>  &quot;tags&quot;: [<br>    &quot;tag3&quot;,<br>    &quot;tag4&quot;<br>  ],<br>  &quot;create_time&quot;: <span class="hljs-number">1554015482530</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="普通创建或全量替换index"><a href="#普通创建或全量替换index" class="headerlink" title="普通创建或全量替换index"></a>普通创建或全量替换index</h3><ul><li>如果原文档不存在，则是创建 </li><li>如果原文档存在，则是替换(全量修改原文档)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _bulk<br>&#123;<br>  &quot;index&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;id&quot;: <span class="hljs-number">3</span>,<br>  &quot;title&quot;: &quot;更新后的文章1&quot;,<br>  &quot;content&quot;: &quot;更新后的内容1&quot;,<br>  &quot;tags&quot;: [<br>    &quot;tag1&quot;,<br>    &quot;tag2&quot;<br>  ],<br>  &quot;create_time&quot;: <span class="hljs-number">1554015482530</span><br>&#125;<br>&#123;<br>  &quot;index&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">5</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;id&quot;: <span class="hljs-number">5</span>,<br>  &quot;title&quot;: &quot;文章5&quot;,<br>  &quot;content&quot;: &quot;内容5&quot;,<br>  &quot;tags&quot;: [<br>    &quot;tag5&quot;,<br>    &quot;tag14&quot;<br>  ],<br>  &quot;create_time&quot;: <span class="hljs-number">1554015482530</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="批量修改update"><a href="#批量修改update" class="headerlink" title="批量修改update"></a>批量修改update</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _bulk<br>&#123;<br>  &quot;update&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;doc&quot;: &#123;<br>    &quot;title&quot;: &quot;更新后的文章11&quot;,<br>    &quot;content&quot;: &quot;更新后的内容11&quot;<br>  &#125;<br>&#125;<br>&#123;<br>  &quot;update&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">5</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;doc&quot;: &#123;<br>    &quot;title&quot;: &quot;文章51&quot;,<br>    &quot;content&quot;: &quot;内容51&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="批量删除delete"><a href="#批量删除delete" class="headerlink" title="批量删除delete"></a>批量删除delete</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _bulk<br>&#123;<br>  &quot;delete&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br>&#123;<br>  &quot;delete&quot;: &#123;<br>    &quot;_index&quot;: &quot;article&quot;,<br>    &quot;_type&quot;: &quot;_doc&quot;,<br>    &quot;_id&quot;: <span class="hljs-number">4</span><br>  &#125;<br>&#125;s<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch数据管理</title>
    <link href="/ES%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <url>/ES%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="ES数据管理"><a href="#ES数据管理" class="headerlink" title="ES数据管理"></a>ES数据管理</h1><h2 id="ES数据管理概述"><a href="#ES数据管理概述" class="headerlink" title="ES数据管理概述"></a>ES数据管理概述</h2><ul><li>ES是面向文档(document oriented)的，这意味着它可以存储整个对象或文档 (document)。</li><li>然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。</li><li>在ES中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。</li><li>ES使用JSON作为文档序列化格式。</li></ul><p><strong>ES存储的一个员工文档的格式示例：</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123; <br> &quot;email&quot;: &quot;584614151@qq.com&quot;,<br> &quot;name&quot;: &quot;张三&quot;, <br> &quot;age&quot;: <span class="hljs-number">30</span>,<br> &quot;interests&quot;: [ &quot;篮球&quot;, &quot;健身&quot; ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>JSON现在已经被大多语言所支持，而且已经成为NoSQL领域的标准格式。 </p></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>格式: PUT &#x2F;索引名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>es_db<br></code></pre></td></tr></table></figure><h3 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h3><p>格式: GET &#x2F;索引名称 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<br></code></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>格式: DELETE &#x2F;索引名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-operator">/</span>es_db<br></code></pre></td></tr></table></figure><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><ul><li>格式: POST &#x2F;索引名称&#x2F;类型&#x2F;id(可选，不传会创建默认的id)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<br>&#123;<br>  &quot;name&quot;: &quot;张三&quot;,<br>  &quot;sex&quot;: <span class="hljs-number">1</span>,<br>  &quot;age&quot;: <span class="hljs-number">25</span>,<br>  &quot;address&quot;: &quot;广州天河公园&quot;,<br>  &quot;remark&quot;: &quot;java developer&quot;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>格式: PUT &#x2F;索引名称&#x2F;类型&#x2F;id</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span><br>&#123;<br>  &quot;name&quot;: &quot;张三&quot;,<br>  &quot;sex&quot;: <span class="hljs-number">1</span>,<br>  &quot;age&quot;: <span class="hljs-number">25</span>,<br>  &quot;address&quot;: &quot;广州天河公园&quot;,<br>  &quot;remark&quot;: &quot;java developer&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><ul><li>格式: PUT &#x2F;索引名称&#x2F;类型&#x2F;id</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span><br>&#123;<br>  &quot;name&quot;: &quot;张三&quot;,<br>  &quot;sex&quot;: <span class="hljs-number">1</span>,<br>  &quot;age&quot;: <span class="hljs-number">25</span>,<br>  &quot;address&quot;: &quot;广州天河公园&quot;,<br>  &quot;remark&quot;: &quot;java developer&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><p>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;id </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>格式: DELETE &#x2F;索引名称&#x2F;类型&#x2F;id </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="查询当前类型中的所有文档-search"><a href="#查询当前类型中的所有文档-search" class="headerlink" title="查询当前类型中的所有文档 _search"></a>查询当前类型中的所有文档 _search</h4><p> 格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search </p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search <br></code></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li><p>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;<em>:</em>** </p></li><li><p>SQL: select * from student where age &#x3D; 28</p></li></ul><p>举例：如要查询age等于28岁的 _search?q&#x3D;<em>:</em>** </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age:<span class="hljs-number">28</span> <br></code></pre></td></tr></table></figure><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;***[25 TO 26] </li><li>SQL: select * from student where age between 25 and 26</li></ul><p>举例：如要查询age在25至26岁之间的 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age[<span class="hljs-number">25</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">26</span>] <br></code></pre></td></tr></table></figure><p><strong>注意: TO 必须为大写</strong> </p><h5 id="大于"><a href="#大于" class="headerlink" title="大于"></a>大于</h5><ul><li>格式:  GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;age:&gt;** </li><li>SQL: select * from student where age &gt; 28</li></ul><p>举例：查询年龄大于28的 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age:<span class="hljs-operator">&gt;</span><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h5 id="小于等于"><a href="#小于等于" class="headerlink" title="小于等于"></a>小于等于</h5><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;age:&lt;&#x3D;** </li><li>SQL: select * from student where age &lt;&#x3D; 28</li></ul><p>举例：查询年龄小于等于28岁的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age:<span class="hljs-operator">&lt;=</span><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h4 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h4><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_mget </li><li>SQL: select * from student where id in (1,2)</li></ul><p>举例：根据多个ID进行批量查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_mget<br>&#123;<br>  &quot;ids&quot;:[&quot;3&quot;,&quot;2&quot;]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul><li><p>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?q&#x3D;age[25 TO 26]&amp;from&#x3D;0&amp;size&#x3D;1 </p></li><li><p>SQL: select * from student where age between 25 and 26 limit 0, 1</p></li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?q<span class="hljs-operator">=</span>age[<span class="hljs-number">25</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">26</span>]<span class="hljs-operator">&amp;</span><span class="hljs-keyword">from</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-operator">&amp;</span>size<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="查询结果只输出某些字段"><a href="#查询结果只输出某些字段" class="headerlink" title="查询结果只输出某些字段"></a>查询结果只输出某些字段</h4><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?_source&#x3D;字段,字段</li><li>SQL: select name,age from student</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?_source<span class="hljs-operator">=</span>name,age<br></code></pre></td></tr></table></figure><h4 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h4><ul><li>格式: GET &#x2F;索引名称&#x2F;类型&#x2F;_search?sort&#x3D;字段 desc </li><li>SQL: select * from student order by age desc</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span> <span class="hljs-operator">/</span>es_db<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span>_search?sort<span class="hljs-operator">=</span>age:<span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch安装</title>
    <link href="/Elasticsearch%E5%AE%89%E8%A3%85/"/>
    <url>/Elasticsearch%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h1><p>1.下载es.  Es 下载链接： <a href="https://www.elastic.co/cn/downloads/elasticsearch">Download Elasticsearch | Elastic</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb4g30d6ij30u00vn0vf.jpg"></p><p>2.解压后在bin路径下，运行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  bin .<span class="hljs-operator">/</span>elasticsearch <span class="hljs-operator">-</span>d<br></code></pre></td></tr></table></figure><p>3.访问<a href="http://localhost:9200/">localhost:9200</a>,看到下面的页面即启动成功</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb4gkb3paj313k0u078b.jpg"></p><h1 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h1><ol><li>Kibana 下载链接：<a href="https://www.elastic.co/cn/downloads/kibana">Download Kibana Free | Get Started Now | Elastic</a></li></ol><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz32m89db4j30u00yigof.jpg" style="zoom:50%;" /><ol start="2"><li>修改 kibana.yml</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">server.port: <span class="hljs-number">5601</span><br>server.host: &quot;localhost&quot;<br>elasticsearch.hosts: [&quot;http://localhost:9200&quot;]<br></code></pre></td></tr></table></figure><p>3.访问<a href="http://localhost:5601/app/kibana">http://localhost:5601/app/kibana</a>, 看到下面的页面即启动成功</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz32vfqn6kj31be0u00vp.jpg" style="zoom:50%;" /><h1 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h1><p>我们后续也需要使用Elasticsearch来进行中文分词，所以需要单独给Elasticsearch安装IK分词器插件。以下为具体安装步骤：</p><ol><li><p>下载ElasticsearchIK分词器 <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p></li><li><p>在es的安装目录下&#x2F;plugins创建ik，将下载的ik分词器上传并解压到该目录</p></li><li><p>重启Elasticsearch</p></li></ol>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">查找进程命令 ps <span class="hljs-operator">-</span>ef <span class="hljs-operator">|</span> grep elastic<br>杀掉进程 kill <span class="hljs-number">-9</span> <span class="hljs-number">2382</span>（进程号）<br></code></pre></td></tr></table></figure><ol start="4"><li>测试分词效果，访问<a href="http://localhost:5601/app/dev_tools#/console">Dev Tools - Elastic</a></li></ol>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _analyze<br>&#123;<br>&quot;analyzer&quot;:&quot;standard&quot;,<br>&quot;text&quot;:&quot;我爱你中国&quot;<br>&#125;<br></code></pre></td></tr></table></figure>   <img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb43jrro7j30l60xgwhh.jpg" style="zoom:50%;" />   <img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb4579turj30l60csgm9.jpg" style="zoom:50%;" /><ul><li>ik_smart:会做最粗粒度的拆分</li></ul>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _analyze<br>&#123;<br>&quot;analyzer&quot;:&quot;ik_smart&quot;,<br>&quot;text&quot;:&quot;我爱你中国&quot;<br>&#125;<br></code></pre></td></tr></table></figure>   <img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb40eub0hj30qk0mmmyq.jpg" style="zoom:50%;" /><ul><li>k_max_word:会将文本做最细粒度的拆分</li></ul>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST _analyze<br>&#123;<br>&quot;analyzer&quot;:&quot;ik_max_word&quot;,<br>&quot;text&quot;:&quot;我爱你中国&quot;<br>&#125;<br></code></pre></td></tr></table></figure>   <img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb419wozoj30r40sutb1.jpg" style="zoom:50%;" />   <h1 id="指定IK分词器作为默认分词器"><a href="#指定IK分词器作为默认分词器" class="headerlink" title="指定IK分词器作为默认分词器"></a>指定IK分词器作为默认分词器</h1><p>​        ES的默认分词设置是standard，这个在中文分词时就比较尴尬了，会单字拆分，比如我搜索关键词“清华大学”，这时候会按“清”，“华”，“大”，“学”去分词，然后搜出来的都是些“清清的河水”，“中华儿女”，“地大物博”，“学而不思则罔”之类的莫名其妙的结果，</p><p>​        这里我们就想把这个分词方式修改一下，于是呢，就想到了ik分词器，有两种ik_smart和ik_max_word。ik_smart会将“清华大学”整个分为一个词，而ik_max_word会将“清华大学”分为“清华大学”，“清华”和“大学”，按需选其中之一就可以了。修改默认分词方法(这里修改school_index索引的默认分词为：ik_max_word)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>school_index<br>&#123;<br>  &quot;settings&quot;:&#123;<br>    &quot;index&quot;:&#123;<br>      &quot;analysis.analyzer.default.type&quot;:&quot;ik_max_word&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8s9sdy4tj30im07g0t6.jpg" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch集群搭建</title>
    <link href="/ElasticSearch%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/ElasticSearch%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch集群搭建"><a href="#ElasticSearch集群搭建" class="headerlink" title="ElasticSearch集群搭建"></a>ElasticSearch集群搭建</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="集群cluster"><a href="#集群cluster" class="headerlink" title="集群cluster"></a>集群cluster</h3><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能</p><h3 id="节点node"><a href="#节点node" class="headerlink" title="节点node"></a>节点node</h3><ul><li>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据。参与集群的索引和搜索功能。</li><li>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中。这意味着，如果在网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</li><li>在一个集群里，可以拥有任意多个节点。而且，如果当前网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</li></ul><h3 id="分片和副本shards-amp-replicas"><a href="#分片和副本shards-amp-replicas" class="headerlink" title="分片和副本shards&amp;replicas"></a>分片和副本shards&amp;replicas</h3>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickHouse的SQL操作</title>
    <link href="/clickHouse%E7%9A%84SQL%E6%93%8D%E4%BD%9C-1/"/>
    <url>/clickHouse%E7%9A%84SQL%E6%93%8D%E4%BD%9C-1/</url>
    
    <content type="html"><![CDATA[<h1 id="ClickHouse的SQL操作"><a href="#ClickHouse的SQL操作" class="headerlink" title="ClickHouse的SQL操作"></a>ClickHouse的SQL操作</h1><p>基本上来说传统关系型数据库（以 MySQL 为例）的 SQL 语句，ClickHouse 基本都支持，这里不会从头讲解 SQL 语法只介绍 ClickHouse 与标准 SQL（MySQL）不一致的地方</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>基本与标准 SQL（MySQL）基本一致</p><p>（1）标准</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> [table_name] <span class="hljs-keyword">values</span>(…),(….)<br></code></pre></td></tr></table></figure><p>（2）从表到表的插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> [table_name] <span class="hljs-keyword">select</span> a,b,c <span class="hljs-keyword">from</span> [table_name_2]<br></code></pre></td></tr></table></figure><h2 id="Update-和Delete"><a href="#Update-和Delete" class="headerlink" title="Update 和Delete"></a>Update 和Delete</h2><ul><li><p>ClickHouse 提供了 Delete 和 Update 的能力，这类操作被称为 Mutation 查询，它可以看做 Alter 的一种。</p></li><li><p>虽然可以实现修改和删除，但是和一般的 OLTP 数据库不一样，<strong>Mutation</strong> 语句是一种很重的操作，而且不支持事务。</p><blockquote><p>“重”的原因主要是每次修改或者删除都会导致放弃目标数据的原有分区，重建新分区。合并的时候才会删除原有分区，所以尽量做批量的变更，不要进行频繁小数据的操作。</p></blockquote></li></ul><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_smt <span class="hljs-keyword">delete</span> <span class="hljs-keyword">where</span> sku_id <span class="hljs-operator">=</span><span class="hljs-string">&#x27;sku_001&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_smt update total_amount<span class="hljs-operator">=</span>toDecimal32(<span class="hljs-number">2000.00</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">102</span>;<br></code></pre></td></tr></table></figure><h3 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h3><p>clickhouse虽然支持 Delete 和 Update 的能力，但是这类操作很重，一般建议不要使用，如果要使用，都可以采用增加数据的方式来实现，如更新的话，可以给列新加版本号；删除的话，可以增加一列删除标记为：delete_at，但这样会造成数据膨胀，可以定期删除失效的数据。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>ClickHouse 基本上与标准 SQL 差别不大</p><p>➢ 支持子查询</p><p>➢ 支持 CTE(Common Table Expression 公用表表达式 with 子句) </p><p>➢ 支持各种 JOIN，但是 JOIN 操作无法使用缓存，所以即使是两次相同的 JOIN 语句，ClickHouse 也会视为两条新 SQL</p><p>➢ 窗口函数</p><p>➢ 不支持自定义函数</p><p>➢ GROUP BY 操作增加了 with rollup\with cube\with total 用来计算小计和总计。</p><p><strong>演示</strong></p><p>（1）插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">bfdf602492c9 :)  <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_mt <span class="hljs-keyword">delete</span> <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>bfdf602492c9 :) <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt <span class="hljs-keyword">values</span><br>                (<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">103</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">104</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">105</span>,<span class="hljs-string">&#x27;sku_003&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">106</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-04 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">107</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-04 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">108</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-04 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">109</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-04 12:00:00&#x27;</span>),<br>                (<span class="hljs-number">110</span>,<span class="hljs-string">&#x27;sku_003&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（2）with rollup：从右至左去掉维度进行小计</p><p>可以看出分别根据  【id,sku_id】【id】【(空)】 进行了分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">bfdf602492c9 :) <span class="hljs-keyword">select</span> id , sku_id,<span class="hljs-built_in">sum</span>(total_amount) <span class="hljs-keyword">from</span> t_order_mt <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id,sku_id <span class="hljs-keyword">with</span> <span class="hljs-keyword">rollup</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1rqitalcj30hg0tamz1.jpg"></p><p>（3）with cube : 从右至左去掉维度进行小计，再从左至右去掉维度进行小计</p><p>可以看出分别根据  【id,sku_id】【id】【sku_id】【(空)】 进行了分组</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1rt0556dj30hu0x0di6.jpg"></p><p>（4）with totals: 只计算合计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">bfdf602492c9 :)  <span class="hljs-keyword">select</span> id , sku_id,<span class="hljs-built_in">sum</span>(total_amount) <span class="hljs-keyword">from</span> t_order_mt <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>                id,sku_id <span class="hljs-keyword">with</span> totals;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1rutq1qaj30j20im75i.jpg"></p><h2 id="alter操作"><a href="#alter操作" class="headerlink" title="alter操作"></a>alter操作</h2><p>同 MySQL 的修改字段基本一致</p><p>1）新增字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tableName <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> newcolname String after col1; <br></code></pre></td></tr></table></figure><p>2）修改字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tableName modify <span class="hljs-keyword">column</span> newcolname String; <br></code></pre></td></tr></table></figure><p>3）删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tableName <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> newcolname; <br></code></pre></td></tr></table></figure><blockquote><p>更多语法参考：<a href="https://clickhouse.com/docs/en/sql-reference/">ClickHouse Documentation</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse表引擎</title>
    <link href="/clickhouse%E8%A1%A8%E5%BC%95%E6%93%8E/"/>
    <url>/clickhouse%E8%A1%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="表引擎介绍"><a href="#表引擎介绍" class="headerlink" title="表引擎介绍"></a>表引擎介绍</h1><p>表引擎是 ClickHouse 的一大特色。不同的引擎有不同的作用，可以说， 表引擎决定了如何存储表的数据。包括：</p><p>➢ 数据的存储方式和位置，写到哪里以及从哪里读取数据。 （一般的引擎都存在磁盘中，但是存在与其他数据库继承的场景，比如和mysql集成，数据放在mysql服务端。）</p><p>➢ 支持哪些查询以及如何支持。（有些语法只有在特定的引擎才可以使用，比如不能在 MergeTree 表中存储多维数组）</p><p>➢ 并发数据访问。（可以多线程执行同一条sql）</p><p>➢ 索引的使用（如果存在）。</p><p>➢ 是否可以执行多线程请求。</p><p>➢ 数据复制参数。</p><blockquote><p>表引擎的使用方式就是必须显式在创建表时定义该表使用的引擎，以及引擎使用的相关参数。</p></blockquote><p><strong>特别注意：引擎的名称大小写敏感</strong></p><h1 id="合并树家族"><a href="#合并树家族" class="headerlink" title="合并树家族"></a>合并树家族</h1><h2 id="MergeTree"><a href="#MergeTree" class="headerlink" title="MergeTree"></a><strong>MergeTree</strong></h2><ul><li>ClickHouse 中最强大的表引擎当属 MergeTree（合并树）引擎及该系列（*MergeTree）</li></ul><p>中的其他引擎，支持索引和分区，地位可以相当于 innodb 之于 Mysql。而且基于 MergeTree，</p><ul><li>还衍生除了很多小弟，也是非常有特色的引擎。</li></ul><ol><li><p>建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>),<br>create_time Datetime<br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id,sku_id);<br></code></pre></td></tr></table></figure></li><li><p><strong>插入数据</strong></p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><h4 id="partition-by-分区"><a href="#partition-by-分区" class="headerlink" title="partition by 分区"></a><strong>partition by</strong> 分区</h4><h5 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h5><p>分区的目的主要是降低扫描的范围，优化查询速度</p><h5 id="2-可选"><a href="#2-可选" class="headerlink" title="2. 可选"></a>2. 可选</h5><p>可选的，如果不填，只会使用一个分区。</p><h5 id="3-分区目录"><a href="#3-分区目录" class="headerlink" title="3.分区目录"></a>3.<strong>分区目录</strong></h5><p>MergeTree 是以列文件+索引文件+表定义文件组成的，但是如果设定了分区那么这些文</p><p>件就会保存到不同的分区目录中。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0c4bfsguj30rw0iqjtg.jpg"></p><h5 id="4-并行"><a href="#4-并行" class="headerlink" title="4.并行"></a>4.<strong>并行</strong></h5><p>分区后，面对涉及跨分区的查询统计，ClickHouse 会以分区为单位并行处理。</p><h5 id="5-数据写入与分区合并"><a href="#5-数据写入与分区合并" class="headerlink" title="5.数据写入与分区合并"></a>5.<strong>数据写入与分区合并</strong></h5><ul><li><p>任何一个批次的数据写入都会产生一个临时分区，不会纳入任何一个已有的分区。</p></li><li><p>写入后的某个时刻（大概 10-15 分钟后），ClickHouse 会自动执行合并操作。</p></li><li><p>也可以手动通过 optimize 执行，把临时分区的数据，合并到已有分区中。语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">optimize <span class="hljs-keyword">table</span> xxxx <span class="hljs-keyword">final</span>;<br></code></pre></td></tr></table></figure><p>如：</p><ul><li>再次执行上面的插入操作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>查看数据并没有纳入任何分区</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0c7984cnj30ui0s8wi5.jpg"></p></li><li><p>手动 optimize 之后，再次查询  <img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0c8dbd1bj30og0y6tce.jpg"></p></li></ul><h4 id="primary-key-主键"><a href="#primary-key-主键" class="headerlink" title="primary key 主键"></a><strong>primary key</strong> <strong>主键</strong></h4><ul><li>ClickHouse 中的主键，和其他数据库不太一样，<strong>它只提供了数据的一级索引，但是却不</strong></li></ul><p><strong>是唯一约束。</strong>这就意味着是可以存在相同 primary key 的数据的。</p><ul><li><p>主键的设定主要依据是查询语句中的 where 条件。</p></li><li><p>根据条件通过对主键进行某种形式的二分查找，能够定位到对应的 index granularity（粒度）,避免了全表扫描。</p><blockquote><p>index granularity： 直接翻译的话就是索引粒度，指在稀疏索引中两个相邻索引对应数据的间隔。ClickHouse 中的 MergeTree 默认是 8192。官方不建议修改这个值，除非该列存在大量重复值，比如在一个分区中几万行才有一个不同数据。</p></blockquote><p><strong>稀疏索引：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0cf9ividj31460nigq3.jpg"></p><p>稀疏索引的好处就是可以用很少的索引数据，定位更多的数据，代价就是只能定位到索引粒度的第一行，然后再进行进行一点扫描。</p><blockquote><p>比如要查找id为15151的数据，可以判断出他大于10101 小于32343 ，因此会在这个区域内进行查找，类似的根据二分查找定位到具体的值。</p></blockquote></li></ul><h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a><strong>order by</strong></h4><ul><li><p>order by 设定了分区内的数据按照哪些字段顺序进行有序保存。</p></li><li><p>order by 是 MergeTree 中唯一一个必填项，甚至比 primary key 还重要，因为当用户不</p><p>设置主键的情况，很多处理会依照 order by 的字段进行处理（比如后面会讲的去重和汇总）。</p></li><li><p><strong>要求：主键必须是 order by 字段的前缀字段</strong>。比如 order by 字段是 (id,sku_id) 那么主键必须是 id 或者(id,sku_id)</p></li></ul><h3 id="跳数索引"><a href="#跳数索引" class="headerlink" title="跳数索引"></a>跳数索引</h3><ul><li><p>MergeTree支持二级索引，又称之为跳数索引，是由数据的聚合信息构建而成。跳数索引的目录也是帮助查询，减少数据扫描的范围。</p></li><li><p>此索引在 <code>CREATE</code> 语句的列部分里定义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">INDEX index_name expr TYPE type(...) GRANULARITY granularity_value<br></code></pre></td></tr></table></figure><ul><li><p><code>*MergeTree</code> 系列的表可以指定跳数索引。</p></li><li><p>跳数索引是指数据片段按照粒度(建表时指定的<code>index_granularity</code>)分割成小块后，将上述SQL的granularity_value数量的小块组合成一个大的块，对这些大块写入索引信息。</p></li><li><p>这样有助于使用<code>where</code>筛选时跳过大量不必要的数据，减少<code>SELECT</code>需要读取的数据量。</p></li><li><p>如：创建测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt2(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>),<br>create_time Datetime,<br>INDEX a total_amount TYPE minmax GRANULARITY <span class="hljs-number">5</span><br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure><blockquote><p>其中 GRANULARITY N 是设定二级索引对于一级索引粒度的粒度。</p><p>即一级索引为[1,3],[3,6],[6,9] ，对应的二级索引范围为[1,9]，将3个一级索引进行了合并，这样查找时就不需要根据一级索引去进行比较，直接根据二级索引就可以。</p></blockquote></li></ul></li></ul><blockquote><p> 目前在 ClickHouse 的官网上二级索引的功能在 v20.1.2.4 之前是被标注为实验性的，在这个版本之后默认是开启的。 </p></blockquote><h3 id="数据-TTL"><a href="#数据-TTL" class="headerlink" title="数据 TTL"></a><strong>数据</strong> <strong>TTL</strong></h3><ul><li><p>TTL 即 Time To Live，TTL用于设置值的生命周期，它既可以为整张表设置，也可以为每个列字段单独设置。表级别的 TTL 还会指定数据在磁盘和卷上自动转移的逻辑（也就是数据过期后可以移动到指定磁盘上）。</p></li><li><p>TTL 表达式的计算结果必须是 <a href="https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/mergetree/">日期</a> 或 <a href="https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/mergetree/">日期时间</a> 类型的字段。</p></li><li><p><code>TTL</code>子句不能被用于主键字段。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">TTL time_column<br>TTL time_column <span class="hljs-operator">+</span> <span class="hljs-type">interval</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-列级别-TTL"><a href="#1-列级别-TTL" class="headerlink" title="1.列级别 TTL"></a>1.<strong>列级别</strong> <strong>TTL</strong></h4><p>当列中的值过期时, ClickHouse会将它们替换成该列数据类型的默认值。如果数据片段中列的所有值均已过期，则ClickHouse 会从文件系统中的数据片段中删除此列。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>创建表时指定 <code>TTL</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> example_table<br>(<br>    d DateTime,<br>    a <span class="hljs-type">Int</span> TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">MONTH</span>,<br>    b <span class="hljs-type">Int</span> TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">MONTH</span>,<br>    c String<br>)<br>ENGINE <span class="hljs-operator">=</span> MergeTree<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(d)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> d;<br></code></pre></td></tr></table></figure><p>为表中已存在的列字段添加 <code>TTL</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> example_table<br>    MODIFY <span class="hljs-keyword">COLUMN</span><br>    c String TTL d <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>;<br></code></pre></td></tr></table></figure><p><strong>案例演示</strong></p><ul><li><p>创建测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_mt7(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) TTL create_time<span class="hljs-operator">+</span><span class="hljs-type">interval</span> <span class="hljs-number">10</span> <span class="hljs-keyword">SECOND</span>,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>MergeTree<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure></li><li><p>插入数据（注意：根据实际时间改变）</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_mt7 <span class="hljs-keyword">values</span><br>(<span class="hljs-number">106</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2022-02-03 10:44:32&#x27;</span>),<br>(<span class="hljs-number">107</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2022-02-03 10:44:32&#x27;</span>),<br>(<span class="hljs-number">110</span>,<span class="hljs-string">&#x27;sku_003&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2022-02-04 19:20:30&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0ik5e2dtj30ns0fe0u6.jpg"></p><ul><li><p>手动合并，查看效果 到期后，指定的字段数据归 0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">optimize <span class="hljs-keyword">table</span> t_order_mt7 <span class="hljs-keyword">final</span>;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0ilgoy7mj30tc120wi1.jpg"></p><h4 id="2-表-TTL"><a href="#2-表-TTL" class="headerlink" title="2.表 TTL"></a>2.表 TTL</h4><ul><li><p>表可以设置一个用于移除过期行的表达式，以及多个用于在磁盘或卷上自动转移数据片段的表达式。当表中的行过期时，ClickHouse 会删除所有对应的行。对于数据片段的转移特性，必须所有的行都满足转移条件。</p></li><li><p>下面的这条语句是数据会在 create_time 之后 10 秒丢失</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_order_mt3 MODIFY TTL create_time <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">10</span> <span class="hljs-keyword">SECOND</span>;<br></code></pre></td></tr></table></figure></li></ul><h5 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h5><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0iqo7gd7j30ze0m476i.jpg"></p><h2 id="ReplacingMergeTree"><a href="#ReplacingMergeTree" class="headerlink" title="ReplacingMergeTree"></a>ReplacingMergeTree</h2><ul><li><p>ReplacingMergeTree 是 MergeTree 的一个变种，它存储特性完全继承 MergeTree，只是多了一个去重的功能。 </p></li><li><p>尽管 MergeTree 可以设置主键，但是 primary key 其实没有唯一约束的功能。如果你想处理掉重复的数据，可以借助这个 ReplacingMergeTree。</p></li></ul><h3 id="去重时机"><a href="#去重时机" class="headerlink" title="去重时机"></a><strong>去重时机</strong></h3><p>数据的去重只会在同一批插入（新版本）或合并的过程中出现。合并会在未知的时间在后台进行，所以你无法预</p><p>先作出计划。有一些数据可能仍未被处理。</p><h3 id="去重范围"><a href="#去重范围" class="headerlink" title="去重范围"></a><strong>去重范围</strong></h3><ul><li><p>如果表经过了分区，去重只会在分区内部进行去重，不能执行跨分区的去重。</p></li><li><p>所以 ReplacingMergeTree 能力有限， ReplacingMergeTree 适用于在后台清除重复的数据以节省空间，但是它不保证没有重复的数据出现。</p></li></ul><h3 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a><strong>案例演示</strong></h3><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_rmt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) ,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>ReplacingMergeTree(create_time)<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id, sku_id);<br></code></pre></td></tr></table></figure><ul><li><p>ReplacingMergeTree() 填入的参数为版本字段，重复数据保留版本字段值最大的。</p></li><li><p>如果不填版本字段，默认按照插入顺序保留最后一条。</p></li></ul><p>（2）向表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_rmt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（3）执行第一次查询</p><p>可以看到插入的数据是根据id和sku_id 去重过的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_order_rmt;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0of9u8h5j30ps0j00ui.jpg"></p><p>（4）再次插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_rmt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>(5) 再次查询，可以看到这次依旧只插入了4条数据，但是和第一次插入的数据没有进行去重，依旧存在重复数据。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0olyjbfej30oo0qgjuc.jpg"></p><p>（6）手动合并</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">OPTIMIZE <span class="hljs-keyword">TABLE</span> t_order_rmt <span class="hljs-keyword">FINAL</span>;<br></code></pre></td></tr></table></figure><p>  (7) 再执行一次查询，此时数据已经根据分区进行了最终去重。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0ovmauddj30ow0imjt6.jpg"></p><h3 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h3><p>➢ 实际上是使用 order by 字段作为唯一键</p><p>➢ 去重不能跨分区</p><p>➢ 只有同一批插入（新版本）或合并分区时才会进行去重</p><p>➢ 认定重复的数据保留，版本字段值最大的</p><p>➢ 如果版本字段相同则按插入顺序保留最后一笔</p><h2 id="SummingMergeTree"><a href="#SummingMergeTree" class="headerlink" title="SummingMergeTree"></a><strong>SummingMergeTree</strong></h2><ul><li><p>对于不查询明细，只关心以维度进行汇总聚合结果的场景。如果只使用普通的MergeTree的话，无论是存储空间的开销，还是查询时临时聚合的开销都比较大。</p></li><li><p>ClickHouse 为了这种场景，提供了一种能够“预聚合”的引擎 SummingMergeTree</p></li><li><p>不支持幂等性，当写入100条，写了50条后挂了，后面再次同步100条数据时，会把前50条的数据聚合两次。</p></li></ul><h3 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a><strong>案例演示</strong></h3><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_smt(<br>id UInt32,<br>sku_id String,<br>total_amount <span class="hljs-type">Decimal</span>(<span class="hljs-number">16</span>,<span class="hljs-number">2</span>) ,<br>create_time Datetime <br>) engine <span class="hljs-operator">=</span>SummingMergeTree(total_amount)<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_time)<br><span class="hljs-keyword">primary</span> key (id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (id,sku_id );<br></code></pre></td></tr></table></figure><p>（2）插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_smt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">1000.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 11:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_004&#x27;</span>,<span class="hljs-number">2500.00</span>,<span class="hljs-string">&#x27;2020-06-01 12:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">12000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>),<br>(<span class="hljs-number">102</span>,<span class="hljs-string">&#x27;sku_002&#x27;</span>,<span class="hljs-number">600.00</span>,<span class="hljs-string">&#x27;2020-06-02 12:00:00&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（3）执行第一次查询，可以看到已经做了一次聚合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_order_smt;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0p639ls5j30py0igabu.jpg"></p><p>（4）再次插入一条重复数据，并查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_order_smt <span class="hljs-keyword">values</span><br>(<span class="hljs-number">101</span>,<span class="hljs-string">&#x27;sku_001&#x27;</span>,<span class="hljs-number">2000.00</span>,<span class="hljs-string">&#x27;2020-06-01 13:00:00&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0p8yhgnfj30pq0liq5h.jpg"></p><p>（5）手动合并,并再次执行查询，可以看到数据已经全部聚合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">OPTIMIZE <span class="hljs-keyword">TABLE</span> t_order_smt <span class="hljs-keyword">FINAL</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0pau5gw1j30oq0qm0ve.jpg"></p><h3 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h3><p>➢ 以 SummingMergeTree（）中指定的列作为汇总数据列 </p><p>➢ 以 order by 的列为准，作为维度列</p><p>➢ 可以填写多列必须数字列，如果不填，以所有非维度列且为数字列的字段为汇总数据列</p><p>➢ 其他的列按插入顺序保留第一行</p><p>➢ 不在一个分区的数据不会被聚合</p><p>➢ 只有在同一批次插入(新版本)或分片合并时才会进行聚合</p><h3 id="能不能直接执行查询-SQL-得到汇总值？"><a href="#能不能直接执行查询-SQL-得到汇总值？" class="headerlink" title="能不能直接执行查询 SQL 得到汇总值？"></a>能不能直接执行查询 SQL 得到汇总值？</h3><p>不行，可能会包含一些还没来得及聚合的临时明细如果要是获取汇总值，还是需要使用 sum 进行聚合，这样效率会有一定的提高，但本身 ClickHouse 是列式存储的，效率提升有限，不会特别明显。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> total_amount <span class="hljs-keyword">from</span> XXX <span class="hljs-keyword">where</span> province_name<span class="hljs-operator">=</span>’’ <span class="hljs-keyword">and</span> create_date<span class="hljs-operator">=</span>’xxx’<br></code></pre></td></tr></table></figure><p>改写为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(total_amount) <span class="hljs-keyword">from</span> province_name<span class="hljs-operator">=</span>’’ <span class="hljs-keyword">and</span> create_date<span class="hljs-operator">=</span>‘xxx’<br></code></pre></td></tr></table></figure><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL 引擎可以对存储在远程 MySQL 服务器上的数据执行 <code>SELECT</code> 查询和<code>insert</code>插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db.]table_name [<span class="hljs-keyword">ON</span> CLUSTER cluster]<br>(<br>    name1 [type1] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALIAS expr1] [TTL expr1],<br>    name2 [type2] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALIAS expr2] [TTL expr2],<br>    ...<br>) ENGINE <span class="hljs-operator">=</span> MySQL(<span class="hljs-string">&#x27;host:port&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;table&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>[, replace_query, <span class="hljs-string">&#x27;on_duplicate_clause&#x27;</span>])<br>SETTINGS<br>    [connection_pool_size<span class="hljs-operator">=</span><span class="hljs-number">16</span>, ]<br>    [connection_max_tries<span class="hljs-operator">=</span><span class="hljs-number">3</span>, ]<br>    [connection_wait_timeout<span class="hljs-operator">=</span><span class="hljs-number">5</span>, ] <span class="hljs-comment">/* 0 -- do not wait */</span><br>    [connection_auto_close<span class="hljs-operator">=</span><span class="hljs-literal">true</span> ]<br>;<br></code></pre></td></tr></table></figure><p>更多见：<a href="https://clickhouse.com/docs/en/engines/table-engines/integrations/mysql/">MySQL | ClickHouse Documentation</a></p><h1 id="日志系列"><a href="#日志系列" class="headerlink" title="日志系列"></a>日志系列</h1><ul><li>这些引擎是为了需要写入许多小数据量（少于一百万行）的表的场景而开发的。</li><li>这系列的引擎有：<ul><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/stripelog/">StripeLog</a></li><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/log/">日志</a></li><li><a href="https://clickhouse.com/docs/zh/engines/table-engines/log-family/tinylog/">TinyLog</a></li></ul></li></ul><h2 id="TinyLog"><a href="#TinyLog" class="headerlink" title="TinyLog"></a>TinyLog</h2><p>以列文件的形式保存在磁盘上，不支持索引，没有并发控制。一般保存少量数据的小表，</p><p>生产环境上作用有限。可以用于平时练习测试用。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse基本数据类型</title>
    <link href="/clickhouse%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/clickhouse%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="clickhouse基本数据类型"><a href="#clickhouse基本数据类型" class="headerlink" title="clickhouse基本数据类型"></a>clickhouse基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a><strong>整型</strong></h2><p>固定长度的整型，包括有符号整型或无符号整型。</p><p>整型范围（-2n-1~2n-1-1）：</p><p>Int8 - [-128 : 127]</p><p>Int16 - [-32768 : 32767]</p><p>Int32 - [-2147483648 : 2147483647]</p><p>Int64 - [-9223372036854775808 : 9223372036854775807]</p><p>无符号整型范围（0~2n-1）：</p><p>UInt8 - [0 : 255]</p><p>UInt16 - [0 : 65535]</p><p>UInt32 - [0 : 4294967295]</p><p>UInt64 - [0 : 18446744073709551615]</p><blockquote><p>使用场景： 个数、数量、也可以存储型id</p></blockquote><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a><strong>浮点型</strong></h2><p>Float32 - float</p><p>Float64 – double</p><p>建议尽可能以整数形式存储数据。例如，将固定精度的数字转换为整数值，如时间用毫秒为单位表示，因为浮点型进行计算时可能引起四舍五入的误差。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">select</span> <span class="hljs-number">1.0</span><span class="hljs-number">-0.9</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1.</span> <span class="hljs-operator">-</span> <span class="hljs-number">0.9</span><br><br>Query id: <span class="hljs-number">82</span>a9fb29<span class="hljs-number">-9</span>ac3<span class="hljs-number">-41</span>a1<span class="hljs-number">-918</span>d<span class="hljs-operator">-</span>a37ec7bff333<br><br>┌──────minus(<span class="hljs-number">1.</span>, <span class="hljs-number">0.9</span>)─┐<br>│ <span class="hljs-number">0.09999999999999998</span> │<br>└─────────────────────┘<br><br><span class="hljs-number">1</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> set. Elapsed: <span class="hljs-number">0.010</span> sec.<br></code></pre></td></tr></table></figure><blockquote><p>使用场景：一般数据值比较小，不涉及大量的统计计算，精度要求不高的时候。比如保存商品的重量。</p></blockquote><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>没有单独的类型来存储布尔值。可以使用 UInt8 类型，取值限制为 0 或 1。</p><h2 id="Decimal-型"><a href="#Decimal-型" class="headerlink" title="Decimal 型"></a><strong>Decimal</strong> <strong>型</strong></h2><p>有符号的浮点数，可在加、减和乘法运算过程中保持精度。对于除法，最低有效数字会</p><p>被丢弃（不舍入）。</p><p>有三种声明：</p><p>➢ Decimal32(s)，相当于 Decimal(9-s,s)，有效位数为 1~9</p><p>➢ Decimal64(s)，相当于 Decimal(18-s,s)，有效位数为 1~18</p><p>➢ Decimal128(s)，相当于 Decimal(38-s,s)，有效位数为 1~38</p><p><strong>s 标识小数位</strong></p><blockquote><p>使用场景： 一般金额字段、汇率、利率等字段为了保证小数点精度，都使用 Decimal</p><p>进行存储。</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><ul><li>String</li></ul><p>字符串可以任意长度的。它可以包含任意的字节集，包含空字节。</p><ul><li>FixedString(N)</li></ul><p>固定长度 N 的字符串，N 必须是严格的正自然数。当服务端读取长度小于 N 的字符</p><p>串时候，通过在字符串末尾添加空字节来达到 N 字节长度。 当服务端读取长度大于 N 的</p><p>字符串时候，将返回错误消息。</p><p>与 String 相比，极少会使用 FixedString，因为使用起来不是很方便。</p><blockquote><p>使用场景：名称、文字描述、字符型编码。 固定长度的可以保存一些定长的内容，比</p><p>如一些编码，性别等但是考虑到一定的变化风险，带来收益不够明显，所以定长字符串使用意义有限。</p></blockquote><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><strong>枚举类型</strong></h2><p>包括 Enum8 和 Enum16 类型。Enum 保存 ‘string’&#x3D; integer 的对应关系。</p><ul><li><p>Enum8 用 ‘String’&#x3D; Int8 对描述。</p></li><li><p>Enum16 用 ‘String’&#x3D; Int16 对描述。</p></li></ul><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><ul><li><p>创建一个带有一个枚举 Enum8(‘hello’ &#x3D; 1, ‘world’ &#x3D; 2) 类型的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_enum<br>                (<br>                x Enum8(<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>)<br>                )<br>                ENGINE <span class="hljs-operator">=</span> TinyLog;<br></code></pre></td></tr></table></figure></li><li><p><strong>这个</strong> <strong>x</strong> 列只能存储类型定义中列出的值：hello或world</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_enum <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;hello&#x27;</span>), (<span class="hljs-string">&#x27;world&#x27;</span>), (<span class="hljs-string">&#x27;hello&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyye8yqx9pj30u00u9mz9.jpg"></p><ul><li><strong>如果需要看到对应行的数值，则必须将</strong> <strong>Enum</strong> <strong>值转换为整数类型</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :)  <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>(x, <span class="hljs-string">&#x27;Int8&#x27;</span>) <span class="hljs-keyword">FROM</span> t_enum;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyye7wjb2nj30qw0g83zh.jpg"></p><blockquote><p>使用场景：对一些状态、类型的字段算是一种空间优化，也算是一种数据约束。但是实</p><p>际使用中往往因为一些数据内容的变化增加一定的维护成本，甚至是数据丢失问题。所以谨慎使用。</p></blockquote><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a><strong>时间类型</strong></h2><p>目前 ClickHouse 有三种时间类型</p><p>➢ Date 接受<code>年-月-日</code>的字符串比如 ‘2019-12-16’ </p><p>➢ Datetime 接受<code>年-月-日 时:分:秒</code>的字符串比如 ‘2019-12-16 20:50:10’ </p><p>➢ Datetime64 接受<code>年-月-日 时:分:秒.亚秒</code>的字符串比如‘2019-12-16 20:50:10.66’</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>Array(T)：由 T 类型元素组成的数组。</p><p>T 可以是任意类型，包含数组类型。 但不推荐使用多维数组，ClickHouse 对多维数组</p><p>的支持有限。例如，不能在 MergeTree 表中存储多维数组。</p><ul><li>创建数组方式 1，使用 array 函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> x, toTypeName(x) ;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyye721a9uj30ry0hkgn4.jpg"></p><ul><li>创建数组方式 2：使用方括号</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-keyword">AS</span> x, toTypeName(x);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyye7bn8x2j30oo0ecwfg.jpg"></p><p>还有很多数据结构，可以参考官方文档：<a href="https://clickhouse.com/docs/zh/sql-reference/data-types/">简介 | ClickHouse文档</a></p>]]></content>
    
    
    <categories>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker安装clickhouse</title>
    <link href="/docker-%E5%AE%89%E8%A3%85clickhouse/"/>
    <url>/docker-%E5%AE%89%E8%A3%85clickhouse/</url>
    
    <content type="html"><![CDATA[<p>1.启动容器服务，加载镜像</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker run <span class="hljs-operator">-</span>d <span class="hljs-comment">--name ch-server --ulimit nofile=262144:262144 -p 8123:8123 -p 9000:9000 -p 9009:9009 yandex/clickhouse-server</span><br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyycj48p14j31py0g4tcd.jpg"></p><p>2.查看服务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker ps<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyycjh5146j31yy05075c.jpg"></p><p>3.进入docker容器内，使用用户名和密码连接数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> docker <span class="hljs-keyword">exec</span> <span class="hljs-operator">-</span>it <span class="hljs-number">46</span>bb792f7762 <span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>bash<br>root<span class="hljs-variable">@46bb792f7762</span>:<span class="hljs-operator">/</span># clickhouse<span class="hljs-operator">-</span>client<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyycl6slqwj30w008qjsx.jpg"></p><blockquote><p>如果有密码，输入下面命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span>root<span class="hljs-variable">@46bb792f7762</span>:<span class="hljs-operator">/</span># clickhouse<span class="hljs-operator">-</span>client <span class="hljs-operator">-</span>u <span class="hljs-keyword">default</span> <span class="hljs-comment">--password test</span><br></code></pre></td></tr></table></figure></blockquote><p>4.查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">46</span>bb792f7762 :) <span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyydfocs7yj30r00fyq3t.jpg"></p><p>5.dbeaver 查看</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyydcukk8nj318m0u0q6x.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse入门</title>
    <link href="/clickhouse%E5%85%A5%E9%97%A8/"/>
    <url>/clickhouse%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ClickHouse-是什么？"><a href="#ClickHouse-是什么？" class="headerlink" title="ClickHouse 是什么？"></a><strong>ClickHouse</strong> 是什么？</h1><p>ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的列式存储数据库（DBMS），使用 C++</p><p>语言编写，主要用于在线分析处理查询（OLAP），能够使用 SQL 查询实时生成分析数据报</p><p>告。</p><blockquote><ul><li>OLTP:   联机事务处理（Online Transaction Processing)。是mysql，oracle这种传统的关系型数据库的主要应用，适合做基本的日常的事务处理，增删改查等操作。</li><li>OLAP：联机分析处理（Online Analytical Processing)，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。适合做一次插入多次查询，适合分析，聚合的场景，但是对更新，删除不擅长。</li></ul></blockquote><h1 id="ClickHouse-的特点"><a href="#ClickHouse-的特点" class="headerlink" title="ClickHouse 的特点"></a>ClickHouse <strong>的特点</strong></h1><h2 id="1-列式存储"><a href="#1-列式存储" class="headerlink" title="1.列式存储"></a>1.<strong>列式存储</strong></h2><h3 id="行式存储和列式存储的对比"><a href="#行式存储和列式存储的对比" class="headerlink" title="行式存储和列式存储的对比"></a>行式存储和列式存储的对比</h3><ul><li><p>行式存储的好处是想查某个人所有的属性时，可以通过一次磁盘查找加顺序读取就可以。但是当想查所有人的年龄时，需要不停的查找，或者全表扫描才行，遍历的很多数据都是不需要的。</p></li><li><p>列式存储，想查所有人的年龄只需把年龄那一列拿出来就可以了</p></li></ul><p>以下面的表为例：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyy3x95nv3j31580est9i.jpg"></p><ul><li><p>采用行式存储时，数据在磁盘上的组织结构为：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyy3xu1e5zj315s05igm7.jpg"></p></li><li><p>采用列式存储时，数据在磁盘上的组织结构为：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyy3yqqgzzj315405kjrz.jpg"></p></li></ul><h3 id="列式储存的好处："><a href="#列式储存的好处：" class="headerlink" title="列式储存的好处："></a><strong>列式储存的好处：</strong></h3><ul><li><p>对于列的聚合，计数，求和等统计操作原因优于行式存储。</p></li><li><p>由于某一列的数据类型都是相同的，针对于数据存储更容易进行数据压缩，每一列</p><p>选择更优的数据压缩算法，大大提高了数据的压缩比重。</p></li><li><p>由于数据压缩比更好，一方面节省了磁盘空间，另一方面对于 cache 也有了更大的</p></li></ul><p>发挥空间</p><h2 id="DBMS-的功能"><a href="#DBMS-的功能" class="headerlink" title="DBMS 的功能"></a><strong>DBMS</strong> <strong>的功能</strong></h2><p>几乎覆盖了标准 SQL 的大部分语法，包括 DDL 和 DML，以及配套的各种函数，用户管</p><p>理及权限管理，数据的备份与恢复。 </p><blockquote><p>数据库管理系统（英语：database management system，缩写：DBMS）即数据库管理软件，是一种针对对象数据库，为管理数据库而设计的大型计算机软件管理系统。</p><p>具有代表性的数据管理系统有：Oracle、Microsoft SQL Server、Access、MySQL及PostgreSQL等。通常数据库管理师会使用数据库管理系统来创建数据库系统。</p></blockquote><h2 id="多样化引擎"><a href="#多样化引擎" class="headerlink" title="多样化引擎"></a><strong>多样化引擎</strong></h2><p>ClickHouse 和 MySQL 类似，把表级的存储引擎插件化，根据表的不同需求可以设定不同</p><p>的存储引擎。目前包括合并树、日志、接口和其他四大类 20 多种引擎。</p><h2 id="高吞吐写入能力"><a href="#高吞吐写入能力" class="headerlink" title="高吞吐写入能力"></a>高吞吐写入能力</h2><ul><li><p>ClickHouse 采用类 LSM Tree的结构，数据写入后定期在后台 Compaction。通过类 LSM tree的结构，ClickHouse 在数据导入时全部是顺序 append 写，写入后数据段不可更改，在后台compaction 时也是多个段 merge sort 后顺序写回磁盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在 HDD 上也有着优异的写入性能。</p></li><li><p>官方公开 benchmark 测试显示能够达到 50MB-200MB&#x2F;s 的写入吞吐能力，按照每行</p></li></ul><p>100Byte 估算，大约相当于 50W-200W 条&#x2F;s 的写入速度。</p><p><a href="https://zhuanlan.zhihu.com/p/415799237">深入浅出分析LSM树（日志结构合并树） - 知乎 (zhihu.com)</a></p><blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyy4aob591j314o0hg0uk.jpg"></p></blockquote><h3 id="数据分区与线程级并行"><a href="#数据分区与线程级并行" class="headerlink" title="数据分区与线程级并行"></a><strong>数据分区与线程级并行</strong></h3><ul><li>ClickHouse 将数据划分为多个 partition，每个 partition 再进一步划分为多个 index</li></ul><p>granularity(索引粒度)，然后通过多个 CPU核心分别处理其中的一部分来实现并行数据处理。</p><p>在这种设计下，<strong>单条 Query 就能利用整机所有 CPU</strong>。极致的并行处理能力，极大的降低了查</p><p>询延时。</p><ul><li>所以，ClickHouse 即使对于大量数据的查询也能够化整为零平行处理。但是有一个弊端</li></ul><p>就是对于单条查询使用多 cpu，就不利于同时并发多条查询。所以对于高 qps 的查询业务，</p><p>ClickHouse 并不是强项。</p><blockquote><p>QPS（<strong>Query Per Second</strong>）：每秒请求数，就是说服务器在一秒的时间内处理了多少个请求。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>clickhouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis主从架构</title>
    <link href="/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    <url>/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis主从架构介绍"><a href="#Redis主从架构介绍" class="headerlink" title="Redis主从架构介绍"></a>Redis主从架构介绍</h1><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，<strong>一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读</strong>。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑<strong>读高并发</strong>。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv2a0o0mqj30oi0lsgmm.jpg" style="zoom:30%;" /><h1 id="主从复制-全量复制-流程"><a href="#主从复制-全量复制-流程" class="headerlink" title="主从复制(全量复制)流程"></a>主从复制(全量复制)流程</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv2yicirhj30tq0lggnx.jpg"></p><ol><li>如果你为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个<strong>SYNC</strong>命令(redis2.8版本之前的命令)master请求复制数据。</li><li>master收到SYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件。</li><li>master将生成的rdb数据发给slave。</li><li>Master由于从执行bgsave到生成rdb数据存在时间，在此时间间隔内，可能有新的客户端请求，master会把这些最近的请求缓存在内存中。（也就是一个最近数据的缓冲区，默认大小为1M）</li><li>当第3步的rdb数据发完后，他会把这些缓存的数据也发给slave</li><li>当slave有老的rdb数据，就会先把老的数据清掉。重新生成包含缓存的rd b数据，并加载到内存中。</li><li>之后，master和slave通过socket长连接，持续进行命令同步，从而保证主从数据一致。</li></ol><blockquote><p>当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master。</p></blockquote><blockquote><p>如果master收到了多个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave。  </p></blockquote><p><strong>当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2.8版本开始，master和slave断开重连后支持部分复制</strong>。</p><h1 id="主从复制-部分复制-流程"><a href="#主从复制-部分复制-流程" class="headerlink" title="主从复制(部分复制)流程"></a>主从复制(部分复制)流程</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv2xkkaizj318w0ro78b.jpg"></p><ol><li>从2.8版本开始，slave与master能够在网络连接断开<strong>重连后只进行部分数据复制。</strong> </li><li>master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据。master和它所有的slave都维护了复制的数据下标offset和master的进程id。</li><li>当网络连接断开后，slave会请求master继续进行未完成的复制。<ul><li>从节点数据下标 offset还在缓存队列里，那么将会从slave记录的数据下标开始从缓存区复制。</li><li>如果master进程id变化了，或者从节点数据下标 offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制</li></ul></li></ol><h1 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a><strong>Redis哨兵高可用架构</strong></h1><ul><li><p>sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。 </p></li><li><p>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过sentinel代理访问redis的主节点。</p></li><li><p>当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv33qmtvpj319e0pktbv.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis主从架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化</title>
    <link href="/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>redis 持久化主要有2种方式：RDB 和AOF</p></blockquote><h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><h2 id="什么是RDB快照"><a href="#什么是RDB快照" class="headerlink" title="什么是RDB快照"></a>什么是RDB快照</h2><ul><li>rdb就是快照，是redis默认的持久化方式，就是把所有的数据持久化到磁盘，隔一段时间持久化一次到 dump.rdb 的二进制文件中，在服务器重启后只需要把文件中的数据恢复即可。 </li><li>你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。 比如说， <code>save 60 1000</code>会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集</li></ul><h2 id="RDB-文件的创建"><a href="#RDB-文件的创建" class="headerlink" title="RDB 文件的创建"></a>RDB 文件的创建</h2><blockquote><p>有两种方式：手动触发和自动触发</p></blockquote><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ul><li>save命令会阻塞当前Redis服务器，直到RDB过程完成为止。在服务器进程阻塞期间，服务器不能处理任何命令请求。因此，当save命令正在执行时，客户端发送的所有命令都会被拒绝，知道save命令执行完毕。（不建议使用）</li><li>bgsave 命令会fork出一个子进程(而不是线程)，由子进程进行RDB文件创建，而父进程继续处理命令。</li></ul><blockquote><p>进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件， 每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。 </p></blockquote><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>redis通过配置文件进行配置，redis可以通过设置服务器配置的save选项，服务器每隔一段时间自动执行一次bgsave命令。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>适合大规模的数据恢复，恢复速度快！</li><li>体积小，相较于aof他只是保存了结果，不需要保存每一次命令操作。</li></ul><p><strong>缺点：</strong></p><ul><li>数据需要一定的时间间隔进程操作！ 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据就没有了。</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><ul><li>以独立日志的方式记录每次写命令，每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 appendonly.aof文 件的末尾，并在 Redis 重启时在重新执行 AOF 文件中的命令以达到恢复数据的目的。</li><li>AOF 的主要作用是解决数据持久化的实时性。</li><li>你可以通过修改配置文件来打开 AOF 功能：  <code>appendonly yes </code></li><li>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。 <ul><li><strong>appendfsync always</strong>：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</li><li><strong>appendfsync everysec</strong>：每秒 fsync 一次，足够快（和使用 RDB 持久化差不多），并且在 故障时只会丢失 1 秒钟的数据。</li><li><strong>appendfsync no</strong>：：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。因为你不清楚不同的操作系统底层是怎么去刷磁盘的。</li></ul></li></ul><h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><ul><li><p>AOF文件里可能有太多没用指令，比如3次递增readcount, 重写后直接会变成readcount:3，AOF会定期根据<strong>内存的最新数据</strong>生成aof文件</p></li><li><p>进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF </p></li><li><p>AOF重写redis会fork出一个子进程去做，不会对redis正常命令处理有太多影响</p></li><li><p>如下两个配置可以控制AOF自动重写频率 </p><ul><li>auto-aof-rewrite-min-size 64mb &#x2F;&#x2F;aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</li><li>auto-aof-rewrite-percentage 100 &#x2F;&#x2F;aof文件自上一次重写后文件大小增长了100%则再次触发重写</li></ul></li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p><ul><li>每一次修改都同步，文件的完整性会更加好！</li></ul><p><strong>缺点：</strong></p><ul><li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</li></ul><h1 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a><strong>Redis 4.0 混合持久化</strong></h1><blockquote><p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志存放，但是存放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。 通过配置 <code> aof-use-rdb-preamble yes</code>可以开启混合持久化。   </p></blockquote><h2 id="混合持久化流程"><a href="#混合持久化流程" class="headerlink" title="混合持久化流程"></a>混合持久化流程</h2><ul><li>如果开启了混合持久化。<strong>AOF在重写时</strong>，不再是单纯将内存数据转换为命令写入AOF文件，而是根据aof命令重写<strong>这一刻之前</strong>的内存做RDB快照处理，并且将RDB快照内容和<strong>增量的</strong>AOF修改内存数据的命令存在一起，都写入新的AOF文件。</li><li>新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</li><li>于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再加载增量 AOF 日志就可以完全替代之前的 AOF 全量文件的加载，因此重启效率大幅得到提升。</li></ul><h2 id="混合持久化AOF文件结构"><a href="#混合持久化AOF文件结构" class="headerlink" title="混合持久化AOF文件结构"></a>混合持久化AOF文件结构</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxtx3e8tbhj30r40i23zd.jpg" style="zoom:50%;" /><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxtx4ka5e8j31ey0q6myv.jpg" style="zoom: 33%;" /></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis持久化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 核心数据结构</title>
    <link href="/redis/"/>
    <url>/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="redis-是什么？"><a href="#redis-是什么？" class="headerlink" title="redis 是什么？"></a>redis 是什么？</h1><blockquote><p>redis是一个高性能的key-value 数据库，它可以用来存储字符串，哈希，列表，集合，有序集合。</p></blockquote><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxrgdfb02gj30tq0v2whf.jpg" style="zoom:50%;" /><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String 是redis中最基础的数据结构，主要用在常规计数，如：统计网站访问数据量，当前在线人数等</p><p><strong>应用场景</strong></p><ul><li><p>单值缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> key1 &quot;zhangsan&quot;<br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> key1<br>&quot;zhangsan&quot;<br></code></pre></td></tr></table></figure></li><li><p>计数器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial <span class="hljs-number">12</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>&quot;12&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> incr article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">13</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> article:readcount:mysql<span class="hljs-operator">-</span>tutorial<br>&quot;13&quot;<br></code></pre></td></tr></table></figure></li><li><p>分布式系统全局序列号<br>INCRBY  orderId  1000&#x2F;&#x2F;redis批量生成序列号提升性能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> orderId<br>&quot;99&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> incrby orderId  <span class="hljs-number">1000</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1099</span><br></code></pre></td></tr></table></figure></li><li><p>分布式锁</p><ul><li>SETNX  product:10001   </li><li>执行业务操作。。。</li><li>DEL  product:10001。                                     &#x2F;&#x2F;执行完业务释放锁</li><li>SET product:10001 true  ex  10  nx          &#x2F;&#x2F;防止程序意外终止导致死</li></ul></li></ul><blockquote><p>SETNX（ <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists ）</p><ul><li><p>在指定的 key 不存在时，为 key 设置指定的值，这种情况下等同 <a href="https://www.redis.com.cn/commands/set.html">SET</a> 命令。当 <code>key</code>存在时，什么也不做。</p></li><li><p>返回值</p><ul><li><code>1</code> 如果key被设置了</li><li><code>0</code> 如果key没有被设置</li></ul></li></ul></blockquote><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><ul><li>定义：Hash是一个field 和value 的映射表，特别适合存储对象，比如存储用户信息，商品信息等。</li><li>优缺点：<ul><li>优点<ul><li>同类数据归类整合储存，方便数据管理</li><li>相比string操作消耗内存与cpu更小</li><li>相比string储存更节省空间</li></ul></li><li>缺点<ul><li>过期功能不能使用在field上，只能用在key上</li></ul></li></ul></li></ul><p><strong>应用场景</strong></p><ul><li>对象缓存</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> HMSET  <span class="hljs-keyword">user</span>  <span class="hljs-number">1</span>:name  zhuge <span class="hljs-number">1</span>:balance  <span class="hljs-number">1888</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> HMGET  <span class="hljs-keyword">user</span>  <span class="hljs-number">1</span>:name  <span class="hljs-number">1</span>:balance<br><span class="hljs-number">1</span>) &quot;zhuge&quot;<br><span class="hljs-number">2</span>) &quot;1888&quot;<br></code></pre></td></tr></table></figure><ul><li>电商购物车<ul><li>以用户id为key；     商品id为field；    商品数量为value；</li><li>购物车操作<ul><li>添加商品 <code> hset cart:user2 &quot;apple&quot; 1</code></li><li>增加数量  <code> hincrby cart:user2 &quot;apple&quot; 3</code></li><li>商品总数 <code>hlen cart:user2</code></li><li>删除商品 <code>hdel cart:user2 &quot;apple&quot;</code></li><li>获取购物车所有商品 <code>hgetall cart:user2</code></li></ul></li></ul></li></ul><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list是一个链表结构，主要功能是push和pop（添加和弹出集合元素），获取一个范围的值等。常用于：粉丝列表，最新消息排行。</p><p><strong>应用场景</strong></p><ul><li><p>微博消息和微信公号消息<br>张三关注了2 个订阅号，美食专栏和娱乐周边</p><ul><li><p>美食专栏发推送</p><p> <code>lpush msg:zhangSan &quot;apple is yammy!&quot;</code></p></li><li><p>娱乐周边发推送.</p><p><code>lpush msg:zhangSan &quot;YangMi is beautiful!&quot;</code></p></li><li><p>查看张三关注的最新订阅号消息.</p><p> <code>lrange msg:zhangSan 0 5</code></p></li></ul></li></ul><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>Redis 中的set集合是无序且不可重复的，它最大的优势可以进行交集，丙级，差集等，常用来求共同好友等。</p><p><strong>应用场景</strong></p><ul><li><p>微信抽奖小程序</p><ul><li>点击参与抽奖加入集合</li></ul><p>​      <code>sadd iphone13 zhangsan</code></p><ul><li>查看参与抽奖所有用户</li></ul><p>​      <code>smembers iphone13</code>  </p><ul><li><p>抽取count名中奖者  </p><ul><li><p>返回集合中2个随机数.</p><p><code>srandmember iphone13 2</code></p></li><li><p>移除并返回集合中的2个随机元素 </p><p> <code>spop iphone13 2</code></p></li></ul></li></ul></li><li><p>微信微博点赞，收藏，标签</p><ul><li>点赞<br>SADD  like:{消息ID}  {用户ID}</li><li>取消点赞<br>SREM like:{消息ID}  {用户ID}</li><li>检查用户是否点过赞<br>SISMEMBER  like:{消息ID}  {用户ID}</li><li>获取点赞的用户列表<br>SMEMBERS like:{消息ID}</li><li>获取点赞用户数<br>SCARD like:{消息ID}</li></ul></li><li><p>集合操作</p><ul><li>交集：SINTER set1 set2 set3 </li><li>并集：SUNION set1 set2 set3</li><li>差集：SDIFF set1 set2 set3</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd set1 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sadd set2 <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sinter set1 set2<br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;3&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sunion set1 set2<br><span class="hljs-number">1</span>) &quot;1&quot;<br><span class="hljs-number">2</span>) &quot;2&quot;<br><span class="hljs-number">3</span>) &quot;3&quot;<br><span class="hljs-number">4</span>) &quot;4&quot;<br><span class="hljs-number">5</span>) &quot;5&quot;<br><span class="hljs-number">6</span>) &quot;6&quot;<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> sdiff set1 set2<br><span class="hljs-number">1</span>) &quot;2&quot;<br><span class="hljs-number">2</span>) &quot;4&quot;<br></code></pre></td></tr></table></figure></li></ul><h1 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h1><p>在set的基础上，增加了一个权重系数score，使集合中的元素可以按照score进行有序排列，常用于实现排行榜。</p><p><strong>应用场景</strong></p><ul><li><p>Zset集合操作实现排行榜</p><ul><li><p>点击新闻   </p><p>ZINCRBY  hotNews:20190819  1  守护香港</p></li><li><p>展示当日排行前十 </p><p> ZREVRANGE  hotNews:20190819  0  10  WITHSCORES </p></li><li><p>七日搜索榜单计算<br>ZUNIONSTORE  hotNews:20190813-20190819  7<br>hotNews:20190813  hotNews:20190814… hotNews:20190819</p><blockquote><p>[ZUNIONSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">key …]</a><br>计算给定的一个或多个有序集的并集，并存储在新的 key 中</p></blockquote></li><li><p>展示七日排行前十<br>ZREVRANGE hotNews:20190813-20190819  0  10  WITHSCORES</p><blockquote><p>[ ZREVRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</p></blockquote></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis 核心数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个SpringBoot项目</title>
    <link href="/%E7%AC%AC%E4%B8%80%E4%B8%AAspringboot%E9%A1%B9%E7%9B%AE/"/>
    <url>/%E7%AC%AC%E4%B8%80%E4%B8%AAspringboot%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><ul><li>进入官网 <a href="https://start.spring.io/">Spring Initializr</a> 初始化项目</li><li>编写控制HelloController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">helloController</span> </span>&#123;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello World!&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pyr.spring.cloud.weather.controller;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.http.MediaType;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.MockMvc;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.hamcrest.Matchers.equalTo;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;<br><br><span class="hljs-meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@AutoConfigureMockMvc</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">helloControllerTest</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    mockMvc.perform(MockMvcRequestBuilders.get(<span class="hljs-string">&quot;/hello&quot;</span>).accept(MediaType.APPLICATION_JSON))<br>      .andExpect(status().isOk())<br>      .andExpect(content().string(equalTo(<span class="hljs-string">&quot;hello World!&quot;</span>)));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><ul><li>idea 里面右击项目</li><li>build&#x2F;libs下运行 <code>Java -jar xxx</code></li><li>项目目录下运行：<code>gradle bootRun</code></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxr8m9n86ij30sq08ujrx.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql锁</title>
    <link href="/mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="锁是什么？"><a href="#锁是什么？" class="headerlink" title="锁是什么？"></a>锁是什么？</h1><ul><li>锁是计算机协调多个线程或进程并发访问同一资源的机制。</li><li>在数据库中，数据是一种共享的资源，因此也需要保证数据并发访问的一致性和有效性。</li></ul><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><ul><li><p>从性能上来分为：<code>乐观锁</code>和<code>悲观锁</code></p><ul><li><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><blockquote><p>乐观锁一般通过版本比对的方式来实现的：</p><ul><li><p>当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。</p></li><li><p>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与我们第一次取出的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。那么更新操作就会失败。</p></li></ul></blockquote></li><li><p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p></li></ul></li><li><p>从操作类型来分为：<code>读锁</code>和<code>写锁</code></p><ul><li>读锁：也称为共享锁，多个读操作可以同时进行，且互不影响。</li><li>写锁：也称为拍他锁，他可以阻断其他读操作或者写操作。</li></ul></li><li><p>从可操作的粒度来分为：<code>表锁</code>和<code>行锁</code></p><ul><li><p>表锁：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲 </p><p>突的概率最高，并发度最低；</p></li><li><p>行锁：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁 </p><p>冲突的概率最低，并发度最高。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见sql优化(二)</title>
    <link href="/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96-%E4%BA%8C/"/>
    <url>/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="一-分页查询优化"><a href="#一-分页查询优化" class="headerlink" title="一  分页查询优化"></a>一  <strong>分页查询优化</strong></h2><h3 id="1-根据自增且连续的主键排序的分页查询"><a href="#1-根据自增且连续的主键排序的分页查询" class="headerlink" title="1. 根据自增且连续的主键排序的分页查询"></a>1. 根据自增且连续的主键排序的分页查询</h3><blockquote><p>原则：按照主键去查询</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">90000</span> limit <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。 </p><p>但是，这条改写的SQL 在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致，如：先删除一条前面的记录，然后再测试原 SQL 和优化后的 SQL</p><h3 id="2-根据非主键字段排序的分页查询"><a href="#2-根据非主键字段排序的分页查询" class="headerlink" title="2.根据非主键字段排序的分页查询"></a>2.根据非主键字段排序的分页查询</h3><blockquote><p>原则： 让排序和分页操作先查出主键，然后根据主键查到对应的记录，这样排序时返回的字段会少很多，从而会执行索引排序。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> name limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>表示根据非主键字段name排序的分页查询，发现并没有使用 name 字段的索引（key 字段对应的值为 null），具体原因为：扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。</p><p>改写后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name limit <span class="hljs-number">90000</span>,<span class="hljs-number">5</span>) ed <span class="hljs-keyword">on</span> e.id <span class="hljs-operator">=</span> ed.id;<br></code></pre></td></tr></table></figure><h2 id="二-Join关联查询优化"><a href="#二-Join关联查询优化" class="headerlink" title="二   Join关联查询优化"></a>二   <strong>Join关联查询优化</strong></h2><h3 id="mysql的表关联常见有两种算法"><a href="#mysql的表关联常见有两种算法" class="headerlink" title="mysql的表关联常见有两种算法"></a>mysql的表关联常见有两种算法</h3><h4 id="1-嵌套循环连接（Nested-Loop-Join）-算法"><a href="#1-嵌套循环连接（Nested-Loop-Join）-算法" class="headerlink" title="1.嵌套循环连接（Nested-Loop Join） 算法"></a>1.嵌套循环连接（Nested-Loop Join） 算法</h4><ul><li><p>一次一行循环地从第一张表（称为<strong>驱动表</strong>）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（<strong>被驱动</strong>表）里取出满足条件的行，然后取出两张表的结果合集。</p></li><li><p>大致流程是：</p><ol><li><p>第一步：从表 t2 中读取一行数据，根据关联字段 到表 t1 中查找</p></li><li><p>第二步：取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端； </p></li><li><p>第三部：重复第二步</p></li></ol><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span><span class="hljs-operator">*</span><span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2 <span class="hljs-keyword">on</span> t1.a<span class="hljs-operator">=</span> t2.a;<br></code></pre></td></tr></table></figure><p>假设t2有100条数据，t1有10000条。整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(<strong>扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据（扫描索引很快，可以忽略），也就是总共 t1 表也扫描了100</strong> 行**)。因此整个过程扫描了 **200 行。</p></blockquote></li><li><p>优化器一般会优先选择小表做驱动表。<strong>所以使用 inner join 时，排在前面的表并不一定就是驱动表。</strong></p></li></ul><h4 id="2-基于块的嵌套循环连接（Block-Nested-Loop-Join）-算法"><a href="#2-基于块的嵌套循环连接（Block-Nested-Loop-Join）-算法" class="headerlink" title="2.基于块的嵌套循环连接（Block Nested-Loop Join） 算法"></a>2.基于块的嵌套循环连接（Block Nested-Loop Join） 算法</h4><ul><li><p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。 </p></li><li><p>大致流程是：</p><ol><li><p>第一步：把t2中的所有数据放在join_buffer中</p></li><li><p>第二步：依次取出t1中的每一行，跟join_buffer中的数据做对比</p></li><li><p>第三部：返回满足条件的数据</p></li></ol><blockquote><p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) &#x3D; <strong>10100</strong>。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000&#x3D; <strong>100 万次</strong>。</p></blockquote></li></ul><h3 id="对于关联sql的优化"><a href="#对于关联sql的优化" class="headerlink" title="对于关联sql的优化"></a>对于关联sql的优化</h3><ul><li><p>关联字段加索引，让mysql做join操作时，尽量选择嵌套循环算法。</p><blockquote><p>从上面的例子可以对比看出，嵌套循环算法因为有索引，每次进行查找时，只需根据索引，查找一条匹配的数据，即扫描一次。但基于块的嵌套循环连接却因为没有索引，每次都需要进行一次全表扫描。</p></blockquote></li><li><p>小表驱动大表。写多表连接sql时如果<strong>明确知道</strong>哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间。</p><blockquote><p>straight_join同inner join类似，但是可以指定左边的表来驱动右边的表。但是使用它一定要慎重，因为大部分情况优化器是比人聪明的，人为指定的顺序不一定比搜索引擎靠谱。</p></blockquote></li></ul><h2 id="三-in和exsits优化"><a href="#三-in和exsits优化" class="headerlink" title="三  in和exsits优化"></a>三  <strong>in和exsits优化</strong></h2><blockquote><p> 原则：<strong>小表驱动大表</strong>，即小的数据集驱动大的数据集 </p></blockquote><ul><li><p>当B表的数据集 &lt; A表的数据集时，in优于exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B) <br>#等价于：  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B)&#123; <br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-operator">=</span> B.id<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当B表的数据集 &gt; B表的数据集时，exists优于in</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> b.id <span class="hljs-operator">=</span> A.id) <br>#等价于：  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> A)&#123;<br>     <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会忽略SELECT清单,因此没有区别</p></blockquote></li></ul><h2 id="四-count-查询优化"><a href="#四-count-查询优化" class="headerlink" title="四  count(*)查询优化"></a>四  <strong>count(*)查询优化</strong></h2><h3 id="查询mysql自己维护的总行数"><a href="#查询mysql自己维护的总行数" class="headerlink" title="查询mysql自己维护的总行数"></a>查询mysql自己维护的总行数</h3><ul><li>对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被 mysql存储在磁盘上查询不需要计算 。</li><li>对于<strong>innodb存储引擎</strong>的表mysql不会存储表的总记录行数，查询count需要实时计算</li></ul><h3 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a><strong>show table status</strong></h3><ul><li><p>如果只需要知道表总行数的估计值可以用如下sql查询，性能很高 .</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxdq94vfa1j31rk088q4o.jpg"></p></li></ul><h3 id="count-优化方式"><a href="#count-优化方式" class="headerlink" title="count(*)优化方式"></a>count(*)优化方式</h3><ul><li><p><strong>将总数维护到Redis里</strong> </p><p>插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准（如mysql执行成功了，redis没有更新成功），很难保证表操作和redis操作的事务一致性 ，可能得考虑分布式事务，适用于准确度要求不高的场景。</p></li><li><p><strong>增加计数表</strong></p><p>插入或删除表数据行的时候同时维护计数表（如新建一个表，该表增加一个字段user_count，insert user 的同时更新该字段），让他们在同一个事务里操作，让mysql的事务来保证一致性。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见sql优化</title>
    <link href="/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96/"/>
    <url>/%E5%B8%B8%E8%A7%81sql%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="常见sql优化"><a href="#常见sql优化" class="headerlink" title="常见sql优化"></a>常见sql优化</h2><ul><li><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p></li><li><p>尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select * 语句</p></li><li><p>尽量不使用不等于（！&#x3D;或者&lt;&gt;），这些无法使用索引，会导致全表扫描 </p></li><li><p>尽量不使用 is null,is not null ，这些无法使用索引，会导致全表扫描 </p></li><li><p>like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</p></li><li><p>少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。</p></li><li><p>尽量将大范围拆分成多个小范围。单次数据量查询过大可能导致优化器最终选择不走索引</p></li><li><p>范围和范围右边的字段不会走索引，只有范围和范围之前的等值字段会走索引</p></li><li><p>不在索引列上做任何操作。（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。</p></li></ul><p>准备工作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">24</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  `position` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>  `hire_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时 间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `idx_name_age_position` (`name`,`age`,`position`) <span class="hljs-keyword">USING</span> BTREE) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br>  <br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;LiLei&#x27;</span>,<span class="hljs-number">22</span>,<span class="hljs-string">&#x27;mana ger&#x27;</span>,NOW());<br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;HanMeimei&#x27;</span>, <span class="hljs-number">23</span>,<span class="hljs-string">&#x27;dev&#x27;</span>,NOW());<br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees(name,age,position,hire_time) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;Lucy&#x27;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;dev&#x27;</span>,NOW());<br></code></pre></td></tr></table></figure><p>Eg1: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;LiLei&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx4g3b8iklj31m606ejsx.jpg"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">left</span>(name,<span class="hljs-number">3</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;LiLei&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx4g3oc8zsj31ek06cgmu.jpg"></p><p>Eg2:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> <span class="hljs-type">date</span>(hire_time) <span class="hljs-operator">=</span><span class="hljs-string">&#x27;2018-09-30&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> hire_time <span class="hljs-operator">&gt;=</span><span class="hljs-string">&#x27;2018-09-30 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> hire_time <span class="hljs-operator">&lt;=</span><span class="hljs-string">&#x27;2018-09-30 23:59:59&#x27;</span>;<br></code></pre></td></tr></table></figure><p>给hire_time增加一个普通索引，上面的sql由于进行了date运算所以不会走索引，下面的会走。</p><h2 id="Using-filesort文件排序原理详解"><a href="#Using-filesort文件排序原理详解" class="headerlink" title="Using filesort文件排序原理详解"></a><strong>Using filesort文件排序原理详解</strong></h2><ul><li><p>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。 </p></li><li><p>filesort文件排序方式</p><ul><li>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</li><li>双路排序（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行</strong> <strong>数据的行 ID</strong>(主键)，然后在 sort buffer 中进行排序，排序完后需要再次通过主键回到原表查询需要的字段。用trace工具 可以看到sort_mode信息里显示&lt; sort_key, rowid &gt;</li></ul><blockquote><p> MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来 判断使用哪种排序模式。</p><ul><li><p>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 单路排序模式； </p></li><li><p>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 双路排序模式。</p></li></ul></blockquote></li><li><p>单路排序 和 双路排序的选择</p><ul><li><p>如果 MySQL 排序内存配置的比较小并且没有条件继续增加了，可以适当max_length_for_sort_data 配 置小点，让优化器选择使用<strong>双路排序</strong>算法，可以在sort_buffer 中一次排序更多的行，只是需要再根据主键回到原表取数据。 </p></li><li><p>如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器 优先选择全字段排序(<strong>单路排序</strong>)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查 询结果了。</p></li></ul></li></ul><blockquote><p>所以，MySQL通过 <strong>max_length_for_sort_data</strong> 这个参数来控制排序，在不同场景使用不同的排序模式， 从而提升排序效率。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Explain详解</title>
    <link href="/Explain-%E8%AF%A6%E8%A7%A3/"/>
    <url>/Explain-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="explain使用介绍"><a href="#explain使用介绍" class="headerlink" title="explain使用介绍"></a>explain使用介绍</h1><ul><li><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈 </p></li><li><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL （如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）。</p></li><li><p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。</p></li></ul><p><strong>下面是使用explain的例子：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwztv72dgxj31aq06mq45.jpg"></p><h2 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h2><h3 id="id列"><a href="#id列" class="headerlink" title="id列"></a>id列</h3><ul><li><p>id列的编号就是select的序列号，有几个select就有几个id</p></li><li><p>id的顺序是按select 出现的顺序增长的</p></li><li><p>Id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzu3b6nonj31fo07m75y.jpg"></p><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h3><ul><li>simple: 简单查询。查询中不含子查询和联合查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx1xees8p5j31cm06ujso.jpg"></p><ul><li>primary : 复杂查询中最外层的select。</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p>中的：<code>select *** from film </code> </p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzu3b6nonj31fo07m75y.jpg"></p><ul><li>subsquery: 复杂查询中的子查询（不在from子句中）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor limit <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p>中的：<code>select 1 from actor limit 1</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzu3b6nonj31fo07m75y.jpg"></p><ul><li>derived([dɪˈraɪv]) : 包含在from子句中的子查询。Mysql将把结果存放在一个临时表中，也称为派生表。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">set</span> session optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;derived_merge=off&#x27;</span>;<br>mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) der;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx1xvhx932j31pa08owgo.jpg"></p><ul><li>union ：在union后的select。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> id, name <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx399g82jsj31ey07ejsz.jpg"></p><blockquote><ul><li>union 用于把来自多个select  语句的结果组合到一个结果集合中。语法为：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-keyword">column</span>,......<span class="hljs-keyword">from</span> table1<br> <span class="hljs-keyword">union</span> [<span class="hljs-keyword">all</span>]<br><span class="hljs-keyword">select</span>  <span class="hljs-keyword">column</span>,...... <span class="hljs-keyword">from</span> table2<br></code></pre></td></tr></table></figure></blockquote><h3 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h3><ul><li>这一列表示explain的这一行在执行哪个表</li><li>当form后有子查询时，table列为<code>&lt;derivedN&gt;</code>格式，表示当前查询依赖id &#x3D; N的查询，于是先执行id&#x3D; N的查询。</li></ul><h3 id="type-列"><a href="#type-列" class="headerlink" title="type 列"></a>type 列</h3><ul><li><p>这一列表示访问类型，即mysql决定如何查找表中的行。</p></li><li><p>性能排序从好到坏依次为：<code>system &gt;const&gt; eq_ref&gt; ref&gt; range &gt; index &gt; all</code>，一般来说，得保证查询至少到range级别，最好到ref。</p></li><li><p>具体的类型介绍。</p><blockquote><ul><li><p>NULL：mysql在窒息感阶段用不着访问表或者索引。例如索引列中取最小值，可以单独查找索引来完成，不需要执行时访问表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx39keqvk8j31kc072myn.jpg"></p></li></ul></blockquote><blockquote><ul><li><p>const：直接按 primary key 或 unique key读取，将该列与常数比较，所以表最多有一个匹配行，读取1次，速度比较快</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx39u1jkh4j31cm084400.jpg"></p></li></ul></blockquote><blockquote><ul><li><p>eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合 条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> film <span class="hljs-keyword">on</span> film_actor.film_id <span class="hljs-operator">=</span> film.id;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3a5jmvsej31m207wjt5.jpg"></p></li></ul></blockquote><blockquote><ul><li>ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者联合索引的部分前缀，索引要 和某个值相比较，可能会找到多个符合条件的行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;film1&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3a7ju6ugj31fk06mta5.jpg"></p></blockquote><blockquote><ul><li>range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3acp599sj31ea06sta0.jpg"></p></blockquote><blockquote><ul><li>index：扫描全表索引，这通常比ALL快一些。即查询的字段都是索引列。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3ahaf61zj31eo06mwft.jpg"></p></blockquote><p>​</p><blockquote><ul><li>ALL：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span>  explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3amcxg5rj31am06yjsm.jpg"></p></blockquote></li></ul><h3 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a><strong>possible_keys列</strong></h3><ul><li>这一列显示查询可能使用哪些索引来查找。 </li><li>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中 数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </li><li>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</li></ul><h3 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h3><ul><li>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </li><li>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索 引，在查询中使用 force index、ignore index。</li></ul><h3 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h3><ul><li>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </li><li>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成， 并且每个int是4字节。通过结果中的key_len&#x3D;4可推断出查询使用了第一个列：film_id列来执行索引查找。</li></ul><blockquote><p>key_len计算规则如下： </p><ul><li><p>字符串 </p><ul><li><p>char(n)：n字节长度</p></li><li><p>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n </p><p>+ 2</p></li></ul></li><li><p>数值类型</p><ul><li>tinyint：1字节 </li><li>smallint：2字节</li><li>int：4字节 </li><li>bigint：8字节</li></ul></li><li><p>时间类型</p><ul><li>date：3字节 </li><li>timestamp：4字节 </li><li>datetime：8字节</li></ul></li><li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></li></ul></blockquote><h3 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a><strong>ref列</strong></h3><ul><li>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</li></ul><h3 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a><strong>rows列</strong></h3><ul><li>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</li></ul><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a><strong>Extra列</strong></h3><p>这一列展示的是额外信息。常见的重要值如下： </p><ul><li><p>Using index：使用覆盖索引（覆盖索引指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。 ）</p></li><li><p>Using where：使用 where 语句来处理结果，查询的列未被索引覆盖</p></li><li><p>Using index condition：会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> film_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> name <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><ul><li>actor.name没有索引，此时创建了张临时表来distinct</li></ul></li><li><p>Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><ul><li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排 序name并检索行记录</li></ul></li><li><p>Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id) <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p> Extra 的介绍不是一定的，需要综合当时的场景考虑，不需要记住哪个场景使用的是哪个，只是需要当出现Using filesort, Using temporary：Using where：时，考虑需要优化。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Explain详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql索引介绍</title>
    <link href="/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><blockquote><p>索引是帮助Mysql高效获取数据的排好序的数据结构</p></blockquote><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h4 id="二叉树：单边增长的场景会导致全表扫描。"><a href="#二叉树：单边增长的场景会导致全表扫描。" class="headerlink" title="二叉树：单边增长的场景会导致全表扫描。"></a>二叉树：单边增长的场景会导致全表扫描。</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwoa8e7thzj30am0dkwek.jpg" style="zoom: 67%;" /><span id="more"></span><h4 id="红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。"><a href="#红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。" class="headerlink" title="红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。"></a>红黑树：相对平衡，比二叉树性能好，大数据下，红黑树的高度过高，会造成磁盘IO频繁。</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwoabk973sj30dy08cjrf.jpg"  /><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>一次hash算法就可以定位到文件的位置，但存在缺点：</p><ul><li>不支持范围查找</li><li>不支持排序</li></ul><p>数据库如果比较大，只用到精确查找就可以用hash</p><h4 id="B-tree："><a href="#B-tree：" class="headerlink" title="B-tree："></a>B-tree：</h4><ol><li><strong>特点：</strong></li></ol><blockquote><ul><li>叶子结点具有相同的深度，叶子结点指针为空。</li><li>所有索引元素不重复</li><li>节点中的数据索引从左到右递增</li></ul></blockquote><ol start="2"><li>如果使用了innoDb存储引擎，结点的data元素就可能存储的是除了索引外的其他所有列，会占用比较大的存储空间，对于一个大结点而言，可以存放的结点数量就会比较小</li></ol><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwoaf7s92lj30ne07oq3a.jpg"  /><h4 id="B-tree-B-tree变种"><a href="#B-tree-B-tree变种" class="headerlink" title="B+tree(B-tree变种)"></a>B+tree(B-tree变种)</h4><ol><li><p>特点：</p><blockquote><ul><li>非叶子结点不存储data ,只存储索引（冗余），可以存放更多的索引。</li><li>叶子结点包含所有的索引字段。</li><li>叶子结点用指针连接，提高区间访问的性能。</li></ul></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwoarcvziwj30r80bwjs3.jpg"></p></li></ol><h2 id="索引是怎么支持千万级表快速查找？"><a href="#索引是怎么支持千万级表快速查找？" class="headerlink" title="索引是怎么支持千万级表快速查找？"></a>索引是怎么支持千万级表快速查找？</h2><p>mysql建议一个结点大小为16kb,这样一次iO速度比较快，一个大结点下的一个索引元素大约是14b，所以一个大结点里面约有1170个索引元素，对于一个高度为3的b+树，可以存储<code>16* 1170* 1170 </code>&#x3D; 2000万。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎是对于表而言的，不同的表可以设置不同的存储引擎</p><h3 id="MyISAM索引实现-非聚集"><a href="#MyISAM索引实现-非聚集" class="headerlink" title="MyISAM索引实现(非聚集)"></a>MyISAM索引实现(非聚集)</h3><ul><li><p>MyISAM索引文件和数据文件是分离的</p></li><li><p>表结构文件是xxx.frm, 索引文件是xxx.MYI, 数据文件是xxx.MYD</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwqkxbz5qvj30j80f8mxz.jpg"></p></li></ul><blockquote><p>执行流程：当有一条查询语句：where Col1 &#x3D; 49， 先判断有没有走索引，走索引的话，先根据49快速在MYI文件中定位到结点，获取该结点存储的索引所在行的磁盘文件指针0x90，再去MYD中定位数据。</p></blockquote><h3 id="InnoDb索引实现-聚集"><a href="#InnoDb索引实现-聚集" class="headerlink" title="InnoDb索引实现(聚集)"></a>InnoDb索引实现(聚集)</h3><ul><li><p>表数据文件本身就是按B+tree组织的一个索引文件</p></li><li><p>叶子结点包含了完整的数据记录，data里存储的是：索引所在行的其他所有数据</p></li><li><p>表结构文件是xxx.frm, 索引文件+ 数据文件 是xxx.ibd</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwql7jmw80j30si0dmgmn.jpg"></p><h4 id="为什么InnoDb表要尽量设定一个主键"><a href="#为什么InnoDb表要尽量设定一个主键" class="headerlink" title="为什么InnoDb表要尽量设定一个主键"></a>为什么InnoDb表要尽量设定一个主键</h4><ul><li>innnoDb表数据文件本身就是按B+tree组织的一个索引文件</li><li>主键是数据库确保数据行在整张表唯一性的保障.</li><li>设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。 </li><li>如果没有主键，InnoDB会选择一个唯一键来作为聚簇索 引，如果没有唯一键，会生成一个隐式的主键。</li></ul><h4 id="主键使用整型的自增ID而不是UUID？"><a href="#主键使用整型的自增ID而不是UUID？" class="headerlink" title="主键使用整型的自增ID而不是UUID？"></a>主键使用整型的自增ID而不是UUID？</h4><ul><li>查找元素的时候会涉及到大量的数据比较，整型比字符串快</li><li>UUID占用的存储空间会大于整形</li><li>叶子结点是按顺序排列的，如果主键索 引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，在维护B+树的过程中，会造成非常多的数据插入，数据移动，然后导致产生很多的内 存碎片，进而造成插入性能的下降。</li></ul><h3 id="辅助索引（非主键索引）"><a href="#辅助索引（非主键索引）" class="headerlink" title="辅助索引（非主键索引）"></a>辅助索引（非主键索引）</h3><ul><li><p>叶子结点存储的是索引所在数据行的主键。</p></li><li><p>辅助索引访问数据总是需要二次查找，先遍历非主键索引再遍历主键索引</p></li></ul><h4 id="为什么非主键索引结构叶子结点存储的是主键值"><a href="#为什么非主键索引结构叶子结点存储的是主键值" class="headerlink" title="为什么非主键索引结构叶子结点存储的是主键值?"></a>为什么非主键索引结构叶子结点存储的是主键值?</h4><ul><li>一致性，完整的数据只在主键索引上维护一份就可以，不用考虑分布式的问题。</li><li>节省存储空间.</li></ul><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><ul><li>5个单值索引，对应5棵B+树，联合索引就只需要一棵树，所以日常推荐使用联合索引而不是单值索引。</li><li>索引排序的时候会按照字段顺序，逐个去排序</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwqm2wi1m8j30og0c8dgy.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>sql优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的6种工作模式</title>
    <link href="/RabbitMQ%E7%9A%846%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/RabbitMQ%E7%9A%846%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ的7种工作模式"><a href="#RabbitMQ的7种工作模式" class="headerlink" title="RabbitMQ的7种工作模式"></a><strong>RabbitMQ的7种工作模式</strong></h1><h2 id="1-simple模式"><a href="#1-simple模式" class="headerlink" title="1. simple模式"></a>1. simple模式</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h61vr62rxtj20cq01sa9y.jpg"></p><ul><li><p>最简单的收发模式。生产者发送一个消息到一个指定的queue，中间不需要任何exchange规则。消费者端通过queue方式进行消费。</p></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>String message = <span class="hljs-string">&quot;hello world&quot;</span>;<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-work工作模式-资源的竞争"><a href="#2-work工作模式-资源的竞争" class="headerlink" title="2. work工作模式(资源的竞争)"></a>2. work工作模式(资源的竞争)</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h61vqu9trgj20b403umx4.jpg"></p><ul><li><p>一个生产者，多个消费者。</p></li><li><p>consumer1, consumer2 同时监听同一 个队列,消息被消费。服务器根据负载方案决定把消息发给一个指定的consumer处理。work主要有两种模式：</p><blockquote><ul><li><strong>轮询分发</strong>：一个消费者消费一条，<strong>按均分配</strong>，woek模式下默认是采用轮询分发方式。比较简单，比如生产费者发送了6条消息到队列中，如果有3个消费者同时监听着这一个队列，那么这3个消费者每人就会分得2条消息。</li><li>公平分发<strong>：根据消费者的消费能力进行公平分发，处理得快的分得多，处理的慢的分得少，</strong>能者多劳。</li></ul></blockquote></li><li><p>隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用。</p></li></ul><h2 id="3-publish-x2F-subscribe发布订阅-共享资源"><a href="#3-publish-x2F-subscribe发布订阅-共享资源" class="headerlink" title="3. publish&#x2F;subscribe发布订阅(共享资源)"></a>3. publish&#x2F;subscribe发布订阅(共享资源)</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h61vrnqw4bj20cw02wmx5.jpg"></p><ul><li><p>type为**”fanout”** 的exchange</p></li><li><p>每个消费者监听自己的队列； 生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。</p></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br>channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>channel.queueBind(<span class="hljs-string">&quot;queue1&quot;</span>, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-Routing路由模式"><a href="#4-Routing路由模式" class="headerlink" title="4. Routing路由模式"></a><strong>4. Routing路由模式</strong></h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h61vsezs1tj20cw04o74c.jpg"></p><ul><li><p>type为”<strong>direct</strong>” 的exchange</p></li><li><p>根据routing_key 进行匹配，生产者，发送消息的时候会制定routing_key，交换机根据routing_key，去匹配绑定改routing_key的队列,只能匹配上路由key对应 的消息队列,对应的消费者才能消费消息</p></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(DIRECT_EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br>channel.basicPublish(DIRECT_EXCHANGE_NAME, ROUTING_KEY, <span class="hljs-keyword">null</span>,message.getBytes(StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(DIRECT_EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br>channel.queueDeclare(DIRECT_QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>channel.queueBind(DIRECT_QUEUE_NAME, DIRECT_EXCHANGE_NAME, ROUTING_KEY);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-topic-主题模式-路由模式的一种"><a href="#5-topic-主题模式-路由模式的一种" class="headerlink" title="5.topic 主题模式(路由模式的一种)"></a><strong>5.topic 主题模式(路由模式的一种)</strong></h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h61vstpqczj20de04g3yj.jpg"></p><ul><li><p>type为”<strong>topic</strong>“ 的exchange</p></li><li><p>交换机根据key的规则模糊匹配到对应的队列，由队列的监听消费者接收消息消费。类似sql的模糊匹配</p></li><li><p>* 代表一个具体的单词。# 代表0个或多个单词</p></li><li><p>代码</p><ul><li><p>producer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.exchangeDeclare(TOPIC_EXCHANGE, BuiltinExchangeType.TOPIC);<br>String message = <span class="hljs-string">&quot;hello world topic!&quot;</span>;<br>channel.basicPublish(TOPIC_EXCHANGE, <span class="hljs-string">&quot;hello.info&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure></li><li><p>consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTING_KEY = <span class="hljs-string">&quot;*.info&quot;</span>;<br>channel.exchangeDeclare(TOPIC_EXCHANGE, BuiltinExchangeType.TOPIC);<br>channel.queueDeclare(TOPIC_QUEUE_1, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>channel.queueBind(TOPIC_QUEUE_1, TOPIC_EXCHANGE, ROUTING_KEY);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-RPC模式-路由模式的一种"><a href="#6-RPC模式-路由模式的一种" class="headerlink" title="6. RPC模式(路由模式的一种)"></a>6. RPC模式(路由模式的一种)</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h61vtu8rx3j20je06iq37.jpg"></p><p>实现不同服务间的远程调用。 springCloud feign</p><h2 id="7-Publisher-Confirms-发送者消息确认"><a href="#7-Publisher-Confirms-发送者消息确认" class="headerlink" title="7. Publisher Confirms 发送者消息确认"></a>7. Publisher Confirms <strong>发送者消息确认</strong></h2><ul><li><p>这个模块就是通过给发送者提供一些确认机制，来保证这个消息发送的过程是成功的</p></li><li><p>发送者确认模式默认是不开启的，所以如果需要开启发送者确认模式，需要手动在channel中进行声明</p><p> <code>channel.confirmSelect() </code></p></li><li><p>在官网的示例中，重点解释了三种策略</p><ul><li><p><strong>1. 发布单条消息</strong></p><p>channel.waitForConfirmsOrDie(5_000);这个方法就会在channel端等待RabbitMQ给出一个响应，用来表明这个消息已经正确发送到了RabbitMQ服务端。但是要注意，这个方法会同步阻塞channel，在等待确认期间，channel将不能再继续发送消息，也就是说会明显降低集群的发送速度即吞吐量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (thereAreMessagesToPublish()) &#123;<br>    <span class="hljs-keyword">byte</span>[] body = ...;<br>    BasicProperties properties = ...;<br>    channel.basicPublish(exchange, queue, properties, body);<br>    <span class="hljs-comment">// uses a 5 second timeout</span><br>    channel.waitForConfirmsOrDie(<span class="hljs-number">5_000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>2. 发送批量消息</strong></p><p>之前单条确认的机制会对系统的吞吐量造成很大的影响，所以稍微中和一点的方式就是发送一批消息后，再一起确认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> batchSize = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">int</span> outstandingMessageCount = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (thereAreMessagesToPublish()) &#123;<br>    <span class="hljs-keyword">byte</span>[] body = ...;<br>    BasicProperties properties = ...;<br>    channel.basicPublish(exchange, queue, properties, body);<br>    outstandingMessageCount++;<br>    <span class="hljs-keyword">if</span> (outstandingMessageCount == batchSize) &#123;<br>        channel.waitForConfirmsOrDie(<span class="hljs-number">5_000</span>);<br>        outstandingMessageCount = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (outstandingMessageCount &gt; <span class="hljs-number">0</span>) &#123;<br>    channel.waitForConfirmsOrDie(<span class="hljs-number">5_000</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>3. 异步确认消息</strong></p><p>Producer在channel中注册监听器来对消息进行确认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.addConfirmListener(ConfirmCallback var1, ConfirmCallback var2); <br></code></pre></td></tr></table></figure><p>发送者在发送完消息后，就会执行第一个监听器callback1，然后等服务端发过来的反馈后，再执行第二个监听器callback2</p></li></ul></li></ul><h2 id="消息的分发策略"><a href="#消息的分发策略" class="headerlink" title="消息的分发策略"></a>消息的分发策略</h2><ul><li><p>消息的分发策略</p><p>  假设队列里有100条消息，有 A,B,C   3个队列</p><ul><li>发布订阅。三个队列都收到100条</li><li>轮训分发。3个队列都是至少33条，剩下一条随机，不论你数据库性能怎么样，大家接受的都是公平的</li><li>公平分发。根据服务器性能，去分发，哪个性能高，哪个处理的消息可能就多，能者多劳，会造成数据倾斜</li><li>重发。发送消息中出现了异常后，消息没有得到应答，就会重发，kafka不支持</li><li>消息拉取。就是RPC去拉取数据</li></ul><blockquote><p>Rabbitmq以上集中策略都支持，且是开源的</p><p>kafka速度最快</p></blockquote></li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul><li>中间件<ul><li>是一种应用于分布式系统的基础软件。</li><li>常见的中间件：mysql，rabbit MQ</li></ul></li><li>怎么选择中间件<ul><li>可以通信，跨平台。比方两个项目一个java，一个go之间要通信，就要遵循同一种协议</li><li>高可用<ul><li>是否拥有持久化。比方中间件挂了，重启后是否可以把消息重新存储起来的能力</li><li>支持集群。系统cpu不够用了，就得搭集群</li></ul></li><li>有分发能力，多个系统，往那个系统去发送消息</li></ul></li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul><li><p>网络协议三要素：</p><ul><li>语法：用户数据的结构与形式，如：http中规定了请求和响应报文的格式</li><li>语义：规定了何种信息需要对应发出何种响应，如：请求get要把参数放在url中，post把参数放在body中</li><li>时序：事件的执行顺序，如：先有请求后有响应</li></ul></li><li><p>为什么消息中间件不用http？</p><ul><li>http的请求和响应报文比较复杂，有cookie, 状态码，响应码这些，但消息中间件：只需要接受消息，存储消息，分发消息，不需要这么复杂</li><li>http大部分是短链接，不利于出现故障时消息持久化</li></ul></li><li><p>AMQP（advanced message. Queuing protocol） 高级消息队列协议</p><ul><li>采用Erlang，底层是C，速度很快</li><li>特性<ul><li>支持分布式事务</li><li>消息持久化</li><li>高性能高可靠的消息处理优势</li></ul></li></ul></li><li><p>kafka 协议</p><ul><li>基于TCP&#x2F;IP的二进制协议，消息内部由长度分割，由基本数据类型构成</li><li>特性<ul><li>结构简单</li><li>解析速度快</li><li>消息持久化</li><li>不支持事务</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>rabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秒杀模块学习</title>
    <link href="/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="秒杀模块"><a href="#秒杀模块" class="headerlink" title="秒杀模块"></a>秒杀模块</h1><h2 id="1-秒杀接口优化"><a href="#1-秒杀接口优化" class="headerlink" title="1. 秒杀接口优化"></a>1. 秒杀接口优化</h2><ul><li>用户是否登陆</li><li>判断库存（备份在redis中一份）<ul><li>在初始化contoller接口的时候，就把商品id和对应的库存数存入到redis</li></ul></li><li>判断是否已经秒杀到了</li><li>减缓存， 下订单（订单和秒杀订单）<ul><li>队列里面存的消息message，有两个变量用户和商品id,</li><li>receiver监听该队列，减库存，减库存成功了，根据用户和商品id,下订单</li><li>contoller需要的就是给队列发消息，最终给前端返回一个状态值（排队中）</li></ul></li></ul><span id="more"></span><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn32zi2y7j30o40n0wfo.jpg" style="zoom: 67%;" /><ul><li>前端轮询：是否生成了订单<ul><li>查询该笔订单是否存在<ul><li>存在，生成订单</li><li>不存在，查看商品是否已经秒杀完了：<ul><li>没秒杀完，就是排队中</li><li>完了，就返回该商品已经卖完了，并且在缓存中记录下该商品已经售罄了。goods_over+goodsId, true</li></ul></li></ul></li></ul></li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3541p3cj30qk0hkq4d.jpg" style="zoom:50%;" /><h2 id="2-秒杀接口地址隐藏"><a href="#2-秒杀接口地址隐藏" class="headerlink" title="2. 秒杀接口地址隐藏:"></a>2. 秒杀接口地址隐藏:</h2><p>针对不同的用户，生成不同的秒杀地址，即秒杀地址上带一个参数，参数根据当前【用户id，商品id】随机生成，并保存在redis中，做秒杀的时候，先检查该参数是否匹配，只有匹配了才可以进行秒杀，不匹配是非法请求。</p><h2 id="3-验证码生成"><a href="#3-验证码生成" class="headerlink" title="3. 验证码生成"></a>3. 验证码生成</h2><p>点击秒杀之前，先让用户输入验证码。有2个目的：</p><ul><li>防止机器人</li><li>用户输入验证码结果时间不同，因此分散用户的请求。</li></ul><p>实现：</p><ul><li>生成秒杀验证码，放在redis中</li><li>在秒杀的时候，先验证验证码，验证成功，删除ke y</li></ul><h2 id="4-接口限流防刷"><a href="#4-接口限流防刷" class="headerlink" title="4. 接口限流防刷"></a>4. 接口限流防刷</h2><p>思路：</p><p>把每个用户访问接口的次数写入到缓存中，并设置失效时长s，因为可能每个方法设置的参数可能不同，所以可以通过注解+拦截器实现。</p><p>实现在 <strong>Controller</strong> 处理请求之前 先判断是否已经超过了设置的最大访问次数。</p><p>具体实现：</p><p>Step1: 在需要防刷的方法上加注解annotation，注解里设置两个参数时间seconds和最大访问次数maxCount</p><p>Step2: 添加拦截器(Interceptor)，在拦截器里先判断该方法上是否加了对应注解</p><p>Step3: 通过request中取得的method uri, 用户id 可以得到当前用户访问的该方法的次数</p><p>step4: 将该次数和注解里存的最大访问次数进行比较，看是否已经超过了限制的最大次数</p><p>Step5: redis中存放的key设置最大过期时间为注解的时间</p><p>Step5: 注册该拦截器</p><h2 id="5-分布式session"><a href="#5-分布式session" class="headerlink" title="5. 分布式session"></a>5. 分布式session</h2><p>用户登陆成功后，给用户生成一个session_id标识这个用户，写在客户端cookie中，客户端访问服务器的时候会带上cookie，服务端在处理的时候，会从cookie中解码出session_id，从而取到用户信息。</p><hr/><h2 id="为什么要使用分布式Session"><a href="#为什么要使用分布式Session" class="headerlink" title="为什么要使用分布式Session"></a>为什么要使用分布式Session</h2><p>Web应用在单机部署的情况下，Session是被单个应用服务器存储管理的，由于只有一个应用服务器，用户的所有请求都是通过它进行响应处理的，所以能够很容易实现会话跟踪和保持。随着业务量的增长，系统架构需要做出调整以适应发展的需要，可能会使用分布式架构或微服务架构，无论使用哪种架构方式，应用系统单机部署的模式已经不能满足需求，所以会将应用系统部署到多台应用服务器上，用户的请求也会通过负载均衡转发到某个具体应用服务器上执行，可能会出现在A1系统登录后创建并保存Session，再次发起请求，请求被转发到A2系统上显示未登录的情况，此时单机部署模式下的Session机制已不能满足要求。所以，在分布式架构或微服务架构下，必须保证一个应用服务器上保存Session后，其它应用服务器可以同步或共享这个Session。</p><h2 id="分布式session管理实现方案"><a href="#分布式session管理实现方案" class="headerlink" title="分布式session管理实现方案"></a>分布式session管理实现方案</h2><p>分布式Session有如下几种实现方式。</p><h2 id="1-Session复制"><a href="#1-Session复制" class="headerlink" title="1.Session复制"></a>1.Session复制</h2><p>在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。<br>优点：代码上不需要做支持和修改。<br>缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。<br>适用场景：只适用于Web服务器比较少且Session数据量少的情况。<br>可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。</p><h2 id="2-Session粘滞"><a href="#2-Session粘滞" class="headerlink" title="2.Session粘滞"></a>2.Session粘滞</h2><p>将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。<br>优点：使用简单，没有额外开销。<br>缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。<br>适用场景：对稳定性要求不是很高的业务情景。</p><h2 id="3-Session集中管理"><a href="#3-Session集中管理" class="headerlink" title="3.Session集中管理"></a>3.Session集中管理</h2><p>在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。<br>优点：可靠性高，减少Web服务器的资源开销。<br>缺点：实现上有些复杂，配置较多。<br>适用场景：Web服务器较多、要求高可用性的情况。<br>可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。</p><h2 id="4-基于Cookie管理"><a href="#4-基于Cookie管理" class="headerlink" title="4.基于Cookie管理"></a>4.基于Cookie管理</h2><p>这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。<br>优点：不需要依赖额外外部存储，不需要额外配置。<br>缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。<br>适用场景：数据不重要、不敏感且数据量小的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这四种方式，相对来说，Session集s管理更加可靠，使用也是最多的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Spock框架编写测试代码</title>
    <link href="/%E4%BD%BF%E7%94%A8Spock%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    <url>/%E4%BD%BF%E7%94%A8Spock%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Spock-介绍"><a href="#Spock-介绍" class="headerlink" title="Spock 介绍"></a>Spock 介绍</h2><blockquote><ul><li><p>Spock是一个为groovy和java语言应用程序来测试和规范的框架。</p></li><li><p>这个框架的突出点在于它美妙和高效表达规范的语言。</p></li><li><p>得益于JUnit runner，Spock能够在大多数IDE、编译工具、持续集成服务下工作。</p></li><li><p>Spock的灵感源于JUnit,jMock, RSpec, Groovy, Scala, Vulcans以及其他优秀的框架形态。</p></li></ul></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>a simple assertion</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be a simple assertion&quot;</span>() &#123;<br>    <span class="hljs-symbol">expect:</span><br>    <span class="hljs-number">1</span> == <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><ul><li>given when then 使用</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should demo given-when-then&quot;</span>()&#123;<br>     <span class="hljs-symbol">given:</span><br>     <span class="hljs-keyword">def</span> user = <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">10</span>)<br><br>     <span class="hljs-symbol">when:</span><br>     <span class="hljs-keyword">int</span> age = user.numberOfSides<br><br>     <span class="hljs-symbol">then:</span><br>     age == <span class="hljs-number">10</span><br> &#125;<br></code></pre></td></tr></table></figure><ul><li>expecting exceptions</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should expect exceptions&quot;</span>()&#123;<br>     <span class="hljs-symbol">when:</span><br>     <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">0</span>)<br><br>     <span class="hljs-symbol">then:</span><br>     thrown(TooFewSidesException)<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>data pipes.     where设置所有期望值</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should expect an exception to be throw for a number of invalid inputs&quot;</span>()&#123;<br>       <span class="hljs-symbol">when:</span><br>       <span class="hljs-keyword">new</span> Polygon(sides)<br><br>       <span class="hljs-symbol">then:</span><br>       thrown(TooFewSidesException)<br><br>       <span class="hljs-comment">//The where block says &quot;run this test with each of the following values: a negative value, zero, one and two&quot;.</span><br>       <span class="hljs-comment">// where设置所有期望值</span><br>       <span class="hljs-symbol">where:</span><br>       sides &lt;&lt; [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to create polygon with valid inputs&quot;</span>()&#123;<br>      <span class="hljs-symbol">expect:</span><br>      <span class="hljs-keyword">new</span> Polygon(sides).numberOfSides == sides<br><br>      <span class="hljs-comment">//The where block says &quot;run this test with each of the following values: a negative value, zero, one and two&quot;.</span><br>      <span class="hljs-symbol">where:</span><br>      sides &lt;&lt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>data tables</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use data tables for calculating max&quot;</span>()&#123;<br>      <span class="hljs-comment">// 如果我们只有一条语句设置了测试和断言，我们可以直接使用`expect`标签</span><br>      <span class="hljs-symbol">expect:</span><br>      Math.max(a,b) == max<br><br>      <span class="hljs-symbol">where:</span><br>      a | b | max<br>      <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">2</span><br>      <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">4</span><br>      <span class="hljs-number">5</span> | <span class="hljs-number">9</span> | <span class="hljs-number">9</span><br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>mocks 模拟出类或API来声明预期的行为</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to mock a specific class&quot;</span>() &#123;<br>        <span class="hljs-symbol">given:</span><br>        Renderer renderer = Mock()<br><br>        <span class="hljs-comment">//@Subject只是为了标记我们正在测试的对象，对代码没有任何影响</span><br>        <span class="hljs-meta">@Subject</span><br>        <span class="hljs-keyword">def</span> ploygon = <span class="hljs-keyword">new</span> Polygon(<span class="hljs-number">4</span>, renderer)<br><br>        <span class="hljs-symbol">when:</span><br>        ploygon.draw()<br><br>        <span class="hljs-symbol">then:</span><br>        <span class="hljs-number">4</span> * renderer.drawLine()<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>stubs 在测试的代码里提供数据或者值</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should be able to create a stubs&quot;</span>() &#123;<br>       <span class="hljs-symbol">given:</span><br>       Palette palette = Stub()<br>       palette.getPrimaryColor() &gt;&gt; Color.red<br><br>       <span class="hljs-keyword">def</span> renderer =  <span class="hljs-keyword">new</span> Renderer(palette)<br><br>       <span class="hljs-symbol">expect:</span><br>       renderer.getForeGroundColor() == Color.red<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>help methods</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use a helper methods&quot;</span>() &#123;<br>    <span class="hljs-symbol">given:</span><br>    Renderer renderer = Mock()<br>    <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>    <span class="hljs-symbol">when:</span><br>    <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>    <span class="hljs-symbol">then:</span><br>    checkDefaultShape(polygon, renderer)<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-keyword">void</span> checkDefaultShape(Polygon polygon, Renderer renderer) &#123;<br>    <span class="hljs-keyword">assert</span> polygon.numberOfSides == <span class="hljs-number">4</span><br>    <span class="hljs-keyword">assert</span> renderer == renderer<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>with 测试但个对象的多个属性</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use #with()&quot;</span>() &#123;<br>        <span class="hljs-symbol">given:</span><br>        Renderer renderer = Mock()<br>        <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>        <span class="hljs-symbol">when:</span><br>        <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>        <span class="hljs-symbol">then:</span><br>        with(polygon)&#123;<br>            numberOfSides == <span class="hljs-number">4</span><br>            renderer == render<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>verifyAll() 确保所有断言都在执行，而不管其中之一是否失败了。</p><p>当使用with时，第一行测试失败了，第二行测试就不会执行了，而verifyAll 会运行所有行测试</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> <span class="hljs-string">&quot;should use #verifyAll()&quot;</span>() &#123;<br>       <span class="hljs-symbol">given:</span><br>       Renderer renderer = Mock()<br>       <span class="hljs-keyword">def</span> shapeFactory = <span class="hljs-keyword">new</span> ShapeFactory(renderer)<br><br>       <span class="hljs-symbol">when:</span><br>       <span class="hljs-keyword">def</span> polygon = shapeFactory.createDefaultPolygon()<br><br>       <span class="hljs-symbol">then:</span><br>       verifyAll(polygon)&#123;<br>           numberOfSides == <span class="hljs-number">5</span><br>           renderer == <span class="hljs-literal">null</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p>setup-and-teardown</p><ul><li>setupSpec():  在规范的开始设置状态一次，这是为了在各个测试方法之间不应该改变的东西</li><li>setup(): 将在该类中的每个单独测试方法之前运行。这可用于在每次测试开始时设置干净状态。</li><li>cleanup(): 在每个测试方法结束时清理数据或状态</li><li>cleanupSpec() :  对于最终的分解代码，该方法将在运行所有测试的最后调用一次。</li></ul></li><li><p>and可以增加多个使代码根据可读性：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">given: <span class="hljs-string">&quot;test method&quot;</span><br><span class="hljs-regexp">//</span> code ....<br><br>and: <span class="hljs-string">&quot;test method with user1&quot;</span><br><span class="hljs-regexp">//</span> code ...<br><br>and: <span class="hljs-string">&quot;test method with user2&quot;</span><br><span class="hljs-regexp">//</span> code ...<br></code></pre></td></tr></table></figure></li></ul><p>​</p>]]></content>
    
    
    <categories>
      
      <category>spock</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kotlin学习</title>
    <link href="/kotlin%E5%AD%A6%E4%B9%A0/"/>
    <url>/kotlin%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Kotlin-是什么？"><a href="#1-Kotlin-是什么？" class="headerlink" title="1.Kotlin 是什么？"></a>1.Kotlin 是什么？</h2><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。</p><p>在Google I&#x2F;O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><h2 id="2-为什么选择-Kotlin？"><a href="#2-为什么选择-Kotlin？" class="headerlink" title="2.为什么选择 Kotlin？"></a>2.为什么选择 Kotlin？</h2><ul><li>简洁: 大大减少样板代码的数量。</li><li>安全: 避免空指针异常等整个类的错误。</li><li>互操作性: 充分利用 JVM、Android 和浏览器的现有库。</li><li>工具友好: 可用任何 Java IDE 或者使用命令行构建。</li></ul><span id="more"></span><h2 id="3-我的第一个-Kotlin-程序"><a href="#3-我的第一个-Kotlin-程序" class="headerlink" title="3.我的第一个 Kotlin 程序"></a>3.我的第一个 Kotlin 程序</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello word!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Kotlin 程序文件以 <strong>.kt</strong> 结尾，如：hello.kt 、app.kt。</p></blockquote><h2 id="4-基础语法"><a href="#4-基础语法" class="headerlink" title="4.基础语法"></a>4.基础语法</h2><ul><li>函数定义</li></ul><p>格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 方法名<span class="hljs-params">(参数A : 类型<span class="hljs-type">A</span>, 参数B : 类型<span class="hljs-type">B</span>)</span></span>: 返回值类型(可以为空) &#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;   <span class="hljs-comment">// Int 参数，返回值 Int</span><br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> result = add(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br>    println(result)<br>&#125;<br><br><span class="hljs-comment">//fun add(x: Int, y: Int): Int &#123;</span><br><span class="hljs-comment">//  return x+ y</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x+ y<br></code></pre></td></tr></table></figure><ul><li>可变长参数</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">vars</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> v:<span class="hljs-type">Int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vt <span class="hljs-keyword">in</span> v)&#123;<br>        print(vt)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    vars(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出12345</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认参数和具名参数</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calThePerimeterOfCircle</span><span class="hljs-params">(pi: <span class="hljs-type">Float</span> = Pi, r: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>* pi * r<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;圆的周长为：<span class="hljs-subst">$&#123;calThePerimeterOfCircle(r = <span class="hljs-number">2.0</span>f)&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数表达式</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> i = &#123;x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x+ y&#125;<br>    println(i(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))<br><br>    <span class="hljs-comment">// 输入类型是两个int ，返回值是int，输入参数为x,y 表达式为x+y</span><br>    <span class="hljs-keyword">var</span> j:(<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123;x,y -&gt; x+y&#125;<br>    println(i(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>条件控制 if</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnBigValue</span><span class="hljs-params">(a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>)</span></span>:<span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (a&gt;b) a <span class="hljs-keyword">else</span> b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a= <span class="hljs-number">3</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">5</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;a&#125;</span>和<span class="hljs-subst">$&#123;b&#125;</span>中较大的数是<span class="hljs-subst">$&#123;returnBigValue(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>When 表达式</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gradeStudent</span><span class="hljs-params">(score:<span class="hljs-type">Int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">when</span>(score)&#123;<br>        <span class="hljs-number">10</span> -&gt; println(<span class="hljs-string">&quot;优秀！&quot;</span>)<br>        <span class="hljs-number">1</span> -&gt; println(<span class="hljs-string">&quot;差劲！&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;努力努力！&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(gradeStudent(<span class="hljs-number">9</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>list</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> items = listOf&lt;String&gt;(<span class="hljs-string">&quot;语文&quot;</span>,<span class="hljs-string">&quot;数学&quot;</span>,<span class="hljs-string">&quot;英语&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> items)&#123;<br>        println(<span class="hljs-string">&quot;科目有：<span class="hljs-subst">$&#123;i&#125;</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> ((i,index) <span class="hljs-keyword">in</span> items.withIndex())&#123;<br>        println(<span class="hljs-string">&quot;科目为：<span class="hljs-subst">$&#123;i&#125;</span>，序号为<span class="hljs-subst">$&#123;index&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>map</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> map = TreeMap&lt;String,String&gt;()<br>    map[<span class="hljs-string">&quot;好&quot;</span>] = <span class="hljs-string">&quot;good&quot;</span><br>    map[<span class="hljs-string">&quot;坏&quot;</span>] = <span class="hljs-string">&quot;bad&quot;</span><br>    println(map[<span class="hljs-string">&quot;好&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>字符串和数字的转换</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;string&quot;</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span><br>    println(<span class="hljs-string">&quot;字符串转数字：<span class="hljs-subst">$&#123;a.toString()&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;数字转字符串：<span class="hljs-subst">$&#123;b.toInt()&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>控制台输入变量</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;请输入第一个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str1 = readLine()<br>    println(<span class="hljs-string">&quot;请输入第二个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str2 = readLine()<br><br>    <span class="hljs-keyword">var</span> num1 = str1!!.toInt()<br>    <span class="hljs-keyword">var</span> num2 = str2!!.toInt()<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;num1&#125;</span>+<span class="hljs-subst">$&#123;num2&#125;</span>=<span class="hljs-subst">$&#123;num1+num2&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>处理异常-&gt; try…catch()</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;请输入第一个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str1 = readLine()<br>    println(<span class="hljs-string">&quot;请输入第二个数字：&quot;</span>)<br>    <span class="hljs-keyword">var</span> str2 = readLine()<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">var</span> num1 = str1!!.toInt()<br>        <span class="hljs-keyword">var</span> num2 = str2!!.toInt()<br>        println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;num1&#125;</span>+<span class="hljs-subst">$&#123;num2&#125;</span>=<span class="hljs-subst">$&#123;num1+num2&#125;</span>&quot;</span>)<br>    &#125;<span class="hljs-keyword">catch</span> (e: Exception)&#123;<br>        println(<span class="hljs-string">&quot;输入的数据有误！&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>字符串模板</p><p>$ 表示一个变量名或者变量值</p><p>$varName 表示变量值</p><p>${varName.fun()} 表示变量的方法返回值:</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 模板中的简单名称：</span><br>    <span class="hljs-keyword">val</span> s1 = <span class="hljs-string">&quot;a is <span class="hljs-variable">$a</span>&quot;</span><br><br>    a = <span class="hljs-number">2</span><br><span class="hljs-comment">// 模板中的任意表达式：</span><br>    <span class="hljs-keyword">val</span> s2 = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;s1.replace(<span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;was&quot;</span>)&#125;</span>, but now is <span class="hljs-variable">$a</span>&quot;</span><br>    println(s2)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>空值处理</p><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式。</p><ul><li><p>字段后加!!像Java一样抛出空异常</p></li><li><p>字段后加?可不做处理返回值为 null或配合?:做空判断处理</p></li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//类型后面加?表示可为空</span><br><span class="hljs-keyword">var</span> age: String? = <span class="hljs-string">&quot;23&quot;</span> <br><span class="hljs-comment">//抛出空指针异常</span><br><span class="hljs-keyword">val</span> ages = age!!.toInt()<br><span class="hljs-comment">//不做处理返回 null</span><br><span class="hljs-keyword">val</span> ages1 = age?.toInt()<br><span class="hljs-comment">//age为空返回-1</span><br><span class="hljs-keyword">val</span> ages2 = age?.toInt() ?: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="5-类"><a href="#5-类" class="headerlink" title="5.类"></a>5.类</h2><h3 id="5-1-类的创建"><a href="#5-1-类的创建" class="headerlink" title="5.1 类的创建"></a>5.1 类的创建</h3><p>Kotlin 中没有 new 关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangular</span></span>&#123;<br>    <span class="hljs-keyword">var</span> width:<span class="hljs-built_in">Int</span> = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> height:<span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> rectangular = Rectangular()<br>    println(rectangular.height)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-枚举类"><a href="#5-2-枚举类" class="headerlink" title="5.2 枚举类"></a>5.2 枚举类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>&#123;<br>    RED,BLACK,BLUE,GREEN,WHITE<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Kotlin-继承"><a href="#6-Kotlin-继承" class="headerlink" title="6. Kotlin 继承"></a>6. Kotlin 继承</h3><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span> // 从 <span class="hljs-symbol">Any</span> 隐式继承<br></code></pre></td></tr></table></figure><p>Any 默认提供了三个函数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">equals</span><span class="hljs-params">()</span></span><br><br><span class="hljs-function"><span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><br><span class="hljs-function"><span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>注意：Any 不是 java.lang.Object。</p><p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">open <span class="hljs-keyword">class</span> <span class="hljs-symbol">Base</span>(<span class="hljs-symbol">p: <span class="hljs-symbol">Int</span></span>)           // 定义基类<br><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Derived</span>(<span class="hljs-symbol">p: <span class="hljs-symbol">Int</span></span>) : <span class="hljs-symbol">Base</span>(<span class="hljs-symbol">p</span>)<br></code></pre></td></tr></table></figure><h1 id="7-Kotlin-接口"><a href="#7-Kotlin-接口" class="headerlink" title="7.Kotlin 接口"></a>7.Kotlin 接口</h1><p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 未实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">//已实现</span><br>      <span class="hljs-comment">// 可选的方法体</span><br>      println(<span class="hljs-string">&quot;foo&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> : <span class="hljs-type">MyInterface1</span>,<span class="hljs-type">MyInterface2 &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar1</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 方法体</span><br>    &#125;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot整合graphql</title>
    <link href="/springboot%E6%95%B4%E5%90%88graphql/"/>
    <url>/springboot%E6%95%B4%E5%90%88graphql/</url>
    
    <content type="html"><![CDATA[<p>GraphQL是比REST更高效、强大和灵活的<strong>新一代API标准</strong>。详细的可以看官网<a href="https://graphql.cn/">GraphQL</a>。</p><p>下面介绍一个Spring boot整合graphql简单的例子。</p><span id="more"></span><ul><li><p>项目准备：相关依赖的引入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">&lt;dependencies&gt;</span><br><span class="hljs-meta">&lt;!--web</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--lombok</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--graphql</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;version&gt;11.0.0&lt;/version&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-meta">&lt;!--playground</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-attr">&lt;dependency&gt;</span><br><span class="hljs-attr">&lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;</span><br><span class="hljs-attr">&lt;artifactId&gt;playground-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="hljs-attr">&lt;version&gt;11.0.0&lt;/version&gt;</span><br><span class="hljs-attr">&lt;/dependency&gt;</span><br><span class="hljs-attr">&lt;/dependencies&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><ul><li><p>定义schema，分别为：</p><p><code>query.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">type Query&#123;<br>  billingAccount(id: ID): BillingAccount<br>&#125;<br></code></pre></td></tr></table></figure><p><code>billingAccount.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">type BillingAccount &#123;<br>  id: ID!<br>  name: String!<br>  currency: Currency<br>&#125;<br></code></pre></td></tr></table></figure><p><code>currency.graphqls</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Currency</span></span>&#123;<br>    RMB,<br>    USD<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义基础要操作的模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccount</span> </span>&#123;<br>    UUID id;<br>    String name;<br>    Currency currency;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Currency</span> </span>&#123;<br>    RMB, USD<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义resolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccountResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GraphQLQueryResolver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BillingAccount <span class="hljs-title">billingAccount</span><span class="hljs-params">(UUID id)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;receive billingAccount id is: &quot;</span>+ id);<br>        <span class="hljs-keyword">return</span> BillingAccount.builder()<br>                .id(id)<br>                .currency(Currency.RMB)<br>                .name(<span class="hljs-string">&quot;张三&quot;</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>效果图</p></li></ul><p><img src="/images/resolver.png" alt="img"></p><h4 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h4><ul><li>定义schema</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Mutation</span>&#123;<br>    createBillingAccount(input: <span class="hljs-type">CreateBillingAccountInput</span>): <span class="hljs-type">BillingAccount</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义input</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span> CreateBillingAccountInput&#123;<br>    name: String<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义input 对应的model</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateBillingAccountInput</span> </span>&#123;<br>  String name;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义mutationResolver</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingAccountMutation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GraphQLMutationResolver</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BillingAccount <span class="hljs-title">createBillingAccount</span><span class="hljs-params">(CreateBillingAccountInput input)</span></span>&#123;<br><br>    <span class="hljs-keyword">return</span> BillingAccount.builder()<br>      .id(UUID.randomUUID())<br>      .currency(Currency.RMB)<br>      .name(input.getName())<br>      .build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图</p><p>!<img src="/images/mutation.png" alt="mutation"></p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Webflux</title>
    <link href="/%20Spring%20Webflux/"/>
    <url>/%20Spring%20Webflux/</url>
    
    <content type="html"><![CDATA[<p><strong>1.响应式编程是什么？</strong></p><ul><li><p>响应式编程（<strong>reactive programming</strong>）是一种基于数据流和变化传递的声明式的编程范式</p><p>本来数据是我们自行处理的，后来我们把要处理的数据抽象出来（变成了数据流），然后通过<strong>API</strong>去处理数据流中的数据（是声明式的,如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum2 = IntStream.of(nums).parallel().sum();<br></code></pre></td></tr></table></figure></li></ul><p>​      将数组中的数据变成数据流，通过显式声明调用**.sum()**来处理数据流中的数据，得到最终的结果。</p><ul><li><p>响应式编程是关于非阻塞应用程序的，这些应用程序是异步的、事件驱动的，并且需要少量的线程来垂直伸缩(即在 JVM 中)，而不是水平伸缩(即通过集群)。</p><blockquote><p>工作太多，做不完时，水平伸缩就相当于加人，垂直伸缩相当于加班。</p></blockquote></li></ul><h3 id="2-响应式流（Reactive-Streams）-是什么"><a href="#2-响应式流（Reactive-Streams）-是什么" class="headerlink" title="2.响应式流（Reactive Streams） 是什么?"></a>2.响应式流（Reactive Streams） 是什么?</h3><span id="more"></span><ul><li><p>响应式流是JDK9引入的，基于发布-订阅者模式的一套数据处理的机制。</p></li><li><p>响应式流从2013年开始，作为提供非阻塞背压的异步流处理标准的倡议。 它旨在解决处理元素流的问题——如何将元素流从发布者传递到订阅者，而不需要发布者阻塞，或订阅者有无限制的缓冲区或丢弃。</p></li></ul><blockquote><p>背压：说白了就是一种反馈，发布者和订阅者之间的一种互动</p></blockquote><blockquote><p>之前的老模式，订阅者很被动，发布者给订阅者多少他就消费多少，不能多也不能多少。</p><p>Reactive Streams就可以做到发布者和订阅者之间可以进行交流，订阅者可以告诉发布者我需要多少数据，订阅者处理完了，可以再向发布者要，没处理完就不要给我。</p><p>起到了一种调节流量的作用，不会导致发布者数据太多，订阅者处理不完浪费，或者直接把订阅者压垮的场景。</p></blockquote><h3 id="2-Spring-Webflux-是什么？"><a href="#2-Spring-Webflux-是什么？" class="headerlink" title="2. Spring Webflux 是什么？"></a>2. Spring Webflux 是什么？</h3><p>Spring WebFlux是<a href="https://rumenz.com/java-topic/spring-mvc-tutorial/index.html">Spring MVC</a>并行版本，并支持完全无阻塞的反应流的web框架。 它支持背压概念，可以处理大量的并发连接，并使用**<a href="https://netty.io/">Netty</a>**作为内置服务器来运行响应式应用程序。 </p><h3 id="3-Spring-Webflux-和Spring-mvc-的关系"><a href="#3-Spring-Webflux-和Spring-mvc-的关系" class="headerlink" title="3.Spring Webflux 和Spring mvc 的关系"></a>3.Spring Webflux 和Spring mvc 的关系</h3><img src="https://spring.io/images/diagram-reactive-1290533f3f01ec9c57baf2cc9ea9fa2f.svg" style="zoom: 25%;" /><p>Spring MVC</p><ul><li>构建于 Servlet API 之上</li><li>同步阻塞 I&#x2F;O 模型, 认为应用会阻塞当前线程，所以一个 Request 对应一个 Thread，需要有一个含有大量线程的线程池</li></ul><p>Spring WebFlux</p><ul><li>构建于 Reactive Streams Adapters 之上</li><li>异步非阻塞 I&#x2F;O 模型，认为应用不会阻塞当前线程，所以只是需要一个包含少数固定线程数的线程池 (event loop workers) 来处理请求</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringWebflux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性之Stream流</title>
    <link href="/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/"/>
    <url>/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="Java8新特性之Stream流"><a href="#Java8新特性之Stream流" class="headerlink" title="Java8新特性之Stream流"></a>Java8新特性之Stream流</h3><h3 id="1-什么是Stream？"><a href="#1-什么是Stream？" class="headerlink" title="1.什么是Stream？"></a>1.什么是Stream？</h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。通过声明性方式，能够对集合中的每个元素进行一系列并行或串行的流水线操作。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">int</span> num2 = IntStream.of(numbers).sum();<br>        System.out.println(num2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-创建流的几种方式"><a href="#2-创建流的几种方式" class="headerlink" title="2.创建流的几种方式"></a>2.创建流的几种方式</h3><span id="more"></span><h4 id="2-1-使用集合"><a href="#2-1-使用集合" class="headerlink" title="2.1 使用集合"></a>2.1 使用集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList();<br>arrayList.stream();<br>arrayList.parallelStream();  <br></code></pre></td></tr></table></figure><h4 id="2-2-使用数组"><a href="#2-2-使用数组" class="headerlink" title="2.2 使用数组"></a>2.2 使用数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="2-3-数字Stream"><a href="#2-3-数字Stream" class="headerlink" title="2.3 数字Stream"></a>2.3 数字Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>IntStream.rangeClosed(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h4 id="2-4-使用Stream-generate"><a href="#2-4-使用Stream-generate" class="headerlink" title="2.4 使用Stream.generate()"></a>2.4 使用Stream.generate()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.generate(()-&gt; <span class="hljs-string">&quot;stream&quot;</span>).limit(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h3><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><blockquote><ul><li>延迟方法：返回值任然是Stream接口自身类型的方法，因此支持链式调用(除了终结方法外，其他都是方法均为延迟方法)</li><li>终结方法：返回值类型不再是Stream接口自身类型的方法。</li></ul></blockquote><h4 id="3-1-延迟方法"><a href="#3-1-延迟方法" class="headerlink" title="3.1 延迟方法"></a>3.1 延迟方法</h4><h5 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter"></a>1. filter</h5><p>可以通过<code>filter</code>方法将一个流转换成另一个子集流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>).filter(i -&gt; i&gt;<span class="hljs-number">2</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5 id="2-peek"><a href="#2-peek" class="headerlink" title="2.peek"></a>2.peek</h5><p>用于debug，foreach是最终操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).peek(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out::println).<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><h5 id="3-map"><a href="#3-map" class="headerlink" title="3.map"></a>3.map</h5><p>将流中的元素映射到另一个流中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).map(String::length).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5 id="4-limit"><a href="#4-limit" class="headerlink" title="4.limit"></a>4.limit</h5><p>对流进行截取，只取用前n个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5 id="5-skip"><a href="#5-skip" class="headerlink" title="5.skip"></a>5.skip</h5><p>跳过前几个</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).skip(<span class="hljs-number">2</span>).<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="3-2-终止方法"><a href="#3-2-终止方法" class="headerlink" title="3.2 终止方法"></a>3.2 终止方法</h4><h5 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1.forEach"></a>1.forEach</h5><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h5 id="2-count"><a href="#2-count" class="headerlink" title="2.count"></a>2.count</h5><p>计算个数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王麻子&quot;</span>).count<span class="hljs-literal">()</span>);<br></code></pre></td></tr></table></figure><h5 id="3-collect"><a href="#3-collect" class="headerlink" title="3.collect"></a>3.collect</h5><p>收集到list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).collect(Collectors.toList());<br>System.out.println(<span class="hljs-string">&quot;收集到list:&quot;</span>+list);<br></code></pre></td></tr></table></figure><h5 id="4-reduce"><a href="#4-reduce" class="headerlink" title="4.reduce"></a>4.reduce</h5><p>从Stream中生成一个值</p><ul><li>使用reduce拼接字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; newStr = Stream.of(str.split(<span class="hljs-string">&quot;&quot;</span>)).reduce((str1, str2) -&gt; str1 + <span class="hljs-string">&quot;-&quot;</span> + str2);<br>System.out.println(newStr.orElse(<span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>使用reduce拼接字符串-+ 带有初始值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String newStr2 = Stream.of(str.split(<span class="hljs-string">&quot;&quot;</span>)).reduce(<span class="hljs-string">&quot;&quot;</span>, (str1, str2) -&gt; str1 + <span class="hljs-string">&quot;-&quot;</span> + str2);<br>System.out.println(newStr2);<br></code></pre></td></tr></table></figure><ul><li>使用reduce计算所有单词总长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Integer&gt; length = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).map(s -&gt; s.length()).reduce((len1, len2) -&gt; len1 + len2);<br>System.out.println(<span class="hljs-string">&quot;length:&quot;</span> + length.get());<br></code></pre></td></tr></table></figure><h5 id="5-max"><a href="#5-max" class="headerlink" title="5.max"></a>5.max</h5><p>求最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; maxValue = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).max((str1, str2) -&gt; str1.length() - str2.length());<br>System.out.println(<span class="hljs-string">&quot;maxValue:&quot;</span> + maxValue.get());<br></code></pre></td></tr></table></figure><h5 id="6-findFirst"><a href="#6-findFirst" class="headerlink" title="6.findFirst"></a>6.findFirst</h5><p>找第一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; firstValue = Stream.of(str.split(<span class="hljs-string">&quot; &quot;</span>)).findFirst();<br>System.out.println(<span class="hljs-string">&quot;firstValue:&quot;</span> + firstValue.get());<br></code></pre></td></tr></table></figure><h3 id="4-惰性求值"><a href="#4-惰性求值" class="headerlink" title="4. 惰性求值"></a>4. 惰性求值</h3><p>惰性求值：终结没有调用的情况下，延迟方法不会执行。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">int</span> num2 = IntStream.of(numbers).map(StreamDemo1::doubleNum).sum();<br>        System.out.println(num2);<br>      <br>      <span class="hljs-comment">// 这里没有执行中间操作</span><br>        IntStream.of(numbers).map(StreamDemo1::doubleNum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doubleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了乘以2&quot;</span>);<br>        <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">Task :StreamDemo1.main()</span><br>执行了乘以2<br>执行了乘以2<br>执行了乘以2<br>12<br></code></pre></td></tr></table></figure><p>中间操作就是：返回stream的操作，如：map</p><p>终止操作就是：sum()</p><p>从输出结果可以看出doubleNum执行了3次</p><h3 id="5-并行流"><a href="#5-并行流" class="headerlink" title="5.并行流"></a>5.并行流</h3><h4 id="5-1-创建一个并行流"><a href="#5-1-创建一个并行流" class="headerlink" title="5.1 创建一个并行流"></a>5.1 创建一个并行流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>).parallel().peek(ParallelStream::debugger).count();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;debugger&quot;</span>+i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">Task :ParallelStream.main()</span><br>debugger90<br>debugger81<br>debugger82<br>debugger83<br>debugger84<br>debugger85<br>debugger86<br>debugger65<br>debugger66<br>debugger67<br><span class="hljs-meta">...</span><br></code></pre></td></tr></table></figure><ul><li>多次调用parallel &#x2F; sequential，以最后一个为准，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>                .parallel().peek(ParallelStream::debugger)<br>                .sequential().peek(ParallelStream::debugger2)<br>                .count();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.err.println(<span class="hljs-string">&quot;debugger2: &quot;</span> + i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;debugger1: &quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-并行流使用自己定义的线程池"><a href="#5-2-并行流使用自己定义的线程池" class="headerlink" title="5.2 并行流使用自己定义的线程池"></a>5.2 并行流使用自己定义的线程池</h4><blockquote><p>原因：避免使用默认线程池，防止任务被阻塞</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallelStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">20</span>);<br>        forkJoinPool.submit(() -&gt; IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>                .parallel().peek(ParallelStream::debugger)<br>                .count());<br>        forkJoinPool.shutdown();<br><br>        <span class="hljs-keyword">synchronized</span> (forkJoinPool) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                forkJoinPool.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;debugger1: &quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Stream-流的运行机制"><a href="#6-Stream-流的运行机制" class="headerlink" title="6. Stream 流的运行机制"></a>6. Stream 流的运行机制</h3><p>所有的操作都是链式调用，每个操作只会对每个元素操作一次；（是通过维护一个链表实现的。）具体实现：</p><blockquote><ul><li>每个中间操作都会返回一个新的流，每个流里面都会有一个SourceStage属性，所有流的SourceStage属性都指向同一个地方head【就是原始流的头部】；</li><li>如果一个中间操作之后还有中间操作，那么这个中间操作对应的流中nextStage属性就会执行下一个中间操作对应的流，否则就是null</li></ul></blockquote><p>注：parallel &#x2F; sequential也是中间操作，但是他们呢不创建流，只是修改head 里的并行标志：parallel</p>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8的新特性之lambda表达式</title>
    <link href="/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-函数接口"><a href="#1-函数接口" class="headerlink" title="1.函数接口"></a>1.函数接口</h3><p>函数接口（<code>@FunctionalInterface</code>）需要满足两个条件：</p><ul><li>类型是接口</li><li>有且只有一个抽象方法</li></ul><p>例如：Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这也是要求我们接口的设计尽量小，符合单一责任制，一个接口只做一个事，这样使用lambda就会比较方便。</p><h3 id="2-lambda表达式是个啥？"><a href="#2-lambda表达式是个啥？" class="headerlink" title="2. lambda表达式是个啥？"></a>2. lambda表达式是个啥？</h3><p><strong>lambda表达式</strong>是<strong>Java8</strong>的新特性，它就是就是一个匿名函数，箭头左边是函数的参数，右边是函数的执行体。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>              System.out.println(<span class="hljs-string">&quot;正常创建一个线程&quot;</span>);<br>          &#125;<br>      &#125;).start();<br>      # 实际上是返回了一个实现了Runnable的实例，箭头左边是参数，右边是方法体<br>      <span class="hljs-keyword">new</span> Thread(()-&gt; System.out.println(<span class="hljs-string">&quot;Lambda创建一个线程&quot;</span>)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上面的代码为例，Runnable接口仅有一个run方法，并且该方法没有参数，所以编译器可以自动推断出箭头后的内容为run方法的方法体。</p><p>如果Runnable接口中含有多个方法，编译器将无法编译lambda表达式，可以看出，lambda表达式是根据编译器的隐式推断来简化代码的。所以，<strong>lambda表达式需要函数式接口的支持。</strong></p><p><strong>实例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MoneyFormat</span></span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">format</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMoney</span><span class="hljs-params">(MoneyFormat moneyFormat)</span></span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;金额数为：&quot;</span> + moneyFormat.format(<span class="hljs-keyword">this</span>.money)));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MoneyDemo moneyDemo = <span class="hljs-keyword">new</span> MoneyDemo(<span class="hljs-number">999</span>);<br>        moneyDemo.printMoney(i -&gt; <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#,##&quot;</span>).format(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上可见，我们不关心接口的名字是什么，只关心输入是int，输出 是string，因此上面代码可优化为：</p><p>删除interface MoneyFormat，使用jdk8带的函数接口Function&lt;Integer,String&gt;替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMoney</span><span class="hljs-params">(Function&lt;Integer,String&gt; moneyFormat)</span></span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;金额数为：&quot;</span> + moneyFormat.apply(<span class="hljs-keyword">this</span>.money)));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MoneyDemo moneyDemo = <span class="hljs-keyword">new</span> MoneyDemo(<span class="hljs-number">999</span>);<br>        moneyDemo.printMoney(i -&gt; <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#,##&quot;</span>).format(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3-lambda表达式常用的函数式接口"><a href="#3-lambda表达式常用的函数式接口" class="headerlink" title="3. lambda表达式常用的函数式接口"></a>3. lambda表达式常用的函数式接口</h2><p>主要是分布在java.util.function包中，下面只简单列举2种：</p><h4 id="2-1-Supplier接口"><a href="#2-1-Supplier接口" class="headerlink" title="2.1 Supplier接口"></a>2.1 Supplier接口</h4><ul><li><code>java.util.function.Supplier&lt;T&gt;</code> 接口仅含有一个无参方法,<code>T get()</code></li><li><code>Supplier&lt;T&gt;</code> 接口是生产型接口,接口泛型指定什么类型,就返回什么泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupplierDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">supplyName</span><span class="hljs-params">(Supplier&lt;String&gt; supplier)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SupplierDemo supplierDemo = <span class="hljs-keyword">new</span> SupplierDemo();<br>        String name = supplierDemo.supplyName(() -&gt; <span class="hljs-string">&quot;张三&quot;</span>);<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Consumer接口"><a href="#3-2-Consumer接口" class="headerlink" title="3.2 Consumer接口"></a>3.2 Consumer接口</h3><ul><li><code>java.util.function.Consumer接口&lt;T&gt;</code> 接口仅含有一个有参方法,<code>void accept(T t)</code></li><li><code>Consumer接口&lt;T&gt;</code> 接口是消费型接口,接口泛型制定什么类型,就接受什么泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">(String name, Consumer&lt;String&gt; consumer)</span> </span>&#123;<br>        consumer.accept(name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConsumerDemo consumerDemo = <span class="hljs-keyword">new</span> ConsumerDemo();<br>        consumerDemo.printName(<span class="hljs-string">&quot;张三&quot;</span>, (String name) -&gt; System.out.println(<span class="hljs-string">&quot;姓名为 : &quot;</span> + name));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lambda表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8的新特性之方法引用</title>
    <link href="/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-方法引用是什么？"><a href="#1-方法引用是什么？" class="headerlink" title="1.方法引用是什么？"></a>1.方法引用是什么？</h3><blockquote><p>Java8的新特性之二：方法引用。方法引用其实也离不开Lambda表达式。</p></blockquote><ul><li><p>方法引用通过方法的名字来指向一个方法。</p></li><li><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p>方法引用使用一对冒号 <strong>::</strong> 。</p></li></ul><h2 id="2、方法引用的分类"><a href="#2、方法引用的分类" class="headerlink" title="2、方法引用的分类"></a>2、方法引用的分类</h2><p>下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。</p><span id="more"></span><table><thead><tr><th align="center">类型</th><th>语法</th><th>对应lambda表达式</th></tr></thead><tbody><tr><td align="center">静态方法引用</td><td>类名::staticMethod</td><td>(args) -&gt; 类名.staticMethod(args)</td></tr><tr><td align="center">实例方法引用</td><td>instance::instance_Method</td><td>(args) -&gt; instance.instance_Method(args)</td></tr><tr><td align="center">对象方法引用</td><td>类名::instance_Method</td><td>(inst,args) -&gt; 类名.instance_Method(args)</td></tr><tr><td align="center">构建方法引用</td><td>类名::new</td><td>(args) -&gt; new 类名(args)</td></tr></tbody></table><h3 id="3、方法引用举例"><a href="#3、方法引用举例" class="headerlink" title="3、方法引用举例"></a>3、方法引用举例</h3><h4 id="3-1-静态方法引用"><a href="#3-1-静态方法引用" class="headerlink" title="3.1 静态方法引用"></a>3.1 静态方法引用</h4><ul><li><p>实例1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s); 输出的参数和输入的参数一致，可以缩写</span><br>    Consumer&lt;String&gt; consumer = System.out::println;<br>    consumer.accept(<span class="hljs-string">&quot;接受的数据&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> 实例中我们将 System.out::println 方法作为静态方法来引用。</p></li><li><p>实例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>            System.out.println(dog + <span class="hljs-string">&quot;狗叫了&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">//静态方法</span><br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        Consumer&lt;Dog&gt; consumer2 = Dog::bark;<br>        consumer2.accept(dog);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-2-实例方法引用"><a href="#3-2-实例方法引用" class="headerlink" title="3.2 实例方法引用"></a>3.2 实例方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> food_weight = <span class="hljs-number">10</span>;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;小狗吃了&quot;</span> + weight + <span class="hljs-string">&quot;斤狗粮&quot;</span>);<br>            <span class="hljs-keyword">this</span>.food_weight -= weight;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.food_weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">// Function&lt;Integer, Integer&gt; function = dog::eat;</span><br>        <span class="hljs-comment">// UnaryOperator&lt;Integer&gt; function = dog::eat;</span><br>        <span class="hljs-comment">// int weight = function.apply(3);</span><br>        IntUnaryOperator function = dog::eat;<br>        <span class="hljs-keyword">int</span> weight = function.applyAsInt(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;还剩余&quot;</span> + weight + <span class="hljs-string">&quot;斤狗粮&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的eat方法，页可改写为<code>public int eat(Dog this, int weight) </code>编译也不会报错。因此&#x3D;》</p><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">JDk会默认把当前实例传入到非静态方法，参数名为<span class="hljs-keyword">this</span>，位置是第一个<br></code></pre></td></tr></table></figure></blockquote><h4 id="3-3-构建方法引用"><a href="#3-3-构建方法引用" class="headerlink" title="3.3 构建方法引用"></a>3.3 构建方法引用</h4><ul><li>无参数的构造方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Supplier&lt;Dog&gt; supplier = Dog::<span class="hljs-keyword">new</span>;<br>        System.out.println(supplier.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有参数的构造方法的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodReferenceDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;啸天犬&quot;</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;String,Dog&gt; function2 =  Dog::<span class="hljs-keyword">new</span>;;<br>        System.out.println(function2.apply(<span class="hljs-string">&quot;小杂毛&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch简介</title>
    <link href="/ElasticSearch%E7%AE%80%E4%BB%8B/"/>
    <url>/ElasticSearch%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h1><h2 id="Es是什么？"><a href="#Es是什么？" class="headerlink" title="Es是什么？"></a>Es是什么？</h2><ul><li>Elasticsearch是用Java开发并且是当前最流行的开源的企业级搜索引擎。</li><li>能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li><li>客户端支持Java、.NET（C#）、PHP、Python、Ruby等多种语言。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>关键词搜索。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz2w2u8asuj30vt0u044p.jpg"></p><blockquote><p>从上面的搜索结果，可以看出不是根据模糊匹配去进行搜索的</p></blockquote><h2 id="ElasticSearch与Lucene的关系"><a href="#ElasticSearch与Lucene的关系" class="headerlink" title="ElasticSearch与Lucene的关系"></a>ElasticSearch与Lucene的关系</h2><ul><li>Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库（框架）</li></ul><h3 id="Lucene缺点："><a href="#Lucene缺点：" class="headerlink" title="Lucene缺点："></a>Lucene缺点：</h3><ul><li>想要使用Lucene，必须使用Java来作为开发语言并将其直接集成到你的应用中。</li><li>Lucene的配置及使用非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</li><li>使用非常复杂-创建索引和搜索索引代码繁杂。</li><li>不支持集群环境-索引数据不同步（不支持大型项目）</li><li>索引数据如果太多就不行，索引库和应用所在同一个服务器,共同占用硬盘.共用空间少.</li></ul><p><strong>上述Lucene框架中的缺点,ES全部都能解决.</strong></p><h2 id="哪些公司在使用Elasticsearch"><a href="#哪些公司在使用Elasticsearch" class="headerlink" title="哪些公司在使用Elasticsearch"></a>哪些公司在使用Elasticsearch</h2><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz2vhwoyi1j309q0isq3h.jpg" style="zoom:50%;" /><h2 id="ES-vs-Solr比较"><a href="#ES-vs-Solr比较" class="headerlink" title="ES vs Solr比较"></a>ES vs Solr比较</h2><ul><li>当单纯的对已有数据进行搜索时，Solr更快。</li><li>当实时建立索引时,Solr会产生io阻塞，查询性能较差,Elasticsearch具有明显的优势。</li><li>Solr利用Zookeeper进行分布式管理，而Elasticsearch自身带有分布式协调管理功能。</li><li>Solr支持更多格式的数据，比如JSON、XML、CSV，而Elasticsearch仅支持json文件格式。</li><li>Solr在传统的搜索应用中表现好于Elasticsearch，但在处理实时搜索应用时效率明显低于Elasticsearch。</li><li>Solr是传统搜索应用的有力解决方案，但Elasticsearch更适用于新兴的实时搜索应用。</li></ul><h2 id="ESvs关系型数据库"><a href="#ESvs关系型数据库" class="headerlink" title="ESvs关系型数据库"></a>ESvs关系型数据库</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz2vkt8j0jj30zu0fsgn8.jpg"></p><h2 id="Lucene全文检索框架"><a href="#Lucene全文检索框架" class="headerlink" title="Lucene全文检索框架"></a>Lucene全文检索框架</h2><h3 id="什么是全文检索"><a href="#什么是全文检索" class="headerlink" title="什么是全文检索"></a>什么是全文检索</h3><ul><li>全文检索是指：通过一个程序扫描文本中的每一个单词，针对单词建立索引，并保存该单词在文本中的位置、以及出现的次数。</li><li>用户查询时，通过之前建立好的索引来查询，将索引中单词对应的文本位置、出现的次数返回给用户，因为有了具体文本的位置，所以就可以将具体内容读取出来了</li></ul><h3 id="词原理之倒排索引"><a href="#词原理之倒排索引" class="headerlink" title="词原理之倒排索引"></a>词原理之倒排索引</h3><p>对于关系型数据库mysql来说，<strong>普通的索引结构就是“id-&gt;题目-&gt;内容”，</strong>在我们搜索的时候，如果我们知道id或者题目<strong>，那么检索效率是很高效的，因为“id”、“题目”是很方便创建索引的。</strong></p><p>那么<strong>倒排序索引</strong>的结构是怎样的呢？简单来讲<strong>就是“以内容的关键词”建立索引，</strong>映射关系为<strong>“内容的关键词-&gt;ID”。</strong>这样的话，我们只需要在“关键词”中进行检索</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz2vpv36j1j30z40em40a.jpg"></p><blockquote><p>对于上面的场景，输入为hello，会根据hello定位到此时数据的id为1和2，进而查出对应的数据。</p></blockquote><h2 id="Elasticsearch中的核心概念"><a href="#Elasticsearch中的核心概念" class="headerlink" title="Elasticsearch中的核心概念"></a>Elasticsearch中的核心概念</h2><h3 id="索引index"><a href="#索引index" class="headerlink" title="索引index"></a>索引index</h3><ul><li>一个索引就是一个拥有几分相似特征的文档的集合。比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引</li><li>一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字</li></ul><h3 id="映射mapping"><a href="#映射mapping" class="headerlink" title="映射mapping"></a>映射mapping</h3><ul><li><p>ElasticSearch中的映射（Mapping）用来定义一个文档</p></li><li><p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分词器、是否被索引等等，这些都是映射里面可以设置的</p></li></ul><h3 id="字段Field"><a href="#字段Field" class="headerlink" title="字段Field"></a>字段Field</h3><ul><li>相当于是数据表的字段|列</li></ul><h3 id="字段类型Type"><a href="#字段类型Type" class="headerlink" title="字段类型Type"></a>字段类型Type</h3><p>每一个字段都应该有一个对应的类型，例如：Text、Keyword、Byte等</p><h3 id="文档document"><a href="#文档document" class="headerlink" title="文档document"></a>文档document</h3><p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（JavascriptObjectNotation）格式来表示；</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oauth2</title>
    <link href="/oauth2/"/>
    <url>/oauth2/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="oauth2-0"><a href="#oauth2-0" class="headerlink" title="oauth2.0"></a>oauth2.0</h1><h2 id="一-oauth2-0-产生"><a href="#一-oauth2-0-产生" class="headerlink" title="一. oauth2.0 产生"></a>一. oauth2.0 产生</h2><ol><li>传统方式：用户和第三方共享密码<ul><li>不安全。未来可能会持久访问资源，第三方存储用户密码不安全，因为他可以访问用户的所有资源</li><li>改密码的话，第三方会失效</li></ul></li></ol><h2 id="二-oauth2-0是什么？"><a href="#二-oauth2-0是什么？" class="headerlink" title="二. oauth2.0是什么？"></a>二. oauth2.0是什么？</h2><blockquote><ul><li><p>oauth2.0 是一种授权方式，使第三方可以获得对用户资源的访问</p></li><li><p>他的核心就是：向第三方应用颁发令牌</p></li><li><p>不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）</p></li></ul></blockquote><h2 id="三-OAuth-2-0-规定了四种获得令牌的流程"><a href="#三-OAuth-2-0-规定了四种获得令牌的流程" class="headerlink" title="三.OAuth 2.0 规定了四种获得令牌的流程"></a>三.OAuth 2.0 规定了四种获得令牌的流程</h2><span id="more"></span><h3 id="3-1-授权码模式"><a href="#3-1-授权码模式" class="headerlink" title="3.1 授权码模式"></a>3.1 授权码模式</h3><p><strong>第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><ol><li><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">https:<span class="hljs-comment">//b.com/oauth/authorize?</span><br>  response_type=code&amp;                        <br>  client_id=CLIENT_ID&amp;<br>  redirect_uri=CALLBACK_URL&amp;<br>  scope=read<br></code></pre></td></tr></table></figure><ul><li>response_type表示要求返回授权码</li><li>client_id让B网站知道是谁在请求</li><li>redirect_uri 是B网站接受或处理后跳转的URL</li><li>scope 表示授权的范围，这里是只读</li></ul></li><li><p>第二步，此时B网站会询问用户是否给予A网站授权，用户表示同意，这时B网站就会跳转到上一步<code>redirect_uri</code> 中的地址（也就是我们常说的callback地址），同时返回一个授权码，如下面的地址，其中，<code>code</code>参数就是授权码</p></li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//a.com/callback?code=AUTHORIZATION_CODE</span><br></code></pre></td></tr></table></figure><ol start="3"><li>第三步，A网站拿到授权码后，就可以根据该授权码，在后端向B网站请求<strong>令牌</strong></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/token?</span><br> <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br> <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET&amp;</span><br> <span class="hljs-attr">grant_type</span>=<span class="hljs-string">authorization_code&amp;</span><br> <span class="hljs-attr">code</span>=<span class="hljs-string">AUTHORIZATION_CODE&amp;</span><br> <span class="hljs-attr">redirect_uri</span>=<span class="hljs-string">CALLBACK_URL</span><br></code></pre></td></tr></table></figure><ul><li><p><code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求）</p></li><li><p><code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码</p></li><li><p><code>code</code>参数是上一步拿到的授权码</p></li><li><p><code>redirect_uri</code>参数是令牌颁发后的回调网址。</p></li></ul><ol start="4"><li><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim">&#123;    <br>  <span class="hljs-string">&quot;access_token&quot;</span>:<span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span>,<br>  <span class="hljs-string">&quot;token_type&quot;</span>:<span class="hljs-string">&quot;bearer&quot;</span>,<br>  <span class="hljs-string">&quot;expires_in&quot;</span>:<span class="hljs-number">2592000</span>,<br>  <span class="hljs-string">&quot;refresh_token&quot;</span>:<span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span>,<br>  <span class="hljs-string">&quot;scope&quot;</span>:<span class="hljs-string">&quot;read&quot;</span>,<br>  <span class="hljs-string">&quot;uid&quot;</span>:<span class="hljs-number">100101</span>,<br>  <span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p></li></ol><h4 id="3-2-隐藏式模式（适合没有后台的第三方）"><a href="#3-2-隐藏式模式（适合没有后台的第三方）" class="headerlink" title="3.2 隐藏式模式（适合没有后台的第三方）"></a>3.2 隐藏式模式（适合没有后台的第三方）</h4><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/authorize?</span><br>  <span class="hljs-attr">response_type</span>=<span class="hljs-string">token&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">redirect_uri</span>=<span class="hljs-string">CALLBACK_URL&amp;</span><br>  <span class="hljs-attr">scope</span>=<span class="hljs-string">read</span><br></code></pre></td></tr></table></figure><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>a.com/callback<span class="hljs-comment">#token=ACCESS_TOKEN</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p><ol><li>点击链接，跳转至第三方</li><li>第三方直接把令牌给客户端</li></ol><p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h4 id="3-3-密码模式（风险极大，适合于用户极其信任第三方）"><a href="#3-3-密码模式（风险极大，适合于用户极其信任第三方）" class="headerlink" title="3.3 密码模式（风险极大，适合于用户极其信任第三方）"></a>3.3 密码模式（风险极大，适合于用户极其信任第三方）</h4><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌</strong></p><ol><li>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。、</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//oauth.b.com/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">password&amp;</span><br>  <span class="hljs-attr">username</span>=<span class="hljs-string">USERNAME&amp;</span><br>  <span class="hljs-attr">password</span>=<span class="hljs-string">PASSWORD&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><ol start="2"><li>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</li></ol><h4 id="3-4-凭证式模式（适合没有前端的第三方）"><a href="#3-4-凭证式模式（适合没有前端的第三方）" class="headerlink" title="3.4 凭证式模式（适合没有前端的第三方）"></a>3.4 凭证式模式（适合没有前端的第三方）</h4><p><strong>命令行下请求令牌。</strong>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><ol><li>第一步，A 应用在命令行向 B 发出请求。</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//oauth.b.com/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">client_credentials&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET</span><br></code></pre></td></tr></table></figure><ul><li><p><code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式</p></li><li><p><code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p></li></ul><ol start="2"><li>第二步，B 网站验证通过以后，直接返回令牌。</li></ol><p>适合场景：向该平台所有用户发送消息提醒</p><h2 id="四、令牌的使用"><a href="#四、令牌的使用" class="headerlink" title="四、令牌的使用"></a>四、令牌的使用</h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">curl -H <span class="hljs-string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> <span class="hljs-string">\</span><br><span class="hljs-string">&quot;https://api.b.com&quot;</span><br></code></pre></td></tr></table></figure><p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p><h2 id="五、更新令牌"><a href="#五、更新令牌" class="headerlink" title="五、更新令牌"></a>五、更新令牌</h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//b.com/oauth/token?</span><br>  <span class="hljs-attr">grant_type</span>=<span class="hljs-string">refresh_token&amp;</span><br>  <span class="hljs-attr">client_id</span>=<span class="hljs-string">CLIENT_ID&amp;</span><br>  <span class="hljs-attr">client_secret</span>=<span class="hljs-string">CLIENT_SECRET&amp;</span><br>  <span class="hljs-attr">refresh_token</span>=<span class="hljs-string">REFRESH_TOKEN</span><br></code></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p>]]></content>
    
    
    <categories>
      
      <category>oauth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper集群特性</title>
    <link href="/zookeeper%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7/"/>
    <url>/zookeeper%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="Zookeeper集群"><a href="#Zookeeper集群" class="headerlink" title="Zookeeper集群"></a>Zookeeper集群</h2><hr><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>zookeeper集群是为了保证系统的性能，能够承载更多的客户端连接。通过集群可以实现以下功能：</p><ul><li>读写分离：提高承载，为更多的客户端提供连接，并保障性能。</li><li>主从自动切换：提高服务容错性，部分节点故障不会影响整个服务集群。</li></ul><h2 id="半数以上运行机制说明"><a href="#半数以上运行机制说明" class="headerlink" title="半数以上运行机制说明"></a>半数以上运行机制说明</h2><p>集群至少需要三台服务器，并且强烈建议使用奇数个服务器。</p><p>因为zookeeper 通过判断大多数节点的存活来判断整个服务是否可用。比如3个节点，挂掉了2个表示整个集群挂掉，而用偶数4个，挂掉了2个也表示其并不是大部分存活，因此也会挂掉。</p><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h3 id="配置语法："><a href="#配置语法：" class="headerlink" title="配置语法："></a>配置语法：</h3><p><code>server.&lt;节点ID&gt;=&lt;ip&gt;:&lt;数据同步端口&gt;:&lt;选举端口&gt;</code></p><ul><li>节点ID：服务id手动指定1至125之间的数字，并写到对应服务节点的 {dataDir}&#x2F;myid 文件中。</li><li>IP地址：节点的远程IP地址，可以相同。但生产环境就不能这么做了，因为在同一台机器就无法达到容错的目的。所以这种称作为伪集群。</li><li>数据同步端口：主从同时数据复制端口，（做伪集群时端口号不能重复）。</li><li>远举端口：主从节点选举端口，（做伪集群时端口号不能重复）。</li></ul><p><strong>配置文件示例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attribute">dataDir</span>=/var/lib/zookeeper/<br><span class="hljs-attribute">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-attribute">initLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attribute">syncLimit</span>=<span class="hljs-number">2</span><br><span class="hljs-comment">#以下为集群配置，必须配置在所有节点的zoo.cfg文件中</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">1</span>=zoo<span class="hljs-number">1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">2</span>=zoo<span class="hljs-number">2</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attribute">server</span>.<span class="hljs-number">3</span>=zoo<span class="hljs-number">3</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br></code></pre></td></tr></table></figure><h3 id="集群配置流程："><a href="#集群配置流程：" class="headerlink" title="集群配置流程："></a>集群配置流程：</h3><ol><li>分别创建3个data目录用于存储各节点数据</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span></span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/1</span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/3</span><br><span class="hljs-title">mkdir</span> <span class="hljs-class"><span class="hljs-keyword">data</span>/3</span><br></code></pre></td></tr></table></figure><ol start="2"><li>编写myid文件</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> <span class="hljs-number">1</span> &gt; data/<span class="hljs-number">1</span>/myid<br><span class="hljs-attribute">echo</span> <span class="hljs-number">3</span> &gt; data/<span class="hljs-number">3</span>/myid<br><span class="hljs-attribute">echo</span> <span class="hljs-number">2</span> &gt; data/<span class="hljs-number">2</span>/myid<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ls -R data<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><br>data/<span class="hljs-number">1</span>:<br>myid<br><br>data/<span class="hljs-number">2</span>:<br>myid<br><br>data/<span class="hljs-number">3</span>:<br>myid<br></code></pre></td></tr></table></figure><p>3、编写配置文件</p><ul><li><code>vim conf/zoo1.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">1</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><ul><li><code>vim conf/zoo2.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">2</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2182</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><ul><li><code>vim conf/zoo3.cfg</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=data/<span class="hljs-number">3</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2183</span><br><span class="hljs-comment">#集群配置</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure><p>4.分别启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo1.cfg<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo2.cfg<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh start conf/zoo3.cfg<br></code></pre></td></tr></table></figure><p>5.分别查看状态</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo1.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo2.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo3.cfg<br>Mode: leader<br></code></pre></td></tr></table></figure><ol start="6"><li>进入客户端，在server1中创建节点，server 3查看节点是否同步</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">.<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>zkCli.sh <span class="hljs-operator">-</span>server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span><br><br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">0</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">1</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>tt<br>Created <span class="hljs-operator">/</span>tt0000000001<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>,<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2182</span>(CONNECTED) <span class="hljs-number">2</span>] ls <span class="hljs-operator">/</span><br>[tt0000000001, zookeeper]<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">.<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>zkCli.sh <span class="hljs-operator">-</span>server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2183</span><br><br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2183</span>(CONNECTED) <span class="hljs-number">1</span>] ls <span class="hljs-operator">/</span><br>[tt0000000001, zookeeper]<br></code></pre></td></tr></table></figure><h2 id="集群角色说明"><a href="#集群角色说明" class="headerlink" title="集群角色说明"></a>集群角色说明</h2><p>zookeeper 集群中总共有三种角色，分别是leader（主节点）follower(子节点) observer（次级子节点）</p><table><thead><tr><th align="left">角色</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>leader</strong></td><td align="left">主节点，又名领导者。用于写入数据，通过选举产生，如果宕机将会选举新的主节点。</td></tr><tr><td align="left"><strong>follower</strong></td><td align="left">子节点，又名追随者。用于实现数据的读取。同时他也是主节点的备选节点，并用拥有投票权。</td></tr><tr><td align="left"><strong>observer</strong></td><td align="left">次级子节点，又名观察者。用于读取数据，与fllower区别在于没有投票权，不能选为主节点。并且在计算集群可用状态时不会将observer计算入内。</td></tr></tbody></table><p><strong>observer配置：</strong><br>只要在集群配置中加上observer后缀即可，示例如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">server</span>.<span class="hljs-number">3</span>=<span class="hljs-number">127.0.0.1:2889</span>:<span class="hljs-number">3889</span>:observer<br></code></pre></td></tr></table></figure><h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>通过 .&#x2F;bin&#x2F;zkServer.sh status &lt;zoo配置文件&gt; 命令可以查看到节点状态，可以发现中间的2182 是leader状态</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo1.cfg<br>Mode: follower<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo2.cfg<br>Mode: leader<br>.<span class="hljs-regexp">/bin/</span>zkServer.sh status conf/zoo3.cfg<br>Mode: follower<br></code></pre></td></tr></table></figure><h3 id="投票机制说明"><a href="#投票机制说明" class="headerlink" title="投票机制说明"></a>投票机制说明</h3><ol><li><p>第一轮投票全部投给自己</p></li><li><p>第二轮投票给myid比自己大的相邻节点，</p></li><li><p>如果得票超过半数，选举结束。</p></li></ol><p>其选举机制如下图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gywytfrbw1j31bi0u0gpa.jpg"></p><h3 id="选举触发："><a href="#选举触发：" class="headerlink" title="选举触发："></a><strong>选举触发：</strong></h3><p>当集群中的服务器出现已下两种情况时会进行Leader的选举</p><ol><li>服务节点初始化启动。当节点初始起动时会在集群中寻找Leader节点，如果找到则与Leader建立连接，其自身状态变化<strong>follower</strong>或<strong>observer。</strong>如果没有找到Leader，当前节点状态将变化LOOKING，进入选举流程。</li><li>半数以上的节点无法和Leader建立连接。在集群运行其间如果有follower或observer节点宕机只要不超过半数并不会影响整个集群服务的正常运行。但如果leader宕机，将暂停对外服务，所有follower将进入LOOKING 状态，进入选举流程。</li></ol><h2 id="数据同步机制"><a href="#数据同步机制" class="headerlink" title="数据同步机制"></a>数据同步机制</h2><p>zookeeper 的数据同步是为了保证各节点中数据的一至性，同步时涉及两个流程，一个是正常的客户端数据提交，另一个是集群某个节点宕机在恢复后的数据同步。</p><h3 id="客户端写入请求"><a href="#客户端写入请求" class="headerlink" title="客户端写入请求"></a>客户端写入请求</h3><p>写入请求的大至流程是，收leader接收客户端写请求，并同步给各个子节点。如下图：</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gywz51yujxj30xi0r2taw.jpg" style="zoom:50%;" /><p>但实际情况要复杂的多，比如client 它并不知道哪个节点是leader 有可能写的请求会发给follower ，由follower在转发给leader进行同步处理</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gywz6vog9pj316g0u00wf.jpg" style="zoom: 50%;" /><p>客户端写入流程说明：</p><ol><li>client向zk中的server发送写请求，如果该server不是leader，则会将该写请求转发给leader server，leader将请求事务以proposal（建议）形式分发给follower；</li><li>当follower收到收到leader的proposal时，根据接收的先后顺序处理proposal；</li><li>当Leader收到follower针对某个proposal过半的ack后，（即follower过半都已经同步完成）则发起事务提交，重新发起一个commit的proposal</li><li>Follower收到commit的proposal后，记录事务提交，并把数据更新到内存数据库；</li><li>当写成功后，反馈给client。</li></ol><h3 id="服务节点初始化同步"><a href="#服务节点初始化同步" class="headerlink" title="服务节点初始化同步"></a>服务节点初始化同步</h3><ul><li><p>在集群运行过程当中如果有一个follower节点宕机，由于宕机节点没过半，集群仍然能正常服务。</p></li><li><p>当leader 收到新的客户端请求，此时无法同步给宕机的节点。造成数据不一致。为了解决这个问题，当节点启动时，第一件事情就是找当前的Leader，比对数据是否一致。不一致则开始同步,同步完成之后在进行对外提供服务。故在节点同步数据期间，该节点不会对外提供服务。</p></li><li><p>Leader挂了后，选举leader的过程中，集群不可以对外提供服务。</p></li></ul><h3 id="5-四字运维命令"><a href="#5-四字运维命令" class="headerlink" title="5.四字运维命令"></a>5.四字运维命令</h3><p>ZooKeeper响应少量命令。每个命令由四个字母组成。可通过telnet或nc向ZooKeeper发出命令。<br>这些命令默认是关闭的，需要配置4lw.commands.whitelist来打开，可打开部分或全部示例如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#打开指定命令</span><br>4lw.commands.<span class="hljs-attribute">whitelist</span>=stat, ruok, conf, isro<br><span class="hljs-comment">#打开全部</span><br>4lw.commands.<span class="hljs-attribute">whitelist</span>=*<br><span class="hljs-comment">#查看服务器及客户端连接状态</span><br>echo stat | nc localhost 2181<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo stat | nc localhost <span class="hljs-number">2181</span><br>stat is not executed because it is not in the whitelist.<br><br>## 打开全部nc命令<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo1.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo2.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin echo <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot;</span> &gt;&gt; conf/zoo3.cfg<br><br>## 重启服务<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo1.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo2.cfg<br>➜  apache-zookeeper-<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>-bin ./bin/zkServer.sh restart conf/zoo3.cfg<br></code></pre></td></tr></table></figure><h3 id="ZXID说明"><a href="#ZXID说明" class="headerlink" title="ZXID说明"></a>ZXID说明</h3><blockquote><p>如何比对Leader的数据版本呢，这里通过ZXID事物ID来确认。比Leader小就需要同步。</p></blockquote><ul><li><p>ZXID是一个长度64位的数字，其中低32位是按照数字递增，任何数据的变更都会导致低32位的数字加1。</p></li><li><p>高32位是leader周期编号，每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的。</p></li></ul><p> </p><p>eg1: 节点数据的变更</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyx6ctcstxj31460siaea.jpg"></p><p>Eg2: 某个节点挂掉重新选举</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyx6bhhfxpj30we0qmgpn.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyx66k725nj31620tytd3.jpg"></p><p><strong>思考题：</strong><br>如果leader 节点宕机，在恢复后它还能被选为leader吗？</p><p>不会，因为它的数据不是最新的。</p>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper客户端使用</title>
    <link href="/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/"/>
    <url>/zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="客户端API常规应用"><a href="#客户端API常规应用" class="headerlink" title="客户端API常规应用"></a>客户端API常规应用</h2><hr><p>zookeeper 提供了java与C两种语言的客户端。我们要学习的就是java客户端。引入最新的maven依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;<br>  &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">3.6</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="初始连接"><a href="#初始连接" class="headerlink" title="初始连接"></a>初始连接</h2><p>常规的客户端类是 org.apache.zookeeper.ZooKeeper，实例化该类之后将会自动与集群建立连接。</p><ul><li>connectString    连接串，包括ip+端口 ,集群模式下用逗号隔开</li><li>sessionTimeout  会话超时时间，该值不能超过服务端所设置的 minSessionTimeout 和maxSessionTimeout</li><li>watcher 会话监听器，服务端事件将会触该监听</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(<span class="hljs-string">&quot;192.168.2.103:2181&quot;</span>, <span class="hljs-number">4000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;init:&quot;</span>+watchedEvent.getPath());<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="创建、查看节点"><a href="#创建、查看节点" class="headerlink" title="创建、查看节点"></a>创建、查看节点</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>通过org.apache.zookeeper.ZooKeeper#create()即可创建节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  List&lt;ACL&gt; aclList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">int</span> perm = ZooDefs.Perms.ADMIN | ZooDefs.Perms.READ;<br>  <br>  <span class="hljs-comment">// perms 对应权限位permission</span><br>  <span class="hljs-comment">// id 对应权限模式scheme + id</span><br>  ACL acl1 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;anyone&quot;</span>));<br>  ACL acl2 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;ip&quot;</span>,<span class="hljs-string">&quot;192.168.2.103&quot;</span>));<br>  ACL acl3 = <span class="hljs-keyword">new</span> ACL(perm, <span class="hljs-keyword">new</span> Id(<span class="hljs-string">&quot;ip&quot;</span>,<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br><br>  aclList.add(acl1);<br>  aclList.add(acl2);<br>  aclList.add(acl3);<br>  zooKeeper.create(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-string">&quot;hello word!&quot;</span>.getBytes(), aclList, CreateMode.PERSISTENT);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行完成后，在zookeeper进行查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">64</span>] getAcl /hello<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: ra<br><span class="hljs-string">&#x27;ip,&#x27;</span><span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.103</span><br>: ra<br><span class="hljs-string">&#x27;ip,&#x27;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>: ra<br>[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">65</span>] get /hello<br>hello word<br></code></pre></td></tr></table></figure><h3 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h3><h4 id="查看当前节点"><a href="#查看当前节点" class="headerlink" title="查看当前节点"></a>查看当前节点</h4><p>通过org.apache.zookeeper.ZooKeeper#getData()即可查看节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>  System.out.println(<span class="hljs-string">&quot;testData:&quot;</span> + <span class="hljs-keyword">new</span> String(keeperData));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a>查看子节点</h4><p>通过org.apache.zookeeper.ZooKeeper#getChildren()即可获取子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetChildrenWithoutWatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> List&lt;String&gt; children = zooKeeper.getChildren(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">false</span>);<br>  children.stream().forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="监听节点"><a href="#监听节点" class="headerlink" title="监听节点"></a>监听节点</h2><ul><li><p>在getData() 与getChildren()两个方法中可分别设置监听数据变化和子节点变化。</p></li><li><p>通过设置watch为true，当前事件触发时会调用zookeeper()构建函数中Watcher.process()方法。也可以添加watcher参数来实现自定义监听。一般采用后者。</p></li><li><p>所有的监听都是一次性的，如果要持续监听需要触发后在添加一次监听。</p></li></ul><p><strong>使用默认监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDataWithWatcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>);<br>  System.out.println(<span class="hljs-string">&quot;testGetDataWithWatcher:&quot;</span> + <span class="hljs-keyword">new</span> String(keeperData));<br>  Thread.sleep(Long.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDataWithCustomWatcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] keeperData = zooKeeper.getData(<span class="hljs-string">&quot;/pyr&quot;</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        zooKeeper.getData(<span class="hljs-string">&quot;/temp&quot;</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (KeeperException | InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;testGetDataWithCustomWatcher:&quot;</span> + watchedEvent.getPath());<br><br>    &#125;<br>  &#125;, <span class="hljs-keyword">null</span>);<br>  Thread.sleep(Long.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三方客户端ZkClient"><a href="#第三方客户端ZkClient" class="headerlink" title="第三方客户端ZkClient"></a>第三方客户端ZkClient</h2><p>zkClient 是在zookeeper客户端基础之上封装的，使用上更加友好。主要变化如下：</p><ul><li>可以设置持久监听，或删除某个监听</li><li>可以插入JAVA对象，自动进行序列化和反序列化</li><li>简化了基本的增删改查操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper特性与节点介绍</title>
    <link href="/zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/"/>
    <url>/zookeeper%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><ol><li><p>单体向分布式服务转变，会产生多个节点间协同问题，如：</p><blockquote><ul><li><p>假设有3个节点，1个job，该job该由哪个节点执行？</p></li><li><p>若该job由节点1执行，要是1挂了，现在该2还是3执行？</p></li></ul></blockquote></li><li><p>上游和下游服务的发现，如：</p><blockquote><ul><li>上游挂了，下游怎么知道？</li><li>下游服务新增，上游怎么知道？</li></ul></blockquote></li><li><p>多节点的协调问题，如：并发产生了请求，该怎么保证请求的幂等性？</p></li></ol><blockquote><p><strong>由于节点自身协调不可靠，性能不高，故需要一个独立服务来做协调，他必须可靠且保证性能。</strong></p></blockquote><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ol><li>zookeeper是用于分布式服务的协调服务。</li><li>它对外公布了一组简单的API，分布式应用程序可以基于这些API，用于同步节点状态，节点配置，服务注册等信息</li><li>它支持java和c两种语言。</li></ol><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>从设计模式的角度理解，zookeeper基于观察者模式。他负责存储和管路大家都关心的数据，然后接受观察，一旦数据状态发生变化，zookeeper就通知注册者。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>zookeeper是由一个leader和多个follower组成的集群</li><li>半数以上节点存活，zookeeper 即可以正常服务</li><li>每个server的数据一致</li><li>来自同一个client的请求依次执行</li><li>原子性，数据更新要么成功，要么失败</li><li>zookeeper数据量少，故同步快，一定时间内，client可以读到最新数据</li></ol><h2 id="zookeeper-启动"><a href="#zookeeper-启动" class="headerlink" title="zookeeper 启动"></a>zookeeper 启动</h2><ul><li>官网下载最新版本 <a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz">Apache Downloads</a>，并解压</li><li>进入conf目录，拷贝默认配置  <code>cp zoo_sample.cfg   zoo.cfg</code></li><li>进入bin目录，启动服务端<code>./zkServer.sh start</code></li><li>进入bin目录，进入客户端<code>./zkCli.sh</code></li></ul><h2 id="常规配置文件说明"><a href="#常规配置文件说明" class="headerlink" title="常规配置文件说明"></a>常规配置文件说明</h2><blockquote><p>tickTime&#x3D;2000   #zookeeper时间配置中的基本单位 (毫秒) </p></blockquote><blockquote><p>initLimit&#x3D;10     #允许follower初始化连接到leader最大时长，它表示tickTime时间倍数 即:initLimit*tickTime</p></blockquote><blockquote><p>syncLimit&#x3D;5 #允许follower与leader数据同步最大时长,它表示tickTime时间倍数</p></blockquote><blockquote><p>dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper  #zookeper 数据存储目录</p></blockquote><blockquote><p>clientPort&#x3D;2181  #对客户端提供的端口号</p></blockquote><blockquote><p>maxClientCnxns&#x3D;60  #单个客户端与zookeeper最大并发连接数</p></blockquote><blockquote><p>autopurge.snapRetainCount&#x3D;3. #保存的数据快照数量，之外的将会被清除</p></blockquote><blockquote><p>autopurge.purgeInterval&#x3D;1  #自动触发清除任务时间间隔，小时为单位。默认为0，表示不自动清除。</p></blockquote><h2 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h2><ul><li><p>close     关闭当前会话</p></li><li><p>connect host:port        重新连接指定Zookeeper服务</p></li><li><p>create [-s] [-e] [-c] [-t ttl] path [data] [acl]          创建节点</p></li><li><p>delete [-v version] path             删除节点，(不能存在子节点） </p></li><li><p>deleteall path [-b batch size]      删除路径及所有子节点</p></li><li><p>get [-s] [-w] path.        查看节点数据 -s 包含节点状态 -w 添加监听 </p></li><li><p>getAcl [-s] path.      列出子节点 -s状态 -R 递归查看所有子节点 -w 添加监听</p></li><li><p>history     查看执行的历史记录</p></li><li><p>redo cmdno  重复 执行命令，history 中命令编号确定</p></li><li><p>quit  退出客户端</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">1</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">2</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<br>Created <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">3</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-keyword">null</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">4</span>] <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>node1 &quot;node1 value&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">5</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br>node1 <span class="hljs-keyword">value</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">6</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>Created <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">7</span>] <span class="hljs-keyword">set</span>  <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">8</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-string">&#x27;get path [watch]&#x27;</span> has been deprecated. Please use <span class="hljs-string">&#x27;get [-s] [-w] path&#x27;</span> instead.<br>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">10</span>] <span class="hljs-keyword">delete</span> <span class="hljs-operator">/</span>node1<br>Node <span class="hljs-keyword">not</span> <span class="hljs-keyword">empty</span>: <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">11</span>] deleteall <span class="hljs-operator">/</span>node1<br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeDeleted path:<span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">12</span>] ls <span class="hljs-operator">/</span><br>[zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] history<br><span class="hljs-number">3</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">4</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>node1 &quot;node1 value&quot;<br><span class="hljs-number">5</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">6</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br><span class="hljs-number">7</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">set</span>  <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-number">8</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1 &quot;child1&quot;<br><span class="hljs-number">9</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>node1<span class="hljs-operator">/</span>child1<br><span class="hljs-number">10</span> <span class="hljs-operator">-</span> <span class="hljs-keyword">delete</span> <span class="hljs-operator">/</span>node1<br><span class="hljs-number">11</span> <span class="hljs-operator">-</span> deleteall <span class="hljs-operator">/</span>node1<br><span class="hljs-number">12</span> <span class="hljs-operator">-</span> ls <span class="hljs-operator">/</span><br><span class="hljs-number">13</span> <span class="hljs-operator">-</span> history<br><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">16</span>] redo <span class="hljs-number">2</span><br>Created <span class="hljs-operator">/</span>node1<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">17</span>] ls <span class="hljs-operator">/</span><br>[node1, zookeeper]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">18</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>node1<br><span class="hljs-keyword">null</span><br>cZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>ctime <span class="hljs-operator">=</span> Thu Jan <span class="hljs-number">13</span> <span class="hljs-number">22</span>:<span class="hljs-number">49</span>:<span class="hljs-number">37</span> CST <span class="hljs-number">2022</span><br>mZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>mtime <span class="hljs-operator">=</span> Thu Jan <span class="hljs-number">13</span> <span class="hljs-number">22</span>:<span class="hljs-number">49</span>:<span class="hljs-number">37</span> CST <span class="hljs-number">2022</span><br>pZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x8</span><br>cversion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>dataVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>aclVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>ephemeralOwner <span class="hljs-operator">=</span> <span class="hljs-number">0x0</span><br>dataLength <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>numChildren <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="节点介绍"><a href="#节点介绍" class="headerlink" title="节点介绍"></a>节点介绍</h2><h3 id="数据基本单元"><a href="#数据基本单元" class="headerlink" title="数据基本单元"></a>数据基本单元</h3><ul><li>zookeepe中的基本数据单元是——节点（znode）。节点之下可以包含子节点，最后以树级方式呈现。</li></ul><ul><li>每个节点拥有唯一的路径path.</li><li>客户端基于path上传节点数据，zookeepe收到数据后，会通知监听该节点的客户端（一个或多个）。</li><li>之前，各个节点的数据是相互孤立的（也可以自己同步，但是没有zookeeper性能高，可靠）。现在，有了zookeeper,各节点的数据可以通过zookeeper可以得到一个高性能高可靠的同步。</li></ul><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycegg0aihj30u00v0wgk.jpg" style="zoom:50%;" /><h3 id="节点的结构"><a href="#节点的结构" class="headerlink" title="节点的结构"></a>节点的结构</h3><ul><li><strong>path</strong>:唯一路径 </li><li><strong>childNode</strong>：子节点</li><li><strong>stat</strong>:状态属性:即path对应的值</li><li><strong>type</strong>:节点类型</li></ul><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><table><thead><tr><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">PERSISTENT</td><td align="left">持久节点</td></tr><tr><td align="left">PERSISTENT_SEQUENTIAL</td><td align="left">持久序号节点</td></tr><tr><td align="left">EPHEMERAL</td><td align="left">临时节点(不可在拥有子节点)</td></tr><tr><td align="left">EPHEMERAL_SEQUENTIAL</td><td align="left">临时序号节点(不可在拥有子节点)</td></tr></tbody></table><h4 id="PERSISTENT（持久节点）"><a href="#PERSISTENT（持久节点）" class="headerlink" title="PERSISTENT（持久节点）"></a>PERSISTENT（持久节点）</h4><ul><li>持久化保存的节点，也是默认创建的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">/</span>test<br></code></pre></td></tr></table></figure><h4 id="PERSISTENT-SEQUENTIAL-持久序号节点"><a href="#PERSISTENT-SEQUENTIAL-持久序号节点" class="headerlink" title="PERSISTENT_SEQUENTIAL(持久序号节点)"></a>PERSISTENT_SEQUENTIAL(持久序号节点)</h4><p>创建时zookeeper 会在路径上加上序号作为后缀，。非常适合用于分布式锁、分布式选举等场景。创建时添加 -s 参数即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s  <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000004<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">14</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000005<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">15</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<br>Created <span class="hljs-operator">/</span>temp0000000006<br></code></pre></td></tr></table></figure><h4 id="EPHEMERAL（临时节点）"><a href="#EPHEMERAL（临时节点）" class="headerlink" title="EPHEMERAL（临时节点）"></a>EPHEMERAL（临时节点）</h4><ul><li>只存在于当前会话，当对话断开后会被删除。创建的时候增加 -e</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><ul><li>适用于心跳，服务发现等场景。如下图当node1挂掉了，它zookeeper1中创建的临时节点和其存储的数据就会就会被删除，zookeeper1就知道node1挂掉了。</li></ul><img src="/Users/panyurou/Library/Application Support/typora-user-images/image-20220116230200083.png" alt="image-20220116230200083" style="zoom:50%;" /><h4 id="EPHEMERAL-SEQUENTIAL（临时序号节点）"><a href="#EPHEMERAL-SEQUENTIAL（临时序号节点）" class="headerlink" title="EPHEMERAL_SEQUENTIAL（临时序号节点）"></a>EPHEMERAL_SEQUENTIAL（临时序号节点）</h4><p>与持久序号节点类似，不同之处在于EPHEMERAL_SEQUENTIAL是临时的会在会话断开后删除。创建时添加 -e -s </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>seq<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">2</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000000<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">3</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000001<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">4</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br>Created <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c10000000002<br></code></pre></td></tr></table></figure><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><ul><li>查看节点属性</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">stat <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure><ul><li>属性说明</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">cZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x2</span>   #创建节点的事务ID<br>ctime <span class="hljs-operator">=</span> Mon Jan <span class="hljs-number">17</span> <span class="hljs-number">21</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16</span> CST <span class="hljs-number">2022</span> #创建节点的时间<br>mZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x2</span> #修改当前节点数据的事务ID<br>mtime <span class="hljs-operator">=</span> Mon Jan <span class="hljs-number">17</span> <span class="hljs-number">21</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16</span> CST <span class="hljs-number">2022</span> #最后修改时间<br>pZxid <span class="hljs-operator">=</span> <span class="hljs-number">0x5</span> #子节点变更（包括自节点的删除和增加，不包括修改）的事务ID<br>cversion <span class="hljs-operator">=</span> <span class="hljs-number">3</span>  #这表示对此znode的子节点进行的更改次数，只包括自节点的删除和增加<br>dataVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #数据版本，当前节点数据变更次数<br>aclVersion <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #权限版本，变更次数<br>ephemeralOwner <span class="hljs-operator">=</span> <span class="hljs-number">0x0</span> #临时节点所属会话ID，永久节点值为<span class="hljs-number">0x0</span><br>dataLength <span class="hljs-operator">=</span> <span class="hljs-number">0</span> #数据长度<br>numChildren <span class="hljs-operator">=</span> <span class="hljs-number">3</span> #子节点数(不包括子子节点)<br></code></pre></td></tr></table></figure><h3 id="节点的监听"><a href="#节点的监听" class="headerlink" title="节点的监听"></a>节点的监听</h3><p>客户添加 -w 参数可实时监听节点与子节点的变化，并且实时收到通知。非常适用保障分布式情况下的数据一致性。其使用方式如下：</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ls -w path</td><td align="left">监听子节点的变化（增，删）</td></tr><tr><td align="left">get -w path</td><td align="left">监听节点数据的变化</td></tr><tr><td align="left">stat -w path</td><td align="left">监听节点属性的变化</td></tr><tr><td align="left">printwatches on|off</td><td align="left">触发监听后，是否打印监听事件(默认on)</td></tr></tbody></table><h4 id="监听节点数据的变化"><a href="#监听节点数据的变化" class="headerlink" title="监听节点数据的变化"></a>监听节点数据的变化</h4><ul><li><p>step1：打开客户端A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>Step2：打开客户端B:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;aaa&quot;<br></code></pre></td></tr></table></figure></li><li><p>此时客户端A，出现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">8</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br><span class="hljs-keyword">null</span><br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>]<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeDataChanged path:<span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>再次在客户端B输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;ddd&quot;<br></code></pre></td></tr></table></figure><p>此时可以发现，客户端A没有收到任何通知，故这里的watch是一次性的，第二次触发不再生效。</p></li></ul><h4 id="监听子节点的变化"><a href="#监听子节点的变化" class="headerlink" title="监听子节点的变化"></a>监听子节点的变化</h4><ul><li><p>step1：打开客户端A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ls <span class="hljs-operator">-</span>w  <span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure></li><li><p>Step2：打开客户端B:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">-</span>s <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>c1<br></code></pre></td></tr></table></figure></li><li><p>此时客户端A，出现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">9</span>] ls <span class="hljs-operator">-</span>w <span class="hljs-operator">/</span>temp<br>[c10000000000, c10000000001, c10000000002]<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">10</span>]<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:<span class="hljs-operator">/</span>temp<br></code></pre></td></tr></table></figure><h3 id="ACL权限设置"><a href="#ACL权限设置" class="headerlink" title="ACL权限设置"></a>ACL权限设置</h3></li><li><p>ACL全称为Access Control List（访问控制列表），用于控制资源的访问权限。   </p></li><li><p>ZooKeeper使用ACL来控制对其znode的防问。</p></li><li><p>基于<code>scheme:id:permission</code>的方式进行权限控制。scheme表示授权模式、id模式对应值、permission即具体的增删改权限位。</p></li></ul><h4 id="scheme-授权模型"><a href="#scheme-授权模型" class="headerlink" title="scheme:授权模型"></a>scheme:授权模型</h4><table><thead><tr><th align="left">方案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">world</td><td align="left">开放模式，world表示全世界都可以访问（这是默认设置）</td></tr><tr><td align="left">ip</td><td align="left">ip模式，限定客户端IP防问</td></tr><tr><td align="left">auth</td><td align="left">用户密码认证模式，只有在会话中添加了认证才可以防问</td></tr><tr><td align="left">digest</td><td align="left">与auth类似，区别在于auth用明文密码，而digest 用sha-1+base64加密后的密码。在实际使用中digest 更常见。</td></tr></tbody></table><h4 id="permission权限位"><a href="#permission权限位" class="headerlink" title="permission权限位"></a><strong>permission权限位</strong></h4><table><thead><tr><th align="left">权限位</th><th align="left">权限</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">CREATE</td><td align="left">可以创建子节点</td></tr><tr><td align="left">d</td><td align="left">DELETE</td><td align="left">可以删除子节点（仅下一级节点）</td></tr><tr><td align="left">r</td><td align="left">READ</td><td align="left">可以读取节点数据及显示子节点列表</td></tr><tr><td align="left">w</td><td align="left">WRITE</td><td align="left">可以设置节点数据</td></tr><tr><td align="left">a</td><td align="left">ADMIN</td><td align="left">可以设置节点访问控制列表权限</td></tr></tbody></table><h4 id="acl-相关命令"><a href="#acl-相关命令" class="headerlink" title="acl 相关命令"></a>acl 相关命令</h4><table><thead><tr><th align="left">命令</th><th align="left">使用方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getAcl</td><td align="left">getAcl <path></td><td align="left">读取ACL权限</td></tr><tr><td align="left">setAcl</td><td align="left">setAcl <path> <acl></td><td align="left">设置ACL权限</td></tr><tr><td align="left">addauth</td><td align="left">addauth <scheme> <auth></td><td align="left">添加认证用户</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>world</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">11</span>] getAcl <span class="hljs-operator">/</span>temp<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: cdrwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">12</span>] setAcl <span class="hljs-operator">/</span>temp world:anyone:rwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">13</span>] getAcl <span class="hljs-operator">/</span>temp<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: rwa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">14</span>] <span class="hljs-keyword">get</span> <span class="hljs-operator">/</span>temp<br>ddd<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">15</span>] <span class="hljs-keyword">set</span> <span class="hljs-operator">/</span>temp &quot;bbb&quot;<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">16</span>] <span class="hljs-keyword">create</span> <span class="hljs-operator">-</span>e <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>t<br>Insufficient permission : <span class="hljs-operator">/</span>temp<span class="hljs-operator">/</span>t<br></code></pre></td></tr></table></figure><ul><li><p>IP</p><p>语法： setAcl <path> ip:&lt;ip地址|地址段&gt;:&lt;权限位&gt;</p></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[zk: localhost<span class="hljs-function">:2181</span><span class="hljs-params">(CONNECTED)</span> 18] <span class="hljs-keyword">set</span>Acl <span class="hljs-string">/temp</span> ip<span class="hljs-function">:192.168.2.103</span><span class="hljs-function">:ra</span><br>[zk: localhost<span class="hljs-function">:2181</span><span class="hljs-params">(CONNECTED)</span> 19] getAcl <span class="hljs-string">/temp</span><br>Insufficient permission : <span class="hljs-string">/temp</span><br></code></pre></td></tr></table></figure><ul><li><p>auth</p><p>语法： </p><ol><li>setAcl <path> auth:&lt;用户名&gt;:&lt;密码&gt;:&lt;权限位&gt;</li><li>addauth digest &lt;用户名&gt;:&lt;密码&gt;</li></ol></li><li><p>digest</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">➜  <span class="hljs-operator">~</span> echo <span class="hljs-operator">-</span>n pyr:<span class="hljs-number">123456</span> <span class="hljs-operator">|</span> openssl dgst <span class="hljs-operator">-</span><span class="hljs-type">binary</span> <span class="hljs-operator">-</span>sha1 <span class="hljs-operator">|</span> openssl base64<br>zj9LbzdoKijw<span class="hljs-operator">/</span>kCo1pQJnXBFiq4<span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 28</span>] create /temp2<br>Created /temp2<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 30</span>] getAcl /temp2<br><span class="hljs-string">&#x27;world,&#x27;</span>anyone<br>: cdrwa<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 31</span>] setAcl /temp2 digest:pyr:zj9LbzdoKijw/kCo1pQJnXBFiq4=:rwa<br>[<span class="hljs-meta">zk: localhost:2181(CONNECTED) 32</span>] getAcl /temp2<br>Insufficient permission : /temp2<br>[<span class="hljs-meta">zk: 127.0.0.1:2181(CONNECTED) 45</span>] addauth digest pyr:<span class="hljs-number">123456</span><br>[<span class="hljs-meta">zk: 127.0.0.1:2181(CONNECTED) 46</span>] <span class="hljs-keyword">get</span> /temp2<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
