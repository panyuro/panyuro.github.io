---
title: 常见sql优化(二)
date: 2021-12-07 22:04:18
tags: mysql索引
categories: 性能调优
---

## 一  **分页查询优化** 

### 1. 根据自增且连续的主键排序的分页查询

> 原则：按照主键去查询

```sql 
mysql> select * from employees limit 90000,5;
```

表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，如下：

```sql
mysql> select * from employees where id > 90000 limit 5;
```

显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。 

但是，这条改写的SQL 在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致，如：先删除一条前面的记录，然后再测试原 SQL 和优化后的 SQL

### 2.根据非主键字段排序的分页查询

> 原则： 让排序和分页操作先查出主键，然后根据主键查到对应的记录，这样排序时返回的字段会少很多，从而会执行索引排序。

```sql
mysql> select * from employees ORDER BY name limit 90000,5;
```

表示根据非主键字段name排序的分页查询，发现并没有使用 name 字段的索引（key 字段对应的值为 null），具体原因为：扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。

改写后：

```sql
mysql> select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;
```

## 二   **Join关联查询优化** 

### mysql的表关联常见有两种算法

 #### 1.嵌套循环连接（Nested-Loop Join） 算法 

* 一次一行循环地从第一张表（称为**驱动表**）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（**被驱动**表）里取出满足条件的行，然后取出两张表的结果合集。

* 大致流程是：

  1. 第一步：从表 t2 中读取一行数据，根据关联字段 到表 t1 中查找

  2. 第二步：取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端； 

  3. 第三部：重复第二步

  > ```sql
  > mysql> EXPLAIN select*from t1 inner join t2 on t1.a= t2.a;
  > ```
  >
  > 假设t2有100条数据，t1有10000条。整个过程会读取 t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(**扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据（扫描索引很快，可以忽略），也就是总共 t1 表也扫描了100** 行**)。因此整个过程扫描了 **200 行。

* 优化器一般会优先选择小表做驱动表。**所以使用 inner join 时，排在前面的表并不一定就是驱动表。**

#### 2.基于块的嵌套循环连接（Block Nested-Loop Join） 算法 

* 把**驱动表**的数据读入到 join_buffer 中，然后扫描**被驱动表**，把**被驱动表**每一行取出来跟 join_buffer 中的数据做对比。 

* 大致流程是：

  1. 第一步：把t2中的所有数据放在join_buffer中

  2. 第二步：依次取出t1中的每一行，跟join_buffer中的数据做对比

  3. 第三部：返回满足条件的数据

  > 整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = **10100**。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= **100 万次**。 

### 对于关联sql的优化

* 关联字段加索引，让mysql做join操作时，尽量选择嵌套循环算法。

  > 从上面的例子可以对比看出，嵌套循环算法因为有索引，每次进行查找时，只需根据索引，查找一条匹配的数据，即扫描一次。但基于块的嵌套循环连接却因为没有索引，每次都需要进行一次全表扫描。

* 小表驱动大表。写多表连接sql时如果**明确知道**哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间。

  > straight_join同inner join类似，但是可以指定左边的表来驱动右边的表。但是使用它一定要慎重，因为大部分情况优化器是比人聪明的，人为指定的顺序不一定比搜索引擎靠谱。

## 三  **in和exsits优化** 

>  原则：**小表驱动大表**，即小的数据集驱动大的数据集 

- 当B表的数据集 < A表的数据集时，in优于exists

  ```sql
  select * from A where id in (select id from B) 
  #等价于：  
  for(select id from B){ 
      select * from A where A.id = B.id
  }
  ```

- 当B表的数据集 > B表的数据集时，exists优于in

  ```sql
  select * from A where exists (select 1 from B where b.id = A.id) 
  #等价于：  
  for(select id from A){
       select * from B where B.id = A.id
  }
  ```

  > EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会忽略SELECT清单,因此没有区别 

## 四  **count(\*)查询优化** 

### 查询mysql自己维护的总行数

* 对于**myisam存储引擎**的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被 mysql存储在磁盘上查询不需要计算 。
* 对于**innodb存储引擎**的表mysql不会存储表的总记录行数，查询count需要实时计算 

### **show table status**

* 如果只需要知道表总行数的估计值可以用如下sql查询，性能很高 .

  ![](https://tva1.sinaimg.cn/large/008i3skNly1gxdq94vfa1j31rk088q4o.jpg)

### count(\*)优化方式

* **将总数维护到Redis里** 

  插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准（如mysql执行成功了，redis没有更新成功），很难保证表操作和redis操作的事务一致性 ，可能得考虑分布式事务，适用于准确度要求不高的场景。

* **增加计数表**

  插入或删除表数据行的时候同时维护计数表（如新建一个表，该表增加一个字段user_count，insert user 的同时更新该字段），让他们在同一个事务里操作，让mysql的事务来保证一致性。
