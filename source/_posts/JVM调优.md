---
title: JVM调优
date: 2022-09-15 15:08:48
tags:
categories: 
---

# JVM调优

## 调优时机

- Full GC 次数频繁
- 应⽤用出现OutOfMemory 等内存异常
- 

JVM调优的方式其实就是减少Full GC, 

调整参数类似年轻代大小，老年代大小，eden和survivor的比例，大对象的大小

老年代的触发比例大小

## 1. 场景

天气预报系统，有一个展示所有城市天气预报的页面，由于城市比较多，需要分页去展示，于是先设置了一次查询5000条，由于每一条城市都需要再去给他设置对应的天气信息，所以搞了一个foreach每一条记录都需要new City()，然后再去set天气信息

初始参数是：

堆的最大和最小容量都设置了1536M, 年轻代是512M，使用的ParNew+CMS垃圾收集器，元空间256M

```
-Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=6 -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M 
‐XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 XX:+UseCMSInitiatingOccupancyOnly
```

## 2. 观察GC整体情况

- Step1 : 运行` jps`看下, 查看当前java进程PID

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h68t6kw94aj20bs05m0sx.jpg" style="zoom:67%;" />

- step2: 运行 `jstat -gc 2593 3000 10000`，每隔3秒，打印下GC压力整体情况。观察可发现，程序突然开始频繁Young Gc 和Full GC。

![image-20220916222011035](/Users/panyurou/Library/Application Support/typora-user-images/image-20220916222011035.png)

## 2. 思考Minor Gc 和Full Gc 触发条件

- Minor Gc 触发条件：当Eden区满时

- Full Gc 触发条件：

  - 调用System.gc()方法的调用。   **-> 不可能，系统中没这样调用**

    此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存


  - 方法区空间不足 **-> 可能性不大**，**静态信息没有很多，不过可以试着将方法区改大试试**

    方法区存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，方法区可能会被占满，从而执行Full GC。

  - 老年代空间不足，对象转入老年代的场景有：
    - 大对象直接进入老年代：为了避免为大对象GC时，多次在survivor上来回复制而降低效率。   **-> 不可能，系统中没很多大对象**
    - 长期存活的对象进入老年代：默认是经历了15次minor GC ，CMS是6次**-> 可能，代码在频繁生成对象，且占用周期比较长。有可能是代码有问题，其实我们可以频繁生成对象，但是应该让他朝生夕死。**
    - **对象动态年龄判断**：survivor区域里，对象年龄从小到大排序，当累加到某个年龄时，占用 survivor区域 的50%，就会把这个年龄大的对象都晋升到老年代。  **-> 可能，因为现在是频繁生成了对象，可以考虑年轻代调大一些。**

  - 老年代空间分配担保机制。**-> 可能性不大，因为老年代挺大的**

    在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。

    - 大于 -> minor GC
    - 小于 ->查看是否开启了空间担保机制
      - 没开启就直接触发full GC，
      - 开启了，就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，会触发full gc。

  ## 3. 可能导致频繁Full GC 的原因

  





## 元空间参数调优

- -XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N
  - **-XX：MaxMetaspaceSize**： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。
  - **-XX：MetaspaceSize**： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发full gc， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。（比如初始值是21M，full gc后，释放了20M，只剩1M，那么垃圾收集器就会将该值调成2M；相反，如果释放了1M，还剩20M，下次就会调整到40M）
- 由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生 了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大。



### 长期存活的对象进入老年代

XX:MaxTenuringThreshold ： 对象晋升到老年代的年龄阈值.默认 15 岁，CMS收集器默认6岁

如果我们可以确定大多数对象都是很快会被回收的，可以将该值调小，比如大多数对象都是3次左右就可以被回收，我们可以设置成5，如果超过了5，就说明剩下的应该是一些类似java bean 这种，会长期存活的对象，我们就没必要，让他再待在survivor占用空间了，提前让他们进入老年代



XX:PretenureSizeThreshold: 大对象的大小

这个一般可以结合你自己系统看下有没有什么大对象 生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始 化分配的缓存对象，比如大的缓存List，Map之类的对象。 



### 对象逃逸分析

-XX:+DoEscapeAnalysis: 开启逃逸分析

 -XX:+EliminateAllocations： 开启标量替换参数

**对象逃逸分析**：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。

JVM对于对象没有被其他地方引用，只在方法作用域有效。可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过**标量替换**优先分配在栈上(**栈上分配**）

### 新生代设置过小

 -Xmn 堆内新生代的大小。

```
‐Xms3072M ‐Xmx3072M ‐Xmn2048M
```

-Xms 堆内存的初始大小.   -Xmx 堆内存的最大大小

新生代设置太小，导致频繁进行minor GC，增大系统消耗

导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC



## 垃圾收集器选择

大内存垃圾回收，使用G1

对于类似Kafka的系统，因为他需要支持每秒处理百万级的消息，所以一般需要大内存机器来部署，比如三四十G，对于这么大的内存，minor GC 即使使用复制算法，也就不再快了，很可能会出现系统每运行一两分钟就会因为minor gc卡顿几秒钟没法处理新消息，这显然是不可以的。使用G1收集器就可以消除长时间的GC停顿，比如设置停顿时间是50ms，后50ms的卡顿其实完全能够接受，用户几乎无感知，那么整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾。



调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现。
1）新生代设置过小
一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC
2）新生代设置过大
一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；二是新生代GC耗时大幅度增加
一般说来新生代占整个堆1/3比较合适
3）Survivor设置过小
导致对象从 eden 直接到达旧生代，降低了在新生代的存活时间
4）Survivor 设置过大
导致eden过小，增加了GC频率
