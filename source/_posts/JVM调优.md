---
title: JVM调优
date: 2022-09-15 15:08:48
tags:
categories: 
---

## 元空间参数调优

- -XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N
  - **-XX：MaxMetaspaceSize**： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。
  - **-XX：MetaspaceSize**： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发full gc， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。（比如初始值是21M，full gc后，释放了20M，只剩1M，那么垃圾收集器就会将该值调成2M；相反，如果释放了1M，还剩20M，下次就会调整到40M）
- 由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生 了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大。



### 长期存活的对象进入老年代

XX:MaxTenuringThreshold ： 对象晋升到老年代的年龄阈值.默认 15 岁，CMS收集器默认6岁

如果我们可以确定大多数对象都是很快会被回收的，可以将该值调小，比如大多数对象都是3次左右就可以被回收，我们可以设置成5，如果超过了5，就说明剩下的应该是一些类似java bean 这种，会长期存活的对象，我们就没必要，让他再待在survivor占用空间了，提前让他们进入老年代



XX:PretenureSizeThreshold: 大对象的大小

这个一般可以结合你自己系统看下有没有什么大对象 生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始 化分配的缓存对象，比如大的缓存List，Map之类的对象。 



### 对象逃逸分析

-XX:+DoEscapeAnalysis: 开启逃逸分析

 -XX:+EliminateAllocations： 开启标量替换参数

**对象逃逸分析**：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。

JVM对于对象没有被其他地方引用，只在方法作用域有效。可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过**标量替换**优先分配在栈上(**栈上分配**）

### 新生代设置过小

 -Xmn 堆内新生代的大小。

```
‐Xms3072M ‐Xmx3072M ‐Xmn2048M
```

-Xms 堆内存的初始大小.   -Xmx 堆内存的最大大小

新生代设置太小，导致频繁进行minor GC，增大系统消耗

导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC







调优手段主要是通过控制堆内存的各个部分的比例和GC策略来实现。
1）新生代设置过小
一是新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间，诱发Full GC
2）新生代设置过大
一是新生代设置过大会导致旧生代过小（堆总量一定），从而诱发Full GC；二是新生代GC耗时大幅度增加
一般说来新生代占整个堆1/3比较合适
3）Survivor设置过小
导致对象从 eden 直接到达旧生代，降低了在新生代的存活时间
4）Survivor 设置过大
导致eden过小，增加了GC频率
