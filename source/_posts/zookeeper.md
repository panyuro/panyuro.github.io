
---

title: zookeeper
date: 2021-09-22 22:43:51
tags: 

- 测试
-  zookeeper

categories:  zookeeper

---



# zookeeper

###  1. zookeeper的产生？

1. 单体向分布式服务转变，会产生多个节点间协同问题，如：

   > - 假设有3个节点，1个job，该job该由哪个节点执行？
   >
   > - 若该job由节点1执行，要是1挂了，现在该2还是3执行？

2. 上游和下游服务的发现，如：

   > * 上游挂了，下游怎么知道？
   > * 下游服务新增，上游怎么知道？

3. 多节点的协调问题，如：并发产生了请求，该怎么保证请求的幂等性？

   

> **由于节点自身协调不可靠，性能不高，故需要一个独立服务来做协调，他必须可靠且保证性能。**

<!-- more -->


#### 2. zookeeper的概要

1. 用于分布式服务的协调服务
2. 由java编写，对外公布API，分布式应用程序可以基于这些API，用于同步节点状态，节点配置，服务注册等信息

#### 3.zookeeper的工作机制

从设计模式的角度理解，zookeeper基于观察者模式。他负责存储和管路大家都关心的数据，然后接受观察，一旦数据状态发生变化，zookeeper就通知注册者。

#### 4.zookeeper 的特点

1. zookeeper是由一个leader和多个follower组成的集群
2. 半数以上节点存活，zookeeper 即可以正常服务
3. 每个server的数据一致
4. 来自同一个client的请求依次执行
5. 原子性，数据更新要么成功，要么失败
6. zookeeper数据量少，故同步快，一定时间内，client可以读到最新数据

#### 5.zookeeper 选举机制

> 原则：
>
> 1. 节点获得半数以上的票数，可被选举
> 2. 节点一上来就选自己，发现不到半数，就会选离自己最近的myId大于自己的节点

案例1. 假设节点总数为3，最终的leader节点是2

1. 第一轮：每个节点都给自己投，所以节点1，节点2，节点3 的票数均为1，投票数未达一半，继续下一轮

2. 第二轮：节点1给离自己最近的节点投，此时为2，2依旧给自己投，节点2的票数过半，选举结束，最终leader为2



![](images/cute.jpeg)









