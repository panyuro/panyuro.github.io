---
title: rabbitMQ入门
date: 2022-09-09 11:16:52
tags: 消息中间件
categories: RabbitMQ
---

# MQ介绍

## 什么是MQ？

- MQ：MessageQueue，消息队列。 队列，是一种FIFO 先进先出的数据结构。
- 消息由生产者发送到MQ进行排队，然后按原来的顺序交由消息的消费者进行处理。
- QQ和微信就是典型的MQ。



## MQ的的优点：

- **异步**：相比于传统的串行、并行执行，可以提高吞吐量。 比如：发快递的时候，我们不需要等待用户接收到快递，而是把快递放进菜鸟驿站，发消息后，离开，用户闲暇时去取快递。

- **解偶**：服务之间进行解耦，才可以减少服务之间的影响。提高系统整体的稳定性以及可扩展性。比如用户下单的场景，用户下单后，订单系统需要通知库存系统减库存，传统的模式，当库存系统无法访问时，用户调用接口失败，从而导致下单失败。但引入MQ后，用户下单后，将下单消息写入消息队列，然后返回用户下单成功，库存系统去订阅下单的消息，去拉取下单信息，从而进行减库存，这时即使库存系统不可用，依旧可以下单成功，实现了订单系统和库存系统的解耦。

- **削峰**：可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请 求。 比如双十一，请求量比较大的时候，我们可以把请求放到MQ里，下游服务再慢慢消费。



## **MQ的缺点**

- 系统可用性降低。系统引入的外部依赖增多，系统的稳定性就会变差。一旦MQ宕机，对业务会产生影响。这就需要考虑如何保证MQ的高可用
- 系统复杂度提高。引入MQ后系统的复杂度会大大提高。以前服务之间可以进行同步的服务调用，引入MQ后，会变为异步调用，数据的链路就会变得更复杂。并且还会带来其他一些问题。比如：如何保证消费不会丢失？不会被重复调用？怎么保证消息的顺序性等问题
- 消息一致性问题。A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统处理成功，C系统处理失败怎么办？这就需要考虑如何保证消息数据处理的一致性。



# **什么是RabbitMQ？** 

RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件

# 为什么选择rabbitmq？

* 支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 
* 支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。
* 开 源的，比较稳定的支持，活跃度也高

> 缺点： 确实 erlang 语言阻止了大量的 Java 工程师 去深入研究和掌控它，对公司而言，几乎处于不可控的状态，



# RabbitMQ的基本概念

-  connection： 客户端与RabbitMQ进行交互，首先就需要建立一个TPC连接，这个连接就是Connection

* Broker： 简单来说就是消息队列服务器实体 

* Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 

* Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 

* Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 

* Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 
* VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部 均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的 权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，类似mysql中的database创建一个table 需要指明用哪个数据库。

# channel信道

- 信道是生产者/消费者与rbabitmq通信的渠道。生产者publish或者消费者consume一个队列都是通过信道完成的。
- 多线程时，rabbitMQ在一条tcp上建立多个信道来处理多线程。
- 每个信道在rabbitmq上有唯一的id,保证一个信道对应一个线程使用。

# 交换机

- 交换机就类似是路由器，他会根据路由键（在rabbitMQ就是routing key），将消息分发到相应的队列上去。

- 交换机的四种类型
  - fanout: 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。(1:N)
  - Direct :   把消息路由到BindingKey和RoutingKey完全匹配的队列中。(1:1)
  - topic: 可以根据模糊匹配，可以将多个消息路由到同一个队列，比如一个队列的routing_key是''.test"那么凡是到达路由器的消息的后缀为“.test”，都会进到这个队列。
    - “* ”只能是一个单词，如“”aa.test“
    - “#”可以是>= 0的单词，如“”test“,"aa.bb.test"
  - `headers`:不依赖路由键匹配规则路由消息。是根据发送消息内容中的`headers`属性进行匹配。性能差，基本用不到。

# 交换机

- 交换机就类似是路由器，他会根据路由键（在rabbitMQ就是routing key），将消息分发到相应的队列上去。

- 交换机的四种类型
  - fanout: 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。(1:N)
  - Direct :   把消息路由到BindingKey和RoutingKey完全匹配的队列中。(1:1)
  - topic: 可以根据模糊匹配，可以将多个消息路由到同一个队列，比如一个队列的routing_key是''.test"那么凡是到达路由器的消息的后缀为“.test”，都会进到这个队列。
    - “* ”只能是一个单词，如“”aa.test“
    - “#”可以是>= 0的单词，如“”test“,"aa.bb.test"
  - `headers`:不依赖路由键匹配规则路由消息。是根据发送消息内容中的`headers`属性进行匹配。性能差，基本用不到。
