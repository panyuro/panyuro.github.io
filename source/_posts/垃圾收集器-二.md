---
title: 垃圾收集器(二)之G1
date: 2022-09-15 16:57:45
tags:
- 性能调优
- 垃圾收集器
categories: JVM
---

[toc]

## **G1收集器**(**-XX:+UseG1GC**)

**G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多核处理器及大容量内存的机器**. 满足**可预测的停顿时间停顿时间的同时,还具备高吞吐量性能特征.** 

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h67e41spm5j218y0ew40m.jpg)

## 一 特点

### 1. 分代收集

- G1将Java堆划分为多个大小相等的独立区域（**Region**），一般Region大小等于堆大小除以2048，JVM最多可以有2048个Region。 

- 这些Region中包含了逻辑上的年轻代和老年代，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。

- 默认年轻代对堆内存的占比是5%，可以通过“-XX:G1NewSizePercent”设置年轻代初始占比。

- 在系统运行中，JVM会不停的给年轻代增加更多的Region，但最多新生代的占比不会超过60%，可以通过“

  -XX:G1MaxNewSizePercent”调整。

- 年轻代中的Eden和 Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100 个，s1对应100个

- 一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。

### 2. **并行与并发**

- 并行性: G1能充分利用CPU、多核环境下的硬件优势，通过多个GC线程同时工作，来缩短Stop-The-World停顿时间。
- 并发性: G1拥有与应用程序交替执行的能力,部分工作可以和应用程序同时执行,因此,一般来说,不会在整个回收阶段发生完全阻塞应用程序的情况

> **并发和并行的区别**
>
> 并行，指的是多个事情，在**同一时间点上**同时发生了。并行的多个任务之间是不互相抢占资源的，系统要有多个CPU才会出现并行
>
> 并发，指的是多个事情，在**同一时间段内**同时发生了。  并发的多个任务之间是互相抢占资源的，整个过程中看似是多个任务同时完成的的，但其实是CPU在多次切换。

### 3. 空间整合

- G1将内存划分为一个个的region。 内存的回收是**以region作为基本单位的**。
- Region之间是复制算法,但整体上实际可看作是**标记- 整理算法**,两种算法都可以避免内存碎片。

### 4. 可预测的停顿

- 降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立**可预测的停顿时间模型**，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数"**-** **XX:MaxGCPauseMillis**"指定)内完成垃圾收集。
- 这里设置的“期望值”必须是符合实际的， 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 最终占满堆引发 Full GC反而降低性能。



## 二 GC的运作过程

- **初始标记**（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，**速度很快** 
- **并发标记**（Concurrent Marking）：同CMS的并发标记 
- **最终标记**（Remark，STW）：同CMS的重新标记 
- **筛选回收**（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划。
  - **G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region**，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。
  - 比如说老年代此时有1000个 Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(**Collection Set**，要回收的集 合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。



## 三 **G1垃圾收集分类** 

**YoungGC** 

- YoungGC并不是说现有的Eden区放满了就会马上触发，
- G1会计算下现在Eden区回收大概要多久时间，如果回收时 间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC 

**MixedGC** 

- 不是FullGC，老年代的占用空间达到整堆的阈值(**-XX:InitiatingHeapOccupancyPercent**设定的值，默认45%)则触发，回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，
- 正常情况G1的垃圾收集是先做 MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现**没有足够** **的空region**能够承载拷贝对象就会触发一次Full GC 

**Full GC** 

- 停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用

- 这个过程是非常耗时的。(Shenandoah优化成多线程收集了) 。Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。 



## 四 G1 大对象的处理

- G1有专门分配 大对象的Region叫**Humongous区**，而不是让大对象直接进入老年代的Region中。
- 在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放 入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。
-  Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开 销。



## **G1收集器参数设置** 



g1算法很复杂，内存不够大，就不要用了
