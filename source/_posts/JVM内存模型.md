---
title: JVM内存模型
date: 2022-09-14 14:22:34
tags:
- 性能调优
categories: JVM调优
---

# JVM内存模型

JVM内存模型总体来说分为五大块。分别是：程序计数器，虚拟机栈，本地方法栈，方法区以及java堆。

![img](https://img-blog.csdnimg.cn/20190428171713239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTIyNjQ3,size_16,color_FFFFFF,t_70)



## 栈

   虚拟机栈（Java Virtual Machine Stacks）描述的是java方法（也就是字节码）执行的内存模型：每个方法在执行的时候都有一个栈帧,用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行就对应了一个栈帧在虚拟机栈中入栈到出栈的过程。

- 线程私有。生命周期与线程相同。
- 在java虚拟机规范中，这个区域规定了两种异常状况。一是 Stack Overflow Error 异常，表示当前线程请求的栈深度大于虚拟机所允许的深度
- 二是Out Of Memory Error 如果所在虚拟机可以扩展，当它扩展时无法得到足够的内存，则会抛出该异常。



## 本地方法栈

   本地方法栈（Native Method Stack）与虚拟机栈发挥的作用是相似的，不同点在于虚拟机栈执行的是java方法服务，而本地方法栈是为虚拟机使用到的Native方法服务。有的虚拟机直接把虚拟机栈和本地方法栈合二为一，与虚拟机栈一样，本地方法栈也会抛出Stack Overflow Error和Out Of Memory Error异常。



## 程序计数器

   程序计数器（Program Counter Register）是一块较小的内存空间，可看做当前线程所执行的字节码行号指令器，字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令。

- 线程私有。每个线程都需要一个独立的程序计数器，个线程之间计数器互不影响，独立存储
- 如果线程正在执行的是一个java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则这个计数器为空。
- 此内存区域是唯一一个在java虚拟机中没有规定 Out Of Memory Error情况的区域。



## 堆

java堆是java虚拟机所管理的内存中最大的一块。它用来存放对象实例和数组。

- 线程共享。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

- java堆是垃圾收集器管理的主要区域，因此很多时候也被称作 “GC堆”（Garbage Collection Heap）。

- java堆可以处于物理不连续的内存空间中，只要逻辑上连续即可。

- 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，则会抛出Out Of Memory Error 。

  

## 方法区

方法区与java堆一样，是线程共享的区域，它里面存储已被虚拟机加载的类信息、静态变量、常量等数据。当方法区无法满足内存分配需求时，会抛出Out Of Memory Error 。运行时常量池是方法区的一部分，用来存放编译器生成的各种字面量和符号的引用。

> - 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。
> - 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存

